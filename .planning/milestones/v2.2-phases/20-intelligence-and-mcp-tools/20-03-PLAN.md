---
phase: 20-intelligence-and-mcp-tools
plan: 03
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - src/paths/path-recall.ts
  - src/hooks/pre-tool-context.ts
  - src/hooks/session-lifecycle.ts
  - src/paths/path-tracker.ts
  - src/paths/path-repository.ts
autonomous: true

must_haves:
  truths:
    - "When new debugging starts on similar issues, relevant past resolved paths are surfaced in context"
    - "Debug paths that span multiple sessions are linked and continued rather than creating duplicates"
    - "Past path recall shows KISS summary so developer gets immediate actionable advice"
  artifacts:
    - path: "src/paths/path-recall.ts"
      provides: "Proactive path recall via similarity matching"
      exports: ["findSimilarPaths"]
    - path: "src/hooks/pre-tool-context.ts"
      provides: "Updated PreToolUse hook that includes path recall"
    - path: "src/hooks/session-lifecycle.ts"
      provides: "Updated SessionStart that checks for suspended paths"
  key_links:
    - from: "src/paths/path-recall.ts"
      to: "src/paths/path-repository.ts"
      via: "pathRepo.listPaths() for candidate paths"
      pattern: "listPaths\\("
    - from: "src/paths/path-recall.ts"
      to: "src/shared/similarity.ts"
      via: "jaccardSimilarity() for error matching"
      pattern: "jaccardSimilarity\\("
    - from: "src/hooks/pre-tool-context.ts"
      to: "src/paths/path-recall.ts"
      via: "findSimilarPaths() when debug signals present"
      pattern: "findSimilarPaths\\("
    - from: "src/hooks/session-lifecycle.ts"
      to: "src/paths/path-tracker.ts"
      via: "PathTracker recovery on SessionStart"
      pattern: "pathTracker"
---

<objective>
Implement proactive path recall (surface relevant past debug paths when new debugging starts) and cross-session path linking (continue suspended paths across session boundaries).

Purpose: INTEL-03 and PATH-06 — developers get "you've seen this before" context automatically, and paths don't fragment across sessions.
Output: path-recall.ts for similarity matching, updated hooks for proactive surfacing and session continuity.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-intelligence-and-mcp-tools/20-01-SUMMARY.md
@src/paths/path-repository.ts
@src/paths/path-tracker.ts
@src/paths/types.ts
@src/shared/similarity.ts
@src/hooks/pre-tool-context.ts
@src/hooks/session-lifecycle.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create path recall module and wire into PreToolUse hook</name>
  <files>src/paths/path-recall.ts, src/hooks/pre-tool-context.ts</files>
  <action>
**path-recall.ts:**

Create a module that finds relevant past resolved debug paths based on text similarity.

1. Import `jaccardSimilarity` from `../shared/similarity.js`
2. Import `PathRepository` from `./path-repository.js`
3. Import `DebugPath` from `./types.js`

4. Export interface `PathRecallResult`:
   ```typescript
   {
     path: DebugPath;
     similarity: number;
     kissSummary: string | null;  // Parsed kiss_summary field
   }
   ```

5. Export function `findSimilarPaths(pathRepo: PathRepository, currentContext: string, limit?: number): PathRecallResult[]`:
   - Get recent resolved paths: `pathRepo.listPaths(50)` then filter to `status === 'resolved'`
   - For each resolved path, compute similarity: `jaccardSimilarity(currentContext, path.trigger_summary)`
   - Also check resolution_summary similarity: `jaccardSimilarity(currentContext, path.resolution_summary ?? '')`
   - Take the MAX of trigger and resolution similarity as the path's score
   - Filter to paths with score >= 0.25 (reasonable threshold for Jaccard on short text)
   - Sort by score DESC
   - Return top `limit` (default 3) results with path, similarity, and kiss_summary (parse from JSON string, null if unparseable)

6. Export function `formatPathRecall(results: PathRecallResult[]): string`:
   - If empty, return empty string
   - Format as:
     ```
     [Laminark] Similar past debug paths found:
     - {trigger_summary.slice(0,80)} (similarity: {score.toFixed(2)})
       KISS: {kiss_summary or "No summary available"}
     ```
   - Cap total output to 600 chars

**pre-tool-context.ts:**

Add path recall to the existing PreToolUse hook. The hook already runs on every tool call. We want to inject path recall context when the tool interaction suggests debugging activity.

1. Add import at top: `import { findSimilarPaths, formatPathRecall } from '../paths/path-recall.js'`
2. Add import: `import { PathRepository } from '../paths/path-repository.js'`

3. Update `handlePreToolUse` signature to accept an optional `pathRepo` parameter:
   ```typescript
   export function handlePreToolUse(
     input: Record<string, unknown>,
     db: BetterSqlite3.Database,
     projectHash: string,
     pathRepo?: PathRepository,
   ): string | null
   ```

4. After the existing FTS5 search and graph lookup sections (before the final output assembly), add a new section:
   ```typescript
   // 3. Path recall for debugging context
   if (pathRepo) {
     try {
       // Use the observation content (tool output or error) as similarity input
       const toolOutput = (toolInput.content as string) ?? (toolInput.command as string) ?? query ?? '';
       if (toolOutput.length > 20) {  // Only search if meaningful content
         const similar = findSimilarPaths(pathRepo, toolOutput, 2);
         const recall = formatPathRecall(similar);
         if (recall) {
           lines.push(recall);
         }
       }
     } catch {
       debug('hook', 'PreToolUse path recall failed');
     }
   }
   ```

5. The hook caller in the MCP server needs to pass pathRepo. Check where handlePreToolUse is called — it's called from the hook handler process (not the MCP server). Since hooks are ephemeral subprocesses, they need their own DB connection and PathRepository. Find the hook entry point that calls handlePreToolUse and add PathRepository construction there.

   Search for where handlePreToolUse is imported/called. It will be in the hook handler entry point. Add PathRepository instantiation there and pass it through. If the hook handler already has a db instance and projectHash, create `new PathRepository(db, projectHash)` and pass it.

   IMPORTANT: The hook handler is a subprocess — it creates its own db connection. The PathRepository is lightweight (just prepared statements). This is safe.
  </action>
  <verify>npx tsc --noEmit src/paths/path-recall.ts src/hooks/pre-tool-context.ts</verify>
  <done>Path recall module finds similar past paths via Jaccard similarity, PreToolUse hook surfaces them when debugging context detected</done>
</task>

<task type="auto">
  <name>Task 2: Cross-session path linking via SessionStart</name>
  <files>src/hooks/session-lifecycle.ts, src/paths/path-repository.ts</files>
  <action>
**path-repository.ts:**

Add a method to find recently active/suspended paths for cross-session linking:

1. Add a new prepared statement in constructor:
   ```typescript
   this.stmtFindRecentActive = db.prepare(`
     SELECT * FROM debug_paths
     WHERE project_hash = ? AND status = 'active'
       AND started_at > datetime('now', '-24 hours')
     ORDER BY started_at DESC
     LIMIT 1
   `);
   ```

2. Add public method `findRecentActivePath(): DebugPath | null`:
   - Run the statement with `this.projectHash`
   - Return mapped DebugPath or null

3. Add a method to list paths by status for better filtering:
   ```typescript
   private readonly stmtListByStatus: BetterSqlite3.Statement;
   ```
   In constructor:
   ```typescript
   this.stmtListByStatus = db.prepare(`
     SELECT * FROM debug_paths
     WHERE project_hash = ? AND status = ?
     ORDER BY started_at DESC
     LIMIT ?
   `);
   ```
   Public method:
   ```typescript
   listPathsByStatus(status: PathStatus, limit: number = 20): DebugPath[] {
     const rows = this.stmtListByStatus.all(this.projectHash, status, limit) as DebugPathRow[];
     return rows.map(rowToDebugPath);
   }
   ```
   Import `PathStatus` from `./types.js`.

**session-lifecycle.ts:**

Add cross-session path linking to the SessionStart handler:

1. Add imports at top:
   ```typescript
   import { PathRepository } from '../paths/path-repository.js';
   import { initPathSchema } from '../paths/schema.js';
   ```

2. Update `handleSessionStart` signature to accept optional pathRepo:
   ```typescript
   export function handleSessionStart(
     input: Record<string, unknown>,
     sessionRepo: SessionRepository,
     db: BetterSqlite3.Database,
     projectHash: string,
     toolRegistry?: ToolRegistryRepository,
     pathRepo?: PathRepository,
   ): string | null
   ```

3. After the existing context assembly (before the return), add cross-session path notification:
   ```typescript
   // PATH-06: Check for active debug paths from prior sessions
   if (pathRepo) {
     try {
       const activePath = pathRepo.findRecentActivePath();
       if (activePath) {
         const waypoints = pathRepo.getWaypoints(activePath.id);
         const lastWaypoint = waypoints[waypoints.length - 1];
         const pathContext = `\n[Laminark] Active debug path carried over from prior session:\n` +
           `  Issue: ${activePath.trigger_summary}\n` +
           `  Waypoints: ${waypoints.length}\n` +
           `  Last activity: ${lastWaypoint?.summary?.slice(0, 100) ?? 'none'}\n` +
           `  Use path_show to see full path, or path_resolve to close it.\n`;
         context = context + pathContext;
       }
     } catch {
       debug('session', 'Cross-session path check failed (non-fatal)');
     }
   }
   ```

   Note: `context` is the variable returned at the end. Since it's a `const`, change it to `let` at its declaration, or append to the return value directly.

4. Find where handleSessionStart is called (in the hook handler entry point) and pass pathRepo. Since the hook handler creates its own db connection, construct `new PathRepository(db, projectHash)` and pass it through. Ensure `initPathSchema(db)` is called before creating PathRepository in the hook handler context.

5. Auto-abandon stale paths: In the same SessionStart section, after checking for active paths, check if any active paths are older than 24 hours and auto-abandon them:
   ```typescript
   if (activePath) {
     const ageMs = Date.now() - new Date(activePath.started_at).getTime();
     if (ageMs > 24 * 60 * 60 * 1000) {
       pathRepo.abandonPath(activePath.id);
       // Don't surface abandoned path — it's stale
     } else {
       // Surface the active path (code above)
     }
   }
   ```
  </action>
  <verify>npx tsc --noEmit src/hooks/session-lifecycle.ts src/paths/path-repository.ts</verify>
  <done>SessionStart detects and surfaces active paths from prior sessions, auto-abandons paths older than 24h, PathRepository has findRecentActivePath() and listPathsByStatus()</done>
</task>

<task type="auto">
  <name>Task 3: Wire pathRepo into hook handler entry point</name>
  <files>src/hooks/pre-tool-context.ts, src/hooks/session-lifecycle.ts</files>
  <action>
Find the hook handler entry point that dispatches to handlePreToolUse and handleSessionStart. Search for the file that imports these functions and calls them based on hook type.

Look for files like `src/hooks/handler.ts`, `src/hooks/index.ts`, or similar entry point. Read it, then:

1. Import PathRepository and initPathSchema
2. After the db and projectHash are available, create pathRepo:
   ```typescript
   initPathSchema(db);
   const pathRepo = new PathRepository(db, projectHash);
   ```
3. Pass pathRepo to handlePreToolUse and handleSessionStart calls

If the hook handler doesn't have a single entry point file (hooks may be registered individually), find each call site and update it.

IMPORTANT: Hook handlers are ephemeral subprocesses that create their own db connections. Creating a PathRepository per invocation is fine — prepared statements are cheap. The key thing is ensuring initPathSchema has been called so the tables exist.

If the hook entry point already calls initPathSchema (from Phase 19 setup), skip the duplicate call.
  </action>
  <verify>npx tsc --noEmit && grep -rn "handlePreToolUse\|handleSessionStart" src/hooks/ --include="*.ts" | grep -v "export function"</verify>
  <done>Hook handler entry point passes PathRepository to both PreToolUse and SessionStart handlers</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- path-recall.ts exists and exports findSimilarPaths, formatPathRecall
- PreToolUse hook includes path recall section
- SessionStart detects and surfaces carried-over debug paths
- Paths older than 24h are auto-abandoned on SessionStart
- PathRepository has findRecentActivePath() and listPathsByStatus()
</verification>

<success_criteria>
- Similar past debug paths surfaced during new debugging via PreToolUse hook
- KISS summaries shown in path recall output for immediate actionable advice
- Active paths from prior sessions detected and surfaced on SessionStart
- Stale paths (>24h) auto-abandoned
- No duplicate paths created when continuing across sessions
</success_criteria>

<output>
After completion, create `.planning/phases/20-intelligence-and-mcp-tools/20-03-SUMMARY.md`
</output>
