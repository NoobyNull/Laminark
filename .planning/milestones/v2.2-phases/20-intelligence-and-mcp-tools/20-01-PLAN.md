---
phase: 20-intelligence-and-mcp-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/paths/kiss-summary-agent.ts
  - src/paths/path-tracker.ts
autonomous: true

must_haves:
  truths:
    - "When a debug path resolves, a KISS summary is generated with root cause and what fixed it"
    - "KISS summary includes multi-layer dimensions: logical, programmatic, development"
    - "KISS summary is stored in the kiss_summary column of debug_paths table"
  artifacts:
    - path: "src/paths/kiss-summary-agent.ts"
      provides: "Haiku-powered KISS summary generation"
      exports: ["generateKissSummary"]
    - path: "src/paths/path-tracker.ts"
      provides: "Updated PathTracker that triggers KISS generation on resolution"
  key_links:
    - from: "src/paths/kiss-summary-agent.ts"
      to: "src/intelligence/haiku-client.ts"
      via: "callHaiku() + extractJsonFromResponse()"
      pattern: "callHaiku\\("
    - from: "src/paths/path-tracker.ts"
      to: "src/paths/kiss-summary-agent.ts"
      via: "generateKissSummary() call on auto-resolve"
      pattern: "generateKissSummary\\("
    - from: "src/paths/kiss-summary-agent.ts"
      to: "src/paths/path-repository.ts"
      via: "repo.getWaypoints() for waypoint context"
      pattern: "getWaypoints\\("
---

<objective>
Create the KISS summary agent that generates actionable "next time, just do X" summaries when debug paths resolve, and wire it into the PathTracker auto-resolution flow.

Purpose: INTEL-01 and INTEL-02 — resolved debug paths produce multi-layer summaries (logical, programmatic, development) so developers get actionable debugging knowledge.
Output: kiss-summary-agent.ts with Haiku-powered summary generation, PathTracker updated to call it on resolution.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/paths/types.ts
@src/paths/path-repository.ts
@src/paths/path-tracker.ts
@src/intelligence/haiku-client.ts
@src/intelligence/haiku-classifier-agent.ts
@src/paths/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KISS summary agent</name>
  <files>src/paths/kiss-summary-agent.ts</files>
  <action>
Create a new Haiku agent module following the exact pattern of haiku-classifier-agent.ts:

1. Import `callHaiku` and `extractJsonFromResponse` from `../intelligence/haiku-client.js`
2. Define a Zod schema for the response:
   ```
   KissSummarySchema = z.object({
     kiss_summary: z.string(),     // "Next time, just do X"
     root_cause: z.string(),       // What actually caused the issue
     what_fixed_it: z.string(),    // The specific fix that resolved it
     dimensions: z.object({
       logical: z.string(),        // Mental model error (e.g., "assumed X was Y")
       programmatic: z.string(),   // Code-level fix (e.g., "change import to dynamic")
       development: z.string(),    // Workflow improvement (e.g., "check logs first")
     }),
   })
   ```
3. Export type `KissSummary` derived from the schema.
4. System prompt instructs Haiku to:
   - Analyze the debug path waypoints (errors, attempts, failures, resolution)
   - Generate a "next time, just do X" summary (kiss_summary field)
   - Identify root cause and what fixed it
   - Produce three dimension summaries: logical (what mental model was wrong), programmatic (what code change fixed it), development (what workflow would catch this faster)
   - Keep each field to 1-2 sentences max
   - Return ONLY JSON, no markdown
5. Export async function `generateKissSummary(triggerSummary: string, waypoints: PathWaypoint[], resolutionSummary: string): Promise<KissSummary>`:
   - Pre-filter waypoints to key types only: 'error', 'failure', 'success', 'resolution', 'discovery' (skip 'attempt' noise)
   - Cap to first 10 filtered waypoints to keep prompt small
   - Format as user content: trigger summary, waypoint list (type + summary each), resolution summary
   - Call `callHaiku(SYSTEM_PROMPT, userContent)`
   - Parse response with `extractJsonFromResponse` then validate with Zod schema
   - Return the parsed KissSummary

Import PathWaypoint type from `./types.js`.
  </action>
  <verify>npx tsc --noEmit src/paths/kiss-summary-agent.ts</verify>
  <done>kiss-summary-agent.ts exports generateKissSummary function and KissSummary type, compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Wire KISS generation into PathTracker resolution</name>
  <files>src/paths/path-tracker.ts</files>
  <action>
Update PathTracker to call generateKissSummary when a path is auto-resolved or manually resolved:

1. Import `generateKissSummary` from `./kiss-summary-agent.js`
2. Add a new private async method `generateAndStoreKiss(pathId: string, resolutionSummary: string): Promise<void>`:
   - Get the path via `this.repo.getPath(pathId)` — if null, return early
   - Get waypoints via `this.repo.getWaypoints(pathId)`
   - Call `generateKissSummary(path.trigger_summary, waypoints, resolutionSummary)`
   - Store result: add a new method call to repo (see below)
   - Wrap entire body in try/catch — KISS generation is non-fatal, log with `debug('paths', 'KISS generation failed', ...)`

3. In `updateResolutionCounter`, after `this.repo.resolvePath(...)` and before state reset:
   - Save pathId and resolutionSummary to local vars before they get cleared
   - Fire-and-forget: `this.generateAndStoreKiss(savedPathId, savedResolutionSummary).catch(...)` — do NOT await (async background, don't block state machine)

4. Add a new public method `resolveManually(resolutionSummary: string): void` for use by MCP tools:
   - If no currentPathId or state !== 'active_debug', return early
   - Add resolution waypoint via `this.repo.addWaypoint(this.currentPathId, 'resolution', resolutionSummary)`
   - Call `this.repo.resolvePath(this.currentPathId, resolutionSummary)`
   - Fire-and-forget KISS generation
   - Reset state to idle, clear currentPathId, consecutiveSuccesses, errorBuffer

5. Add a new public method `startManually(triggerSummary: string): string | null`:
   - If state is already 'active_debug', return currentPathId (already tracking)
   - Create path via `this.repo.createPath(triggerSummary)`
   - Set state to 'active_debug', store currentPathId
   - Reset consecutiveSuccesses and errorBuffer
   - Return the new path id

6. Add a public getter `getActivePathId(): string | null` returning this.currentPathId.

7. Add prepared statement to PathRepository for updating kiss_summary:
   In path-repository.ts, add a new prepared statement and method:
   - `stmtUpdateKiss` prepared as: `UPDATE debug_paths SET kiss_summary = ? WHERE id = ? AND project_hash = ?`
   - Public method `updateKissSummary(pathId: string, kissSummary: string): void` that runs the statement

Wait — path-repository.ts is NOT in this plan's files_modified. Instead, have the kiss-summary-agent return a JSON string, and in PathTracker.generateAndStoreKiss, use a direct db.prepare approach? No — better to add updateKissSummary to PathRepository. Update files_modified to include path-repository.ts.

Actually, add the repo method inline in this task since it's one statement:
- In path-repository.ts, add `stmtUpdateKiss` prepared statement in constructor
- Add `updateKissSummary(pathId: string, kissSummary: string): void` method
- In PathTracker.generateAndStoreKiss, call `this.repo.updateKissSummary(pathId, JSON.stringify(kissSummary))` where kissSummary is the full KissSummary object serialized as JSON

This stores the structured KISS data in the kiss_summary TEXT column (already exists in schema from Phase 19).
  </action>
  <verify>npx tsc --noEmit && grep -n "generateAndStoreKiss\|resolveManually\|startManually\|updateKissSummary" src/paths/path-tracker.ts src/paths/path-repository.ts</verify>
  <done>PathTracker auto-generates KISS summaries on resolution, has resolveManually() and startManually() for MCP tools, PathRepository has updateKissSummary()</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- kiss-summary-agent.ts exists and exports generateKissSummary
- path-tracker.ts has resolveManually, startManually, getActivePathId methods
- path-repository.ts has updateKissSummary method
- KISS generation is fire-and-forget (non-blocking) in auto-resolve flow
</verification>

<success_criteria>
- KISS summary agent created following existing Haiku agent pattern
- Multi-layer dimensions (logical, programmatic, development) in schema
- PathTracker triggers KISS generation on auto-resolve (non-blocking)
- PathTracker exposes manual start/resolve methods for MCP tools (Plan 02)
- PathRepository can update kiss_summary column
</success_criteria>

<output>
After completion, create `.planning/phases/20-intelligence-and-mcp-tools/20-01-SUMMARY.md`
</output>
