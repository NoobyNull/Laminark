---
phase: 20-intelligence-and-mcp-tools
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - src/mcp/tools/debug-paths.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can explicitly start a debug path via path_start MCP tool"
    - "User can explicitly resolve an active path via path_resolve MCP tool"
    - "User can view a path with waypoints and KISS summary via path_show MCP tool"
    - "User can list recent paths filtered by status via path_list MCP tool"
  artifacts:
    - path: "src/mcp/tools/debug-paths.ts"
      provides: "Four MCP tools: path_start, path_resolve, path_show, path_list"
      exports: ["registerDebugPathTools"]
    - path: "src/index.ts"
      provides: "Registration call for debug path tools"
  key_links:
    - from: "src/mcp/tools/debug-paths.ts"
      to: "src/paths/path-tracker.ts"
      via: "pathTracker.startManually(), resolveManually(), getActivePathId()"
      pattern: "pathTracker\\."
    - from: "src/mcp/tools/debug-paths.ts"
      to: "src/paths/path-repository.ts"
      via: "pathRepo.getPath(), listPaths(), getWaypoints()"
      pattern: "pathRepo\\."
    - from: "src/index.ts"
      to: "src/mcp/tools/debug-paths.ts"
      via: "registerDebugPathTools()"
      pattern: "registerDebugPathTools\\("
---

<objective>
Create four MCP tools (path_start, path_resolve, path_show, path_list) for explicit user control over debug path lifecycle.

Purpose: UI-01 through UI-04 — when auto-detection needs override, users can manually start, resolve, inspect, and list debug paths.
Output: debug-paths.ts with all four tools registered, wired into index.ts.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-intelligence-and-mcp-tools/20-01-SUMMARY.md
@src/mcp/tools/query-graph.ts
@src/paths/path-tracker.ts
@src/paths/path-repository.ts
@src/paths/types.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create debug-paths MCP tool module</name>
  <files>src/mcp/tools/debug-paths.ts</files>
  <action>
Create a new MCP tool module following the exact pattern of query-graph.ts (server.registerTool with Zod schemas).

Export a single registration function:
```typescript
export function registerDebugPathTools(
  server: McpServer,
  pathRepo: PathRepository,
  pathTracker: PathTracker,
  notificationStore: NotificationStore | null,
  projectHash: string,
): void
```

Inside, register four tools:

**1. path_start (UI-01)**
- Description: "Explicitly start tracking a debug path. Use when auto-detection hasn't triggered but you're actively debugging."
- Input: `{ trigger: z.string().describe("Brief description of the issue being debugged") }`
- Handler:
  - Call `pathTracker.startManually(args.trigger)`
  - If returns existing pathId (already active): return text "Debug path already active: {pathId}"
  - If returns new pathId: return text "Debug path started: {pathId}\nTracking: {trigger}"
  - Prepend notifications (follow query-graph.ts pattern)

**2. path_resolve (UI-02)**
- Description: "Explicitly resolve the active debug path with a resolution summary. Use when auto-detection hasn't detected resolution."
- Input: `{ resolution: z.string().describe("What fixed the issue") }`
- Handler:
  - Call `pathTracker.getActivePathId()` — if null, return error "No active debug path to resolve"
  - Call `pathTracker.resolveManually(args.resolution)`
  - Return text "Debug path resolved: {pathId}\nResolution: {resolution}\nKISS summary generating in background..."

**3. path_show (UI-03)**
- Description: "Show a debug path with its waypoints and KISS summary."
- Input: `{ path_id: z.string().optional().describe("Path ID to show. Omit for active path.") }`
- Handler:
  - If path_id provided: `pathRepo.getPath(args.path_id)` — if null, return error
  - If path_id omitted: `pathRepo.getActivePath()` — if null, return error "No active debug path"
  - Get waypoints: `pathRepo.getWaypoints(path.id)`
  - Format output as readable text:
    ```
    ## Debug Path: {path.id}
    Status: {path.status}
    Started: {path.started_at}
    Trigger: {path.trigger_summary}

    ### Waypoints ({count})
    1. [{waypoint.waypoint_type}] {waypoint.summary} ({waypoint.created_at})
    2. ...

    ### Resolution
    {path.resolution_summary ?? "Still active"}

    ### KISS Summary
    {Parsed kiss_summary JSON or "Not yet generated"}
    ```
  - For KISS summary: parse the JSON string from path.kiss_summary, format as:
    ```
    **Next time:** {kiss_summary}
    **Root cause:** {root_cause}
    **What fixed it:** {what_fixed_it}
    **Logical:** {dimensions.logical}
    **Programmatic:** {dimensions.programmatic}
    **Development:** {dimensions.development}
    ```
  - If kiss_summary is null or fails to parse, show "KISS summary not yet generated"

**4. path_list (UI-04)**
- Description: "List recent debug paths, optionally filtered by status."
- Input:
  ```
  {
    status: z.enum(['active', 'resolved', 'abandoned']).optional().describe("Filter by status"),
    limit: z.number().int().min(1).max(50).default(10).describe("Max paths to return")
  }
  ```
- Handler:
  - Call `pathRepo.listPaths(args.limit)`
  - If status filter provided, filter in-memory: `paths.filter(p => p.status === args.status)`
  - Format as text table:
    ```
    ## Debug Paths

    | ID (short) | Status | Trigger | Started | Resolved |
    |------------|--------|---------|---------|----------|
    | {id.slice(0,8)} | {status} | {trigger.slice(0,50)} | {started_at} | {resolved_at ?? '-'} |
    ```
  - If no paths found: "No debug paths found"

Use the same helper patterns from query-graph.ts: `textResponse()`, `errorResponse()`, `prependNotifications()`. Define them locally or import — simplest to define locally since they're trivial 1-liners.
  </action>
  <verify>npx tsc --noEmit src/mcp/tools/debug-paths.ts</verify>
  <done>Four MCP tools registered: path_start, path_resolve, path_show, path_list with Zod schemas and text formatting</done>
</task>

<task type="auto">
  <name>Task 2: Wire debug path tools into server startup</name>
  <files>src/index.ts</files>
  <action>
1. Add import at top of index.ts:
   ```typescript
   import { registerDebugPathTools } from './mcp/tools/debug-paths.js';
   ```

2. After the existing tool registrations (after `registerReportTools` block, around line 265), add:
   ```typescript
   registerDebugPathTools(server, pathRepo, pathTracker, notificationStore, projectHash);
   ```

   Note: `pathRepo` and `pathTracker` are already instantiated at lines 271-272 of index.ts. The registerDebugPathTools call must come AFTER those lines. Place it after line 272 (after pathTracker creation) and before `startServer(server)`.

3. Verify the registration is unconditional (not gated behind any feature flag — paths are always available since Phase 19).
  </action>
  <verify>npx tsc --noEmit && grep "registerDebugPathTools" src/index.ts</verify>
  <done>Debug path MCP tools registered on server startup, available to Claude immediately</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- All four tools registered: path_start, path_resolve, path_show, path_list
- Tools properly accept Zod-validated inputs
- path_show displays KISS summary when available
- index.ts imports and calls registerDebugPathTools
</verification>

<success_criteria>
- path_start creates new debug path or returns existing active one
- path_resolve resolves active path and triggers KISS generation
- path_show displays path details, waypoints, and formatted KISS summary
- path_list shows recent paths with optional status filter
- All tools wired into MCP server via index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/20-intelligence-and-mcp-tools/20-02-SUMMARY.md`
</output>
