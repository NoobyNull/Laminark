---
phase: 19-path-detection-and-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/paths/types.ts
  - src/paths/schema.ts
  - src/paths/path-repository.ts
  - src/storage/migrations.ts
autonomous: true

must_haves:
  truths:
    - "Debug paths persist in dedicated SQLite tables with ordered waypoints"
    - "Waypoints have distinct types including dead-end tracking"
    - "Paths survive MCP server restarts via SQLite persistence"
  artifacts:
    - path: "src/paths/types.ts"
      provides: "DebugPath, PathWaypoint, WaypointType type definitions"
      exports: ["DebugPath", "PathWaypoint", "WaypointType", "PathStatus", "WAYPOINT_TYPES"]
    - path: "src/paths/schema.ts"
      provides: "DDL for debug_paths and path_waypoints tables"
      exports: ["initPathSchema"]
    - path: "src/paths/path-repository.ts"
      provides: "CRUD operations for debug paths and waypoints"
      exports: ["PathRepository"]
    - path: "src/storage/migrations.ts"
      provides: "Migration 020 for debug path tables"
      contains: "debug_paths"
  key_links:
    - from: "src/paths/path-repository.ts"
      to: "src/paths/types.ts"
      via: "imports DebugPath, PathWaypoint types"
      pattern: "import.*from.*types"
    - from: "src/paths/schema.ts"
      to: "src/storage/migrations.ts"
      via: "DDL matches migration 020 schema"
      pattern: "debug_paths"
---

<objective>
Create the persistence layer for debug resolution paths: type definitions, SQLite schema, and repository CRUD.

Purpose: PATH-04 and PATH-05 require dedicated SQLite tables for debug paths and waypoints. This is the foundation that PathTracker (Plan 03) writes to and reads from. Per locked decision: paths stored in dedicated tables, NOT embedded in graph_nodes.

Output: src/paths/ directory with types, schema initialization, and PathRepository class.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/storage/migrations.ts
@src/graph/types.ts
@src/storage/observations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Path type definitions and SQLite schema</name>
  <files>src/paths/types.ts, src/paths/schema.ts, src/storage/migrations.ts</files>
  <action>
Create `src/paths/types.ts` with:

```typescript
// Waypoint types as const array (same pattern as graph/types.ts)
export const WAYPOINT_TYPES = [
  'error',        // Error encountered
  'attempt',      // Fix attempted
  'failure',      // Attempted fix didn't work (dead end - PATH-05)
  'success',      // Something worked
  'pivot',        // Changed approach
  'revert',       // Reverted a change
  'discovery',    // Learned something useful
  'resolution',   // Final fix that resolved the issue
] as const;

export type WaypointType = (typeof WAYPOINT_TYPES)[number];

export type PathStatus = 'active' | 'resolved' | 'abandoned';

export interface DebugPath {
  id: string;
  status: PathStatus;
  trigger_summary: string;
  resolution_summary: string | null;
  kiss_summary: string | null;   // For Phase 20
  started_at: string;            // ISO 8601
  resolved_at: string | null;
  project_hash: string;
}

export interface PathWaypoint {
  id: string;
  path_id: string;
  observation_id: string | null; // Links to observations table
  waypoint_type: WaypointType;
  sequence_order: number;
  summary: string;
  created_at: string;
}
```

Create `src/paths/schema.ts` with `initPathSchema(db)` function that creates:
- `debug_paths` table (id TEXT PRIMARY KEY, status TEXT CHECK(IN 'active','resolved','abandoned'), trigger_summary TEXT NOT NULL, resolution_summary TEXT, kiss_summary TEXT, started_at TEXT NOT NULL, resolved_at TEXT, project_hash TEXT NOT NULL)
- `path_waypoints` table (id TEXT PRIMARY KEY, path_id TEXT NOT NULL REFERENCES debug_paths(id), observation_id TEXT, waypoint_type TEXT CHECK(IN waypoint types), sequence_order INTEGER NOT NULL, summary TEXT NOT NULL, created_at TEXT NOT NULL)
- Index on debug_paths(project_hash, status)
- Index on debug_paths(started_at DESC)
- Index on path_waypoints(path_id, sequence_order)
- Use `CREATE TABLE IF NOT EXISTS` pattern (same as graph/schema.ts initGraphSchema)

Add migration 020 to MIGRATIONS array in `src/storage/migrations.ts`:
- Version 20, name: 'create_debug_path_tables'
- SQL creates both tables and all indexes
- Follow the exact pattern of existing migrations (string SQL, not function)

Use randomBytes hex IDs (same as graph/schema.ts pattern). Schema must use TEXT PRIMARY KEY not INTEGER AUTOINCREMENT since paths use UUID-style IDs.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Grep for "version: 20" in migrations.ts to confirm migration added.</verify>
  <done>types.ts exports all path types, schema.ts creates tables idempotently, migration 020 exists in MIGRATIONS array.</done>
</task>

<task type="auto">
  <name>Task 2: PathRepository CRUD operations</name>
  <files>src/paths/path-repository.ts</files>
  <action>
Create `src/paths/path-repository.ts` following the pattern of ObservationRepository (project-scoped, prepared statements, constructor takes db + projectHash):

```typescript
export class PathRepository {
  constructor(db: BetterSqlite3.Database, projectHash: string)
```

Methods needed:

**Path lifecycle:**
- `createPath(triggerSummary: string): DebugPath` — generates UUID id via randomBytes, sets status='active', started_at=now
- `resolvePath(pathId: string, resolutionSummary: string): void` — sets status='resolved', resolved_at=now, resolution_summary
- `abandonPath(pathId: string): void` — sets status='abandoned', resolved_at=now
- `getActivePath(): DebugPath | null` — returns the active path for this project (at most one active at a time)
- `getPath(pathId: string): DebugPath | null` — get by ID
- `listPaths(limit?: number): DebugPath[]` — list recent paths for project, default limit 20, ordered by started_at DESC

**Waypoint management:**
- `addWaypoint(pathId: string, type: WaypointType, summary: string, observationId?: string): PathWaypoint` — generates UUID id, auto-increments sequence_order based on MAX(sequence_order) for that path_id + 1
- `getWaypoints(pathId: string): PathWaypoint[]` — ordered by sequence_order ASC
- `countWaypoints(pathId: string): number` — for cap enforcement (max 30 per path)

All methods use prepared statements cached on the instance (same pattern as ObservationRepository). Project-scoped: all queries filter by project_hash.

Import types from './types.js'. Use `import type BetterSqlite3 from 'better-sqlite3'` for the db type. Generate IDs with `randomBytes(16).toString('hex')` from node:crypto.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors.</verify>
  <done>PathRepository class exports with all lifecycle and waypoint methods, prepared statements for performance, project-scoped queries.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `src/paths/types.ts` exports DebugPath, PathWaypoint, WaypointType, PathStatus, WAYPOINT_TYPES
- `src/paths/schema.ts` exports initPathSchema
- `src/paths/path-repository.ts` exports PathRepository with createPath, resolvePath, addWaypoint, getActivePath, getWaypoints
- Migration 020 exists in MIGRATIONS array
- No modifications to graph_nodes or graph_edges tables (per locked decision)
</verification>

<success_criteria>
- All path types defined with const array pattern matching graph/types.ts
- Two new SQLite tables (debug_paths, path_waypoints) defined in schema and migration
- PathRepository provides full CRUD with project scoping
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/19-path-detection-and-storage/19-01-SUMMARY.md`
</output>
