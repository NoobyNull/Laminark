# Roadmap: Laminark v2.2 Debug Resolution Paths

## Overview

Transform debugging from throwaway noise into first-class knowledge artifacts. Laminark automatically detects when debugging begins, captures the journey as ordered waypoints, detects resolution, and distills the messy path into a KISS summary ("next time, just do X"). Debug paths live as graph entities with D3 breadcrumb visualization and MCP tools for explicit control.

## Phases

- [ ] **Phase 19: Path Detection & Storage** - Automatic debug session lifecycle with waypoint capture and SQLite persistence
- [ ] **Phase 20: Intelligence & MCP Tools** - KISS summaries, proactive recall, cross-session linking, and explicit path control tools
- [ ] **Phase 21: Graph Visualization** - D3 breadcrumb trail overlay with path detail panel

## Phase Details

### Phase 19: Path Detection & Storage
**Goal**: System automatically detects debugging, captures the journey as ordered waypoints, and persists everything to SQLite
**Depends on**: Phase 18 (Agent SDK Migration — Haiku pipeline)
**Requirements**: PATH-01, PATH-02, PATH-03, PATH-04, PATH-05
**Success Criteria** (what must be TRUE):
  1. When a developer hits repeated errors during any task, the system automatically begins tracking a debug path without manual intervention
  2. Meaningful waypoints (errors, attempts, pivots, reverts, discoveries) are recorded in order during active debug — noise (routine reads, unchanged files) is filtered out
  3. When the developer resolves the issue (tests pass, errors stop), the system automatically closes the path
  4. Dead ends (attempted fixes that failed) are tracked as distinct waypoint types, distinguishable from successful steps
  5. Debug paths and their waypoints persist across MCP server restarts via dedicated SQLite tables
**Plans**: TBD

### Phase 20: Intelligence & MCP Tools
**Goal**: Resolved paths produce actionable KISS summaries, past paths surface proactively during new debugging, and users have explicit MCP control over path lifecycle
**Depends on**: Phase 19
**Requirements**: INTEL-01, INTEL-02, INTEL-03, PATH-06, UI-01, UI-02, UI-03, UI-04
**Success Criteria** (what must be TRUE):
  1. When a debug path resolves, a KISS summary is generated that tells the developer "next time, just do X" with root cause and what fixed it
  2. KISS summaries include multi-layer dimensions: logical (mental model error), programmatic (code-level fix), and development (workflow improvement)
  3. When new debugging starts on a similar issue (same files, similar errors), relevant past debug paths are surfaced in context
  4. Debug paths that span multiple sessions (developer closes and reopens Claude) are linked and continued rather than creating duplicates
  5. User can explicitly start, resolve, show, and list debug paths via MCP tools when auto-detection needs override
**Plans**: TBD

### Phase 21: Graph Visualization
**Goal**: Debug paths are visually explorable as animated breadcrumb trails overlaid on the knowledge graph
**Depends on**: Phase 19 (Phase 20 not required — visualization works with or without summaries)
**Requirements**: UI-05, UI-06, UI-07
**Success Criteria** (what must be TRUE):
  1. Debug paths render as animated dashed lines connecting waypoint nodes on the D3 graph, with waypoints color-coded by type (error: red, attempt: yellow, resolution: green)
  2. Clicking a path node opens a detail panel showing the ordered waypoint timeline, KISS summary (if resolved), and linked entities
  3. A toggle control in the graph toolbar shows/hides the path overlay without affecting the underlying knowledge graph
**Plans**: TBD

## Progress

**Execution Order:** 19 -> 20 -> 21 (Phase 21 can begin after 19 if needed, but 20 is the natural next step)

| Phase | Plans Complete | Status | Completed |
|-------|----------------|--------|-----------|
| 19. Path Detection & Storage | 0/TBD | Not started | - |
| 20. Intelligence & MCP Tools | 0/TBD | Not started | - |
| 21. Graph Visualization | 0/TBD | Not started | - |
