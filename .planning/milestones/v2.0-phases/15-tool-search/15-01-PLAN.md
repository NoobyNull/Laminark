---
phase: 15-tool-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/migrations.ts
  - src/storage/tool-registry.ts
  - src/shared/tool-types.ts
autonomous: true

must_haves:
  truths:
    - "FTS5 keyword search on tool_registry name+description returns ranked results"
    - "Vector search on tool_registry_embeddings returns tools by semantic similarity"
    - "Hybrid search fuses FTS5 and vector results via reciprocal rank fusion"
    - "Query sanitization prevents FTS5 syntax errors from user input"
    - "Scope filtering narrows results to a single scope when specified"
  artifacts:
    - path: "src/storage/migrations.ts"
      provides: "Migration 18 with FTS5 + vec0 tables for tool registry"
      contains: "tool_registry_fts"
    - path: "src/storage/tool-registry.ts"
      provides: "searchTools hybrid search method"
      contains: "searchTools"
    - path: "src/shared/tool-types.ts"
      provides: "ToolSearchResult type definition"
      contains: "ToolSearchResult"
  key_links:
    - from: "src/storage/tool-registry.ts"
      to: "src/search/hybrid.ts"
      via: "reciprocalRankFusion import"
      pattern: "reciprocalRankFusion"
    - from: "src/storage/migrations.ts"
      to: "tool_registry table"
      via: "FTS5 external content reference"
      pattern: "content='tool_registry'"
---

<objective>
Add FTS5 and vec0 search indexing for the tool registry, and implement hybrid search methods on ToolRegistryRepository.

Purpose: Provides the search foundation that the `discover_tools` MCP tool (Plan 02) will call. Without this, tool descriptions cannot be searched by keyword or semantic meaning.

Output: Migration 18 (FTS5 + vec0 tables), ToolSearchResult type, searchTools() and supporting methods on ToolRegistryRepository.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-tool-search/15-RESEARCH.md
@src/storage/migrations.ts
@src/storage/tool-registry.ts
@src/shared/tool-types.ts
@src/search/hybrid.ts
@src/storage/search.ts
@src/storage/embeddings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migration 18 and ToolSearchResult type</name>
  <files>src/storage/migrations.ts, src/shared/tool-types.ts</files>
  <action>
1. Add `ToolSearchResult` interface to `src/shared/tool-types.ts`:
   ```typescript
   export interface ToolSearchResult {
     tool: ToolRegistryRow;
     score: number;
     matchType: 'fts' | 'vector' | 'hybrid';
   }
   ```

2. Add migration 18 to `src/storage/migrations.ts` as a functional migration (like migration 11/14/15) because the vec0 table creation must be conditional on `hasVectorSupport`. The migration function receives `db` as parameter:

   a. FTS5 table (always created):
   ```sql
   CREATE VIRTUAL TABLE tool_registry_fts USING fts5(
     name,
     description,
     content='tool_registry',
     content_rowid='id',
     tokenize='porter unicode61'
   );
   ```

   b. Three sync triggers (same pattern as observations_fts in migration 5):
   - `tool_registry_ai` AFTER INSERT: insert new.id, new.name, new.description
   - `tool_registry_au` AFTER UPDATE: delete old row, insert new row
   - `tool_registry_ad` AFTER DELETE: delete old row

   c. FTS5 rebuild to index existing tool_registry rows:
   ```sql
   INSERT INTO tool_registry_fts(tool_registry_fts) VALUES('rebuild');
   ```

   d. vec0 table (conditional -- only if the db has sqlite-vec). Since this is a functional migration, check for vec0 support by attempting the CREATE and catching failure, OR pass `hasVectorSupport` flag. The simplest approach: use a try/catch around the vec0 CREATE to match the graceful degradation pattern:
   ```sql
   CREATE VIRTUAL TABLE IF NOT EXISTS tool_registry_embeddings USING vec0(
     tool_id INTEGER PRIMARY KEY,
     embedding float[384] distance_metric=cosine
   );
   ```
   Wrap this in try/catch -- if vec0 module is unavailable, skip silently.

3. Update the `runMigrations` function: migration 18 is a functional migration, so no special handling needed (the existing `typeof m.up === 'function'` branch handles it). However, do NOT add migration 18 to the vec0-skip list (lines that check `migration.version === 4 || migration.version === 6`). The FTS5 portion must always run; only the vec0 portion is conditional, and the functional migration handles that internally.

4. Update the migration doc comment at the top of the MIGRATIONS array to include:
   `Migration 018: Tool registry FTS5 + vec0 tables for hybrid search on tool descriptions.`
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles. Verify migration 18 exists in the MIGRATIONS array with version 18 and name 'create_tool_registry_search'.
  </verify>
  <done>
Migration 18 is defined as a functional migration creating tool_registry_fts (always), sync triggers, FTS5 rebuild, and tool_registry_embeddings (conditional on vec0 availability). ToolSearchResult type is exported from tool-types.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Hybrid search methods on ToolRegistryRepository</name>
  <files>src/storage/tool-registry.ts</files>
  <action>
1. Add imports at top of tool-registry.ts:
   ```typescript
   import { reciprocalRankFusion } from '../search/hybrid.js';
   import type { ToolSearchResult } from '../shared/tool-types.js';
   ```
   Note: ToolSearchResult is already in the same tool-types.ts file that ToolRegistryRow comes from, so it can be added to the existing import.

2. Add a private `sanitizeQuery` method to ToolRegistryRepository (extract the pattern from SearchEngine in search.ts -- copy the logic, do not import SearchEngine since it's observation-scoped):
   ```typescript
   private sanitizeQuery(query: string): string | null {
     const words = query.trim().split(/\s+/).filter(Boolean);
     if (words.length === 0) return null;
     const sanitized = words
       .map(w => {
         let cleaned = w.replace(/["*()^{}[\]]/g, '');
         if (/^(NEAR|OR|AND|NOT)$/i.test(cleaned)) return '';
         cleaned = cleaned.replace(/[^\w\-]/g, '');
         return cleaned;
       })
       .filter(Boolean);
     if (sanitized.length === 0) return null;
     return sanitized.join(' ');
   }
   ```

3. Add `searchByKeyword` method to ToolRegistryRepository:
   ```typescript
   searchByKeyword(query: string, options?: { scope?: string; limit?: number }): ToolSearchResult[] {
     const sanitized = this.sanitizeQuery(query);
     if (!sanitized) return [];
     const limit = options?.limit ?? 20;

     let sql = `
       SELECT tr.*, bm25(tool_registry_fts, 2.0, 1.0) AS rank
       FROM tool_registry_fts
       JOIN tool_registry tr ON tr.id = tool_registry_fts.rowid
       WHERE tool_registry_fts MATCH ?
     `;
     const params: unknown[] = [sanitized];

     if (options?.scope) {
       sql += ' AND tr.scope = ?';
       params.push(options.scope);
     }

     sql += ' ORDER BY rank LIMIT ?';
     params.push(limit);

     try {
       const rows = this.db.prepare(sql).all(...params) as (ToolRegistryRow & { rank: number })[];
       return rows.map(row => ({
         tool: { ...row, rank: undefined } as unknown as ToolRegistryRow,
         score: Math.abs(row.rank),
         matchType: 'fts' as const,
       }));
     } catch (err) {
       debug('tool-registry', 'FTS5 search failed', { error: String(err) });
       return [];
     }
   }
   ```
   Note: Clean up the `rank` property from the spread by destructuring or mapping to a clean ToolRegistryRow (remove the `rank` field from the returned `tool` object).

4. Add `searchByVector` method:
   ```typescript
   searchByVector(queryEmbedding: Float32Array, options?: { scope?: string; limit?: number }): Array<{ toolId: number; distance: number }> {
     const limit = options?.limit ?? 40;
     try {
       let sql = `
         SELECT tre.tool_id, tre.distance
         FROM tool_registry_embeddings tre
       `;
       const params: unknown[] = [queryEmbedding];

       if (options?.scope) {
         sql += ' JOIN tool_registry tr ON tr.id = tre.tool_id WHERE tre.embedding MATCH ? AND tr.scope = ?';
         params.push(options.scope);
       } else {
         sql += ' WHERE tre.embedding MATCH ?';
       }

       sql += ' ORDER BY tre.distance LIMIT ?';
       params.push(limit);

       return this.db.prepare(sql).all(...params) as Array<{ tool_id: number; distance: number }>;
     } catch (err) {
       debug('tool-registry', 'Vector search failed', { error: String(err) });
       return [];
     }
   }
   ```
   Return `tool_id` (snake_case matching SQL column name).

5. Add the main `searchTools` method that combines FTS5 + vector via RRF:
   ```typescript
   async searchTools(
     query: string,
     options?: {
       scope?: string;
       limit?: number;
       worker?: { isReady(): boolean; embed(text: string): Promise<Float32Array | null> } | null;
       hasVectorSupport?: boolean;
     },
   ): Promise<ToolSearchResult[]> {
     const limit = options?.limit ?? 20;

     // Step 1: FTS5 keyword search
     const ftsResults = this.searchByKeyword(query, { scope: options?.scope, limit });

     // Step 2: Vector search (if available)
     let vectorResults: Array<{ tool_id: number; distance: number }> = [];
     if (options?.worker?.isReady() && options?.hasVectorSupport) {
       const queryEmbedding = await options.worker.embed(query);
       if (queryEmbedding) {
         vectorResults = this.searchByVector(queryEmbedding, { scope: options?.scope, limit: limit * 2 });
       }
     }

     // Step 3: FTS-only fallback
     if (vectorResults.length === 0) {
       return ftsResults.slice(0, limit);
     }

     // Step 4: Fuse with RRF
     const ftsRanked = ftsResults.map(r => ({ id: String(r.tool.id) }));
     const vecRanked = vectorResults.map(r => ({ id: String(r.tool_id) }));
     const fused = reciprocalRankFusion([ftsRanked, vecRanked]);

     // Build lookup maps
     const ftsMap = new Map<string, ToolSearchResult>();
     for (const r of ftsResults) {
       ftsMap.set(String(r.tool.id), r);
     }
     const vecIds = new Set(vectorResults.map(r => String(r.tool_id)));

     // Assemble results
     const results: ToolSearchResult[] = [];
     for (const item of fused) {
       if (results.length >= limit) break;
       const fromFts = ftsMap.get(item.id);
       const fromVec = vecIds.has(item.id);

       if (fromFts) {
         results.push({
           tool: fromFts.tool,
           score: item.fusedScore,
           matchType: fromFts && fromVec ? 'hybrid' : 'fts',
         });
       } else if (fromVec) {
         // Vector-only: look up the full tool row
         const toolRow = this.db.prepare('SELECT * FROM tool_registry WHERE id = ?').get(Number(item.id)) as ToolRegistryRow | undefined;
         if (toolRow) {
           results.push({
             tool: toolRow,
             score: item.fusedScore,
             matchType: 'vector',
           });
         }
       }
     }

     return results;
   }
   ```

6. Add `storeEmbedding` method for the background embedding loop (Plan 02 will call this):
   ```typescript
   storeEmbedding(toolId: number, embedding: Float32Array): void {
     try {
       this.db.prepare(
         'INSERT OR REPLACE INTO tool_registry_embeddings(tool_id, embedding) VALUES (?, ?)'
       ).run(toolId, embedding);
     } catch (err) {
       debug('tool-registry', 'Failed to store tool embedding', { toolId, error: String(err) });
     }
   }
   ```

7. Add `findUnembeddedTools` method for the background embedding loop:
   ```typescript
   findUnembeddedTools(limit: number = 5): Array<{ id: number; name: string; description: string }> {
     try {
       return this.db.prepare(`
         SELECT id, name, description FROM tool_registry
         WHERE description IS NOT NULL
           AND id NOT IN (SELECT tool_id FROM tool_registry_embeddings)
         LIMIT ?
       `).all(limit) as Array<{ id: number; name: string; description: string }>;
     } catch (err) {
       debug('tool-registry', 'Failed to find unembedded tools', { error: String(err) });
       return [];
     }
   }
   ```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles with no errors. Verify that `searchTools`, `searchByKeyword`, `searchByVector`, `sanitizeQuery`, `storeEmbedding`, and `findUnembeddedTools` are all present on ToolRegistryRepository.
  </verify>
  <done>
ToolRegistryRepository has searchTools() (hybrid FTS5+vector via RRF), searchByKeyword() (FTS5), searchByVector() (vec0 KNN), sanitizeQuery() (FTS5 safety), storeEmbedding(), and findUnembeddedTools(). All methods handle errors gracefully with debug logging and empty-array fallbacks.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Migration 18 exists in MIGRATIONS array with version 18
3. ToolSearchResult type exported from src/shared/tool-types.ts
4. ToolRegistryRepository has searchTools, searchByKeyword, searchByVector, storeEmbedding, findUnembeddedTools methods
5. sanitizeQuery strips FTS5 operators (AND, OR, NOT, NEAR) and special characters
6. reciprocalRankFusion imported from src/search/hybrid.ts
</verification>

<success_criteria>
- Migration 18 creates tool_registry_fts (FTS5 with name+description, porter unicode61 tokenizer, sync triggers, rebuild) and tool_registry_embeddings (vec0 384-dim cosine, conditional on sqlite-vec)
- searchTools() combines FTS5 + vector results via RRF, degrades to FTS5-only when vector unavailable
- Query sanitization prevents FTS5 syntax errors from arbitrary user input
- Scope filtering applies at the SQL level (not post-filter)
- storeEmbedding and findUnembeddedTools support the background embedding loop
</success_criteria>

<output>
After completion, create `.planning/phases/15-tool-search/15-01-SUMMARY.md`
</output>
