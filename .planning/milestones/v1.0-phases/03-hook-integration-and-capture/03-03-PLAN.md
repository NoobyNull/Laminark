---
phase: 03-hook-integration-and-capture
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - hooks/hooks.json
  - src/hooks/handler.ts
  - src/hooks/__tests__/handler.test.ts
  - src/hooks/__tests__/integration.test.ts
autonomous: true

must_haves:
  truths:
    - "hooks/hooks.json configures PostToolUse, PostToolUseFailure, SessionStart, SessionEnd, and Stop events to invoke the hook handler"
    - "PostToolUse and PostToolUseFailure are async:true; SessionStart is sync (no async flag)"
    - "The hook handler runs privacy filter before admission filter before database write"
    - "A PostToolUse event with noise content (e.g., npm install output) does not produce a stored observation"
    - "A PostToolUse event with an API key in tool_input has the key redacted in the stored observation"
    - "A PostToolUse event targeting a .env file produces no observation at all"
    - "End-to-end: piping a PostToolUse JSON to the hook handler creates a correctly-filtered observation in the database"
    - "End-to-end: piping SessionStart then SessionEnd JSONs creates and closes a session record"
  artifacts:
    - path: "hooks/hooks.json"
      provides: "Claude Code plugin hook configuration for all 5 event types"
      contains: "CLAUDE_PLUGIN_ROOT"
      min_lines: 20
    - path: "src/hooks/handler.ts"
      provides: "Updated handler with privacy and admission filter wiring"
      contains: "redactSensitiveContent"
    - path: "src/hooks/__tests__/handler.test.ts"
      provides: "Handler unit tests for stdin parsing, dispatch, and filter pipeline"
      min_lines: 40
    - path: "src/hooks/__tests__/integration.test.ts"
      provides: "End-to-end tests: JSON stdin -> filter pipeline -> database verification"
      min_lines: 80
  key_links:
    - from: "src/hooks/handler.ts"
      to: "src/hooks/privacy-filter.ts"
      via: "redactSensitiveContent() called before admission check"
      pattern: "redactSensitiveContent"
    - from: "src/hooks/handler.ts"
      to: "src/hooks/admission-filter.ts"
      via: "shouldAdmit() called after privacy filter"
      pattern: "shouldAdmit"
    - from: "hooks/hooks.json"
      to: "dist/hooks/handler.js"
      via: "command field referencing ${CLAUDE_PLUGIN_ROOT}"
      pattern: "CLAUDE_PLUGIN_ROOT.*dist/hooks/handler\\.js"
---

<objective>
Wire the privacy and admission filters into the hook handler, create the hooks.json plugin configuration, and prove the entire capture pipeline works end-to-end with integration tests.

Purpose: This plan brings together the three independent pieces: the handler (Plan 01), the filters (Plan 02), and the Claude Code plugin configuration (hooks.json). After this plan, the complete observation capture pipeline is functional -- tool usage flows through privacy redaction, noise detection, and into the database. Integration tests prove all 4 Phase 3 success criteria.

Output: Complete, tested hook integration system ready for Claude Code plugin deployment. hooks.json configures all 5 hook events. Integration tests prove end-to-end capture with filtering.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-hook-integration-and-capture/03-RESEARCH.md

# Prior plan summaries needed (handler structure + filter APIs)
@.planning/phases/03-hook-integration-and-capture/03-01-SUMMARY.md
@.planning/phases/03-hook-integration-and-capture/03-02-SUMMARY.md

# Source files being wired together
@src/hooks/handler.ts
@src/hooks/capture.ts
@src/hooks/session-lifecycle.ts
@src/hooks/admission-filter.ts
@src/hooks/privacy-filter.ts
@src/shared/config.ts

# Test utilities
@src/storage/__tests__/test-utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hooks.json and wire filters into handler</name>
  <files>
    hooks/hooks.json
    src/hooks/handler.ts
  </files>
  <action>
Create `hooks/hooks.json` with the Claude Code plugin hook configuration. This file goes at the plugin root (`hooks/hooks.json`) and uses `${CLAUDE_PLUGIN_ROOT}` for paths:

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/dist/hooks/handler.js\"",
            "async": true,
            "timeout": 10
          }
        ]
      }
    ],
    "PostToolUseFailure": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/dist/hooks/handler.js\"",
            "async": true,
            "timeout": 10
          }
        ]
      }
    ],
    "SessionStart": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/dist/hooks/handler.js\"",
            "timeout": 5
          }
        ]
      }
    ],
    "SessionEnd": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/dist/hooks/handler.js\"",
            "async": true,
            "timeout": 10
          }
        ]
      }
    ],
    "Stop": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "node \"${CLAUDE_PLUGIN_ROOT}/dist/hooks/handler.js\"",
            "async": true,
            "timeout": 10
          }
        ]
      }
    ]
  }
}
```

Key configuration decisions (from research):
- `async: true` for PostToolUse, PostToolUseFailure, SessionEnd, Stop -- fire-and-forget, non-blocking
- NO `async` for SessionStart -- sync/blocking to allow future Phase 5 context injection
- `matcher: ""` (empty) matches ALL tool names -- capture everything, let filters decide
- `timeout: 10` for async hooks, `timeout: 5` for SessionStart (keep fast)

Update `src/hooks/handler.ts` to wire in the privacy and admission filters:

1. Import `redactSensitiveContent`, `isExcludedFile` from `./privacy-filter.js`
2. Import `shouldAdmit` from `./admission-filter.js`
3. In the PostToolUse/PostToolUseFailure dispatch path, AFTER calling `extractObservation()` from capture.ts but BEFORE calling `obsRepo.create()`:
   a. Extract the file_path from tool_input if present (for file exclusion check)
   b. Call `isExcludedFile(filePath)` -- if true, skip entirely (debug log and return)
   c. Call `redactSensitiveContent(observationText, filePath)` -- if returns null, skip (file was excluded)
   d. Call `shouldAdmit(tool_name, redactedText)` -- if false, skip (noise detected)
   e. Only if all filters pass, call `obsRepo.create()` with the redacted text

The filter order matters: privacy first (redact secrets before any other processing), then admission (reject noise). This ensures we never accidentally log secret content in debug messages from the admission filter.

Update the capture.ts `processPostToolUse` function to accept filter functions as parameters (or restructure so the handler calls extractObservation + filters + create in sequence rather than having processPostToolUse do everything). The goal is that `handler.ts` orchestrates the pipeline: extract -> privacy filter -> admission filter -> store.
  </action>
  <verify>
1. `hooks/hooks.json` is valid JSON (use `node -e "JSON.parse(require('fs').readFileSync('hooks/hooks.json', 'utf-8'))"`)
2. `npm run check` passes with no type errors
3. `npx tsdown` succeeds (handler still builds with new imports)
  </verify>
  <done>
hooks.json configures all 5 hook event types with correct async/sync settings. Handler wires privacy filter -> admission filter -> database write in the correct order. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create handler unit tests and end-to-end integration tests</name>
  <files>
    src/hooks/__tests__/handler.test.ts
    src/hooks/__tests__/integration.test.ts
  </files>
  <action>
Create `src/hooks/__tests__/handler.test.ts` with unit tests for the handler's filter pipeline:

1. Test that PostToolUse with a Write tool and clean content produces a stored observation
2. Test that PostToolUse with noise Bash output (npm WARN) does NOT produce a stored observation
3. Test that PostToolUse with an API key in content produces a stored observation with the key REDACTED
4. Test that PostToolUse targeting a .env file produces NO observation
5. Test that PostToolUseFailure events are captured (with error info in the observation)
6. Test that mcp__laminark__save_memory tool is skipped
7. Test that Stop events do NOT create observations
8. Test that SessionStart creates a session and SessionEnd closes it
9. Test that unknown/missing hook_event_name is handled gracefully (no crash)

For these unit tests, call the handler's internal pipeline functions directly (not via stdin). Create the temp database using createTempDb(), instantiate repositories, and call the dispatch/pipeline logic.

Create `src/hooks/__tests__/integration.test.ts` with end-to-end tests that simulate the full hook invocation:

1. **E2E: PostToolUse Write -> observation stored**
   - Build a PostToolUse JSON payload for a Write tool
   - Pipe it to the handler via child_process (fork or exec the built dist/hooks/handler.js with stdin)
   - Wait for process exit
   - Open the database and verify the observation exists with correct content and source
   - Verify exit code is 0

2. **E2E: PostToolUse Bash with noise -> no observation**
   - Build a PostToolUse JSON payload for Bash with `npm install` output
   - Pipe to handler
   - Verify NO observation was stored (database query returns empty)
   - Verify exit code is 0

3. **E2E: PostToolUse with API key -> observation stored with redaction**
   - Build payload with content containing `sk-abcdefghijklmnopqrstuvwxyz12345678`
   - Pipe to handler
   - Verify observation stored with `[REDACTED:api_key]` in content
   - Verify exit code is 0

4. **E2E: Session lifecycle -> session created and closed**
   - Pipe SessionStart JSON, then pipe SessionEnd JSON with same session_id
   - Verify session exists in database with started_at and ended_at both set
   - Verify exit code is 0 for both

5. **E2E: Invalid JSON -> exits 0 (no crash)**
   - Pipe `"not json {{{"`
   - Verify exit code is 0 (handler catches and swallows error)

For E2E tests, use `child_process.execSync` or `child_process.fork` with a temporary LAMINARK_DB_PATH environment variable pointing to a temp database (or set up the temp db path via environment variable). The handler uses `getDatabaseConfig()` which reads `getDbPath()` -- for testing, either:
- Set `LAMINARK_HOME` or similar env var to redirect to temp dir, OR
- Create the temp database at the default path and clean up after, OR
- Refactor `getDbPath()` to check an env var override (e.g., `LAMINARK_DATA_DIR`)

The simplest approach: add `LAMINARK_DATA_DIR` environment variable support to `getConfigDir()` in `src/shared/config.ts` (check `process.env.LAMINARK_DATA_DIR` first, fall back to `~/.laminark`). This is a one-line addition that enables testability without complex mocking. Update the function:
```typescript
export function getConfigDir(): string {
  const dir = process.env.LAMINARK_DATA_DIR || join(homedir(), '.laminark');
  mkdirSync(dir, { recursive: true });
  return dir;
}
```

This approach also benefits all future testing (Phase 4+).
  </action>
  <verify>
Run `npm test` and verify ALL tests pass (Phase 1 tests + Phase 3 capture/filter/handler/integration tests). Run `npm run check` for type safety.
  </verify>
  <done>
Handler unit tests prove the filter pipeline works correctly (noise rejected, secrets redacted, .env excluded, self-referential skipped). Integration tests prove end-to-end flow from stdin JSON through filters to database storage. All 4 Phase 3 success criteria are demonstrated by tests:
1. Tool usage -> observation captured (E2E Write test)
2. Session lifecycle tracked (E2E session test)
3. Noise filtered out (E2E Bash noise test)
4. Sensitive content excluded (E2E API key redaction test)
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes -- ALL tests pass (Phase 1 + Phase 3)
2. `npm run check` passes with no type errors
3. `npx tsdown` builds both entry points
4. hooks/hooks.json is valid JSON with all 5 event types configured
5. Integration tests prove all 4 Phase 3 success criteria:
   - SC1: Tool usage auto-captures observation
   - SC2: Session start/end tracked with session IDs
   - SC3: Noise filtered out
   - SC4: Sensitive content excluded/redacted
</verification>

<success_criteria>
- hooks.json configures all 5 hook events with correct async/sync flags
- Handler pipeline: extract -> privacy filter -> admission filter -> store
- Integration tests prove end-to-end capture with real database
- Noise content is rejected (build output, package install, linter spam)
- Sensitive content is redacted (API keys, JWTs, connection strings)
- .env file observations are fully excluded
- Handler always exits 0 even with invalid input
- All Phase 1 tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/03-hook-integration-and-capture/03-03-SUMMARY.md`
</output>
