---
phase: 05-session-context-and-summaries
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/curation/summarizer.ts
  - src/curation/index.ts
  - src/storage/sessions.ts
  - scripts/stop-hook.sh
  - hooks/hooks.json
  - src/curation/summarizer.test.ts
autonomous: true

must_haves:
  truths:
    - "When a session ends via Stop hook, observations from that session are compressed into a concise summary"
    - "Session summaries are stored in the sessions table with the summary column populated"
    - "Summaries are concise (under 500 tokens) even when session had many observations"
    - "If a session has zero observations, no summary is generated (graceful no-op)"
  artifacts:
    - path: "src/curation/summarizer.ts"
      provides: "Session summary generation from observations"
      exports: ["generateSessionSummary", "compressObservations"]
    - path: "src/curation/index.ts"
      provides: "Curation module barrel export"
      exports: ["generateSessionSummary"]
    - path: "scripts/stop-hook.sh"
      provides: "Stop hook script that triggers summary generation"
      contains: "curl.*session-summary"
    - path: "hooks/hooks.json"
      provides: "Hook configuration registering the Stop event"
      contains: "Stop"
  key_links:
    - from: "scripts/stop-hook.sh"
      to: "src/ingest/receiver.ts"
      via: "HTTP POST to core process /session-summary endpoint"
      pattern: "curl.*localhost.*session-summary"
    - from: "src/curation/summarizer.ts"
      to: "src/storage/sessions.ts"
      via: "reads session observations, writes summary back to session row"
      pattern: "getSessionObservations|updateSessionSummary"
    - from: "src/curation/summarizer.ts"
      to: "src/storage/observations.ts"
      via: "queries observations by sessionId for compression"
      pattern: "getObservationsBySession"
---

<objective>
Session summary generation at Stop hook -- compress session observations into concise summaries.

Purpose: When a Claude Code session ends, the system compresses all observations captured during that session into a concise, reusable summary stored in the sessions table. This summary becomes the primary context artifact injected into future sessions (Plan 05-02). Without summaries, context injection would need to load raw observations, which is too verbose and slow.

Output: A summarizer module that extracts key insights from session observations, a Stop hook script that triggers summarization, and updated hooks.json registering the Stop event.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session summarizer module with observation compression</name>
  <files>
    src/curation/summarizer.ts
    src/curation/index.ts
    src/storage/sessions.ts
    src/curation/summarizer.test.ts
  </files>
  <action>
    1. Create `src/curation/summarizer.ts` with these functions:

       **`compressObservations(observations: Observation[]): string`**
       - Takes an array of observations from a single session
       - Extracts key information: decisions made, files modified, problems encountered, solutions applied, tools used
       - Groups observations by source type (hook:PostToolUse, mcp:save_memory, etc.)
       - Produces a structured text summary with sections:
         ```
         ## Session Summary
         **Duration:** {startedAt} to {endedAt}
         **Observations:** {count}

         ### Key Activities
         - {bullet points of significant actions, max 10}

         ### Decisions & Insights
         - {any explicitly saved memories or notable decisions}

         ### Files Touched
         - {list of unique file paths mentioned, max 15}
         ```
       - Target output: under 500 tokens (~375 words). If observations exceed this when summarized, prioritize: explicit saves > decisions > file edits > tool output
       - This is a heuristic text-based summarizer (no LLM call). Extract patterns from observation content using simple heuristics:
         - File paths: regex `/[a-zA-Z_/.-]+\.[a-zA-Z]+/`
         - Decisions: observations containing "decided", "chose", "will use", "going with"
         - Problems: observations containing "error", "failed", "bug", "issue", "fix"
         - Solutions: observations containing "fixed", "resolved", "solved", "working now"

       **`generateSessionSummary(sessionId: string, db: DatabaseConnection): SessionSummary | null`**
       - Queries all observations for the given sessionId from the storage layer
       - If zero observations, returns null (no summary needed)
       - Calls `compressObservations()` to generate the summary text
       - Updates the session row's `summary` column via `updateSessionSummary(sessionId, summaryText)`
       - Returns `{ sessionId, summary: string, observationCount: number, generatedAt: string }`

       Define a `SessionSummary` type:
       ```typescript
       export interface SessionSummary {
         sessionId: string;
         summary: string;
         observationCount: number;
         generatedAt: string;
       }
       ```

    2. Add to `src/storage/sessions.ts` (modify existing file from Phase 1):
       - `getSessionObservations(sessionId: string): Observation[]` -- returns all non-deleted observations for a session, ordered by createdAt
       - `updateSessionSummary(sessionId: string, summary: string): void` -- updates the summary column on the session row, sets updatedAt timestamp
       - If these functions already exist from Phase 3, verify they work correctly and add them if missing

    3. Create `src/curation/index.ts` as barrel export:
       ```typescript
       export { generateSessionSummary, compressObservations } from './summarizer.js';
       export type { SessionSummary } from './summarizer.js';
       ```

    4. Create `src/curation/summarizer.test.ts` with tests:
       - Test compressObservations with empty array returns empty summary
       - Test compressObservations with 3 observations produces structured output
       - Test compressObservations with 50+ observations stays under 500 tokens (~2000 chars)
       - Test file path extraction from observation content
       - Test decision keyword detection
       - Test generateSessionSummary returns null for session with no observations

    Note: Do NOT use an LLM/API call for summarization. This is a heuristic text summarizer. The research mentions Claude Agent SDK compression as an option, but for Phase 5 we use deterministic text extraction to keep the Stop hook fast and dependency-free. LLM-powered summaries can be added as an enhancement later.
  </action>
  <verify>
    1. `npx vitest run src/curation/summarizer.test.ts` passes all tests
    2. `npx tsc --noEmit` passes with zero type errors
    3. Grep confirms summarizer.ts exports generateSessionSummary and compressObservations
    4. Grep confirms sessions.ts has getSessionObservations and updateSessionSummary
    5. Test confirms output of compressObservations for 50 observations is under 2000 characters
  </verify>
  <done>
    Session summarizer module exists with heuristic text compression. Given a session's observations, it extracts key activities, decisions, insights, and file paths into a structured summary under 500 tokens. The storage layer supports reading session observations and writing summaries back. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Stop hook script and register in hooks.json</name>
  <files>
    scripts/stop-hook.sh
    hooks/hooks.json
  </files>
  <action>
    1. Create `scripts/stop-hook.sh`:
       ```bash
       #!/bin/bash
       # Stop hook: triggers session summary generation when Claude Code session ends
       # Reads session info from stdin JSON, POSTs to core process to generate summary
       # This hook runs async (non-blocking) so it doesn't delay session shutdown

       INPUT=$(cat)
       SESSION_ID=$(echo "$INPUT" | node -e "
         let d=''; process.stdin.on('data',c=>d+=c);
         process.stdin.on('end',()=>{try{console.log(JSON.parse(d).session_id||'')}catch{console.log('')}})
       " 2>/dev/null)

       if [ -n "$SESSION_ID" ]; then
         curl -s -X POST "http://localhost:37819/session-summary" \
           -H "Content-Type: application/json" \
           -d "{\"sessionId\": \"$SESSION_ID\"}" &
       fi

       exit 0
       ```
       Make the script executable: `chmod +x scripts/stop-hook.sh`

       Note: The port 37819 matches the ingest receiver port from Phase 3's architecture. If Phase 3 used a different port, match that port. The `&` on curl makes this fire-and-forget -- the hook exits immediately while the summary generates in the background.

    2. Update `hooks/hooks.json` to register the Stop hook. Read the existing file first (Phase 3 may have already created it with PostToolUse, SessionStart, SessionEnd hooks). Add the Stop hook entry:
       ```json
       {
         "hooks": [
           // ... existing hooks from Phase 3 ...
           {
             "event": "Stop",
             "script": "scripts/stop-hook.sh",
             "async": true,
             "timeout": 30000
           }
         ]
       }
       ```
       The Stop hook uses `async: true` because summary generation can take a moment and must not block session shutdown. The 30-second timeout is generous -- heuristic summarization should complete in under 1 second, but network latency to the core process could add delay.

    3. Add a `/session-summary` POST endpoint to the ingest receiver (`src/ingest/receiver.ts`). This endpoint:
       - Accepts `{ sessionId: string }` in the request body
       - Calls `generateSessionSummary(sessionId, db)` from the curation module
       - Returns 200 with the summary if generated, 204 if no observations to summarize
       - Returns 400 if sessionId is missing
       - Wraps in try/catch, returns 500 on error (summary generation must not crash the core process)

    If `src/ingest/receiver.ts` does not exist yet (Phase 3 may not have been executed), create a minimal version with just the `/session-summary` endpoint. The hook dispatcher endpoints from Phase 3 can be added later. Use Node.js built-in `http` module or Hono (if already installed) for the HTTP server.
  </action>
  <verify>
    1. `bash -n scripts/stop-hook.sh` passes syntax check
    2. `test -x scripts/stop-hook.sh` confirms executable permission
    3. `cat hooks/hooks.json | node -e "JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'))"` validates JSON
    4. Grep confirms hooks.json contains "Stop" event entry
    5. Grep confirms receiver.ts has a /session-summary route
    6. `npx tsc --noEmit` passes with zero type errors
  </verify>
  <done>
    Stop hook script exists, is executable, and fires asynchronously when Claude Code session ends. hooks.json registers the Stop event. The core process has a /session-summary endpoint that receives the session ID and triggers summary generation. Summary results are written to the session row in the database.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run` passes all tests including summarizer tests
- `npx tsc --noEmit` passes with zero type errors
- scripts/stop-hook.sh is executable and syntactically valid
- hooks/hooks.json is valid JSON containing a "Stop" event entry
- Session summary generation produces structured output under 500 tokens
- Zero-observation sessions produce no summary (graceful no-op)
</verification>

<success_criteria>
- CTX-02 is satisfied: session summaries are generated at Stop hook by compressing session observations
- Summarizer produces concise structured text (under 500 tokens) from any number of session observations
- Stop hook fires asynchronously and does not block session shutdown
- Summary is persisted in the sessions table for retrieval by Plan 05-02
</success_criteria>

<output>
After completion, create `.planning/phases/05-session-context-and-summaries/05-01-SUMMARY.md`
</output>
