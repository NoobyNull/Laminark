---
phase: 01-storage-engine
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/storage/database.ts
  - src/storage/migrations.ts
  - src/storage/index.ts
autonomous: true

must_haves:
  truths:
    - "Opening the database creates data.db at ~/.laminark/"
    - "Database operates in WAL mode with busy_timeout of 5000ms"
    - "Schema has observations table with INTEGER PRIMARY KEY AUTOINCREMENT rowid and TEXT UNIQUE id"
    - "FTS5 external content table exists with content_rowid='rowid' referencing the stable integer rowid"
    - "FTS5 sync triggers exist for INSERT, UPDATE, and DELETE operations"
    - "Closing and reopening the database preserves all data and schema"
    - "Migration system tracks applied versions and skips already-applied ones"
    - "sqlite-vec loads successfully or degrades gracefully without error"
  artifacts:
    - path: "src/storage/database.ts"
      provides: "Database connection manager with WAL mode, PRAGMA setup, sqlite-vec loading"
      exports: ["openDatabase"]
      min_lines: 60
    - path: "src/storage/migrations.ts"
      provides: "Version-tracked schema migration system"
      exports: ["runMigrations", "MIGRATIONS"]
      min_lines: 80
  key_links:
    - from: "src/storage/database.ts"
      to: "better-sqlite3"
      via: "new Database(dbPath) constructor call"
      pattern: "import.*better-sqlite3"
    - from: "src/storage/database.ts"
      to: "sqlite-vec"
      via: "sqliteVec.load(db) for extension loading"
      pattern: "sqliteVec\\.load"
    - from: "src/storage/database.ts"
      to: "src/storage/migrations.ts"
      via: "runMigrations called after PRAGMA setup"
      pattern: "runMigrations"
    - from: "src/storage/migrations.ts"
      to: "observations_fts"
      via: "Migration creates FTS5 external content table with triggers"
      pattern: "content='observations'.*content_rowid='rowid'"
---

<objective>
SQLite database initialization with WAL mode, PRAGMA configuration, sqlite-vec extension loading, schema creation via migrations, and FTS5 full-text indexing.

Purpose: Establish the durable storage foundation that every subsequent plan reads from and writes to. The schema design addresses the critical FTS5 rowid stability issue identified in research: observations uses explicit `INTEGER PRIMARY KEY AUTOINCREMENT` with text `id` as a UNIQUE column. WAL mode and correct PRAGMA ordering prevent the corruption vectors documented in research. The migration system enables schema evolution across all 8 phases without data loss.
Output: An `openDatabase` function that returns a properly configured SQLite database with WAL mode, FTS5, optional sqlite-vec, and all schema tables created.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-storage-engine/01-RESEARCH.md
@.planning/phases/01-storage-engine/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database connection manager with WAL mode, PRAGMAs, and sqlite-vec</name>
  <files>
    src/storage/database.ts
  </files>
  <action>
    Create `src/storage/database.ts` that exports an `openDatabase` function returning a configured better-sqlite3 Database instance plus metadata.

    **Function signature:**
    ```typescript
    export interface LaminarkDatabase {
      db: BetterSqlite3.Database;
      hasVectorSupport: boolean;
      close(): void;
      checkpoint(): void;
    }

    export function openDatabase(config: DatabaseConfig): LaminarkDatabase;
    ```

    **Implementation of openDatabase:**

    1. Ensure the directory for config.dbPath exists: `mkdirSync(dirname(config.dbPath), { recursive: true })`

    2. Create the better-sqlite3 connection: `new Database(config.dbPath)`

    3. Set PRAGMAs in this EXACT order (order matters per research):
       ```
       journal_mode = WAL          -- MUST be first (persistent, stored in DB file)
       busy_timeout = {config.busyTimeout}  -- Per-connection, must set every time
       synchronous = NORMAL        -- Safe ONLY with WAL, faster than FULL
       cache_size = -64000         -- 64MB (negative = KiB)
       foreign_keys = ON           -- Per-connection, not persistent
       temp_store = MEMORY         -- Temp tables in memory
       wal_autocheckpoint = 1000   -- Explicit (default, prevents WAL growth)
       ```
       Use `db.pragma('key = value')` for each. Verify WAL mode is active by checking the return value of the journal_mode pragma -- if it returns something other than 'wal' (e.g., on a read-only filesystem), log a warning.

    4. Load sqlite-vec extension with graceful degradation:
       ```typescript
       import * as sqliteVec from 'sqlite-vec';

       let hasVectorSupport = false;
       try {
         sqliteVec.load(db);
         hasVectorSupport = true;
       } catch {
         // Vector search unavailable -- keyword-only mode
       }
       ```
       Note: Use `sqliteVec.load(db)` -- NOT `db.loadExtension()`. The sqlite-vec npm package provides its own load function that handles platform-specific binary resolution.

    5. Run migrations (call imported `runMigrations` -- implemented in Task 2):
       ```typescript
       runMigrations(db, hasVectorSupport);
       ```

    6. Return the LaminarkDatabase object with:
       - `close()`: Run `db.pragma('wal_checkpoint(PASSIVE)')` to flush WAL, then `db.close()`. Wrap in try/catch -- if checkpoint fails (e.g., locked), still close.
       - `checkpoint()`: Run `db.pragma('wal_checkpoint(PASSIVE)')` for periodic maintenance.

    **Key design decisions (from research):**
    - Single connection per process. better-sqlite3 is synchronous, so connection pooling adds zero benefit.
    - `BEGIN IMMEDIATE` is NOT manually needed because better-sqlite3's `db.transaction()` already uses it by default.
    - WAL mode is persistent (survives reconnection), but busy_timeout and foreign_keys are NOT -- they must be set every time.

    Import DatabaseConfig from `../shared/config.js` (use .js extension for NodeNext ESM resolution).
  </action>
  <verify>
    1. `npx tsc --noEmit` passes
    2. Create a quick test or script that:
       - Calls openDatabase with a temp path
       - Verifies `db.pragma('journal_mode', { simple: true })` returns 'wal'
       - Verifies `db.pragma('busy_timeout', { simple: true })` returns 5000
       - Verifies `db.pragma('synchronous', { simple: true })` returns 1 (NORMAL)
       - Verifies `db.pragma('foreign_keys', { simple: true })` returns 1 (ON)
       - Calls close()
       - Verifies the .db file exists on disk
  </verify>
  <done>
    openDatabase creates a WAL-mode SQLite connection with correct PRAGMA order (journal_mode first, then busy_timeout, synchronous, cache_size, foreign_keys, temp_store, wal_autocheckpoint). sqlite-vec loads or gracefully degrades. close() checkpoints WAL before shutdown. Single connection per process by design.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create migration system and initial schema with FTS5 external content</name>
  <files>
    src/storage/migrations.ts
    src/storage/index.ts
  </files>
  <action>
    1. Create `src/storage/migrations.ts` with a version-tracked migration system:

       **Migration tracking table** (created by runMigrations before applying any migrations):
       ```sql
       CREATE TABLE IF NOT EXISTS _migrations (
         version INTEGER PRIMARY KEY,
         name TEXT NOT NULL,
         applied_at TEXT NOT NULL DEFAULT (datetime('now'))
       );
       ```

       **Migration interface and runner:**
       ```typescript
       interface Migration {
         version: number;
         name: string;
         up: string;  // SQL to execute
       }

       export function runMigrations(db: BetterSqlite3.Database, hasVectorSupport: boolean): void {
         // 1. Create _migrations table if not exists
         // 2. Get max applied version: SELECT COALESCE(MAX(version), 0) FROM _migrations
         // 3. For each unapplied migration:
         //    - Run in a transaction (db.transaction)
         //    - Execute the SQL
         //    - INSERT into _migrations
       }
       ```

       **CRITICAL SCHEMA DESIGN -- Migration 001 (Observations):**

       The observations table MUST use `rowid INTEGER PRIMARY KEY AUTOINCREMENT` as the primary key column, NOT `id TEXT PRIMARY KEY`. This is the critical finding from research: FTS5 external content tables require a STABLE integer rowid for `content_rowid`. Implicit rowid on a TEXT PRIMARY KEY table is NOT stable across VACUUM.

       ```sql
       CREATE TABLE observations (
         rowid INTEGER PRIMARY KEY AUTOINCREMENT,
         id TEXT NOT NULL UNIQUE DEFAULT (lower(hex(randomblob(16)))),
         project_hash TEXT NOT NULL,
         content TEXT NOT NULL,
         source TEXT NOT NULL DEFAULT 'unknown',
         session_id TEXT,
         embedding BLOB,
         embedding_model TEXT,
         embedding_version TEXT,
         created_at TEXT NOT NULL DEFAULT (datetime('now')),
         updated_at TEXT NOT NULL DEFAULT (datetime('now')),
         deleted_at TEXT
       );

       CREATE INDEX idx_observations_project ON observations(project_hash);
       CREATE INDEX idx_observations_session ON observations(session_id);
       CREATE INDEX idx_observations_created ON observations(created_at);
       CREATE INDEX idx_observations_deleted ON observations(deleted_at) WHERE deleted_at IS NOT NULL;
       ```

       Note the partial index on deleted_at -- only indexes non-NULL values since most rows will have NULL deleted_at.

       **Migration 002 (Sessions):**
       ```sql
       CREATE TABLE sessions (
         id TEXT PRIMARY KEY,
         project_hash TEXT NOT NULL,
         started_at TEXT NOT NULL DEFAULT (datetime('now')),
         ended_at TEXT,
         summary TEXT
       );

       CREATE INDEX idx_sessions_project ON sessions(project_hash);
       CREATE INDEX idx_sessions_started ON sessions(started_at);
       ```

       **Migration 003 (FTS5 External Content + Sync Triggers):**

       This migration creates the FTS5 virtual table with `content='observations'` and `content_rowid='rowid'`, referencing the STABLE integer rowid. Then creates the three required sync triggers.

       ```sql
       CREATE VIRTUAL TABLE observations_fts USING fts5(
         content,
         content='observations',
         content_rowid='rowid',
         tokenize='porter unicode61'
       );

       -- Sync trigger: INSERT
       CREATE TRIGGER observations_ai AFTER INSERT ON observations BEGIN
         INSERT INTO observations_fts(rowid, content)
           VALUES (new.rowid, new.content);
       END;

       -- Sync trigger: UPDATE (delete old entry, insert new)
       CREATE TRIGGER observations_au AFTER UPDATE ON observations BEGIN
         INSERT INTO observations_fts(observations_fts, rowid, content)
           VALUES('delete', old.rowid, old.content);
         INSERT INTO observations_fts(rowid, content)
           VALUES (new.rowid, new.content);
       END;

       -- Sync trigger: DELETE
       CREATE TRIGGER observations_ad AFTER DELETE ON observations BEGIN
         INSERT INTO observations_fts(observations_fts, rowid, content)
           VALUES('delete', old.rowid, old.content);
       END;
       ```

       The `porter unicode61` tokenizer: `unicode61` handles UTF-8 and Unicode case folding; `porter` adds Porter stemming so "correction" matches "corrected", "correcting", etc.

       **Migration 004 (Vector Table -- conditional):**

       Only apply if `hasVectorSupport` is true. If false, skip silently (will be applied later when sqlite-vec becomes available).

       ```sql
       CREATE VIRTUAL TABLE IF NOT EXISTS observation_embeddings USING vec0(
         observation_id TEXT PRIMARY KEY,
         embedding float[384]
       );
       ```

       384 dimensions matches all-MiniLM-L6-v2 / BGE Small EN v1.5 (Phase 4 default). Use the text `id` as PRIMARY KEY in vec0 (stable public identifier, per research recommendation).

       Export the MIGRATIONS array so tests can inspect it.

    2. Update `src/storage/index.ts` to export from both modules:
       ```typescript
       export { openDatabase } from './database.js';
       export type { LaminarkDatabase } from './database.js';
       export { runMigrations, MIGRATIONS } from './migrations.js';
       ```

    3. Ensure database.ts calls runMigrations after PRAGMA setup and sqlite-vec loading (wire the call in Task 1's openDatabase function).
  </action>
  <verify>
    1. `npx tsc --noEmit` passes
    2. Write a vitest test (`src/storage/__tests__/database.test.ts`) that:
       - Opens database at a temp path via openDatabase
       - Verifies _migrations table exists with correct number of rows (3 or 4 depending on vector support)
       - Verifies observations table exists with columns: rowid, id, project_hash, content, source, session_id, embedding, embedding_model, embedding_version, created_at, updated_at, deleted_at
       - Verifies observations.rowid is INTEGER PRIMARY KEY AUTOINCREMENT (not implicit)
       - Verifies sessions table exists with columns: id, project_hash, started_at, ended_at, summary
       - Verifies observations_fts virtual table exists
       - Inserts a test observation via raw SQL
       - Queries `SELECT * FROM observations_fts WHERE content MATCH 'test'` and verifies it returns the row (trigger sync works)
       - Updates the observation's content, re-searches, verifies updated content is found
       - Deletes the observation, re-searches, verifies zero results (trigger sync works)
       - Closes and reopens database -- verifies migrations are NOT re-run (check _migrations count is same)
       - Verifies all data persists after close/reopen
    3. `npx vitest run` passes
    4. `npx tsdown` builds successfully
  </verify>
  <done>
    Migration system tracks schema versions in _migrations table. Migration 001 creates observations with INTEGER PRIMARY KEY AUTOINCREMENT (stable rowid for FTS5) plus TEXT UNIQUE id (public identifier). Migration 002 creates sessions. Migration 003 creates FTS5 external content table with porter+unicode61 tokenizer and three sync triggers. Migration 004 conditionally creates vec0 table for 384-dim embeddings. Reopening the database skips already-applied migrations. FTS5 triggers keep full-text index in perfect sync with observation writes, updates, and deletes.
  </done>
</task>

</tasks>

<verification>
- Database opens with WAL mode as first PRAGMA, busy_timeout = 5000ms
- observations table has: rowid (INTEGER PK AUTOINCREMENT), id (TEXT UNIQUE), project_hash, content, source, session_id, embedding (BLOB nullable), embedding_model, embedding_version, created_at, updated_at, deleted_at
- sessions table has: id, project_hash, started_at, ended_at, summary
- FTS5 external content table references content_rowid='rowid' (the STABLE integer PK)
- Three FTS5 sync triggers exist and work for INSERT, UPDATE, DELETE
- sqlite-vec vec0 table created if extension available, graceful skip otherwise
- Data persists across close/reopen
- Migrations are idempotent (skip if already applied)
- All tests pass: `npx vitest run`
</verification>

<success_criteria>
- WAL mode confirmed via PRAGMA query (MEM-01, MEM-08)
- Schema uses INTEGER PRIMARY KEY AUTOINCREMENT for FTS5 stability (research critical fix)
- Schema stores embedding + model version metadata (MEM-09)
- Project hash column on observations and sessions (MEM-06)
- busy_timeout = 5000ms (MEM-07)
- FTS5 external content table with sync triggers (SRC-05 foundation)
- Migration system tracks versions and is idempotent
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-engine/01-02-SUMMARY.md`
</output>
