---
phase: 02-mcp-interface-and-search
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - .mcp.json
  - src/mcp/__tests__/tools.test.ts
  - src/mcp/__tests__/token-budget.test.ts
autonomous: true

must_haves:
  truths:
    - "Claude Code discovers Laminark MCP tools via .mcp.json plugin manifest"
    - "save_memory persists text with auto-generated or user-provided title (SC-2)"
    - "recall search returns keyword-ranked results under 2000 token budget (SC-1, SC-4)"
    - "recall purge soft-deletes a memory that disappears from search but is recoverable via restore (SC-3)"
    - "recall view shows 3 levels of progressive disclosure: compact, timeline, full (SC-4)"
    - "Both MCP tools (save_memory and recall) are registered and callable (SC-5)"
  artifacts:
    - path: ".mcp.json"
      provides: "Claude Code plugin manifest pointing to npx tsx src/index.ts"
      contains: "laminark"
    - path: "src/mcp/__tests__/tools.test.ts"
      provides: "Integration tests proving all 5 Phase 2 success criteria"
    - path: "src/mcp/__tests__/token-budget.test.ts"
      provides: "Unit tests for token estimation and budget enforcement"
  key_links:
    - from: ".mcp.json"
      to: "src/index.ts"
      via: "npx tsx src/index.ts command to start MCP server"
      pattern: "tsx.*src/index.ts"
    - from: "src/mcp/__tests__/tools.test.ts"
      to: "src/mcp/tools/save-memory.ts"
      via: "Tests exercise save_memory through ObservationRepository"
      pattern: "generateTitle|ObservationRepository"
    - from: "src/mcp/__tests__/tools.test.ts"
      to: "src/mcp/tools/recall.ts"
      via: "Tests exercise recall search, purge, restore through storage layer"
      pattern: "SearchEngine|softDelete|restore"
---

<objective>
Create the plugin manifest for Claude Code integration and a comprehensive test suite that proves all 5 Phase 2 success criteria through automated tests.

Purpose: The .mcp.json manifest is what makes Claude Code discover and launch the Laminark MCP server. The test suite provides repeatable proof that the MCP interface works correctly: keyword search returns ranked results, save_memory persists with titles, purge/restore works, progressive disclosure respects token budgets, and tools are registered.

Output: Working .mcp.json at project root, token budget unit tests, and integration tests covering all Phase 2 success criteria.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-mcp-interface-and-search/02-CONTEXT.md
@.planning/phases/02-mcp-interface-and-search/02-RESEARCH.md
@.planning/phases/02-mcp-interface-and-search/02-01-SUMMARY.md
@.planning/phases/02-mcp-interface-and-search/02-02-SUMMARY.md
@src/mcp/server.ts
@src/mcp/tools/save-memory.ts
@src/mcp/tools/recall.ts
@src/mcp/token-budget.ts
@src/storage/observations.ts
@src/storage/search.ts
@src/shared/types.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Plugin manifest and token budget tests</name>
  <files>
    .mcp.json
    src/mcp/__tests__/token-budget.test.ts
  </files>
  <action>
**Step 1: Create `.mcp.json` at project root**

Per 02-RESEARCH.md: Plugin-bundled .mcp.json uses server names as top-level keys (NOT wrapped in an `mcpServers` object).

```json
{
  "laminark": {
    "command": "npx",
    "args": ["tsx", "src/index.ts"],
    "env": {}
  }
}
```

This tells Claude Code to start the Laminark MCP server by running `npx tsx src/index.ts`. The tsx devDependency (already installed) executes TypeScript source directly.

NOTE: For production/distribution, this would change to `node dist/index.js` after build. The tsx approach is correct for development and local plugin usage.

**Step 2: Create `src/mcp/__tests__/token-budget.test.ts`**

Unit tests for the token budget utility. Import from `../../mcp/token-budget.js`.

Test cases (use Vitest describe/it/expect):

```
describe('estimateTokens')
  it('returns ceil(length/4) for empty string' -- expect 0)
  it('returns ceil(length/4) for short text' -- "hello" = 2 tokens)
  it('returns ceil(length/4) for longer text' -- 100-char string = 25 tokens)

describe('enforceTokenBudget')
  it('returns all items when under budget')
    -- 3 items of 10 tokens each, budget 2000 -> truncated: false, items.length: 3

  it('truncates when items exceed budget')
    -- 100 items of 100 tokens each (total 10000), budget 2000 -> truncated: true, items.length < 100

  it('always includes at least 1 item even if it exceeds budget')
    -- 1 item of 5000 tokens, budget 2000 -> truncated: false, items.length: 1

  it('reserves 100 tokens for metadata')
    -- items that exactly fill budget-100 -> truncated: false; add 1 more token -> truncated: true

  it('respects custom budget parameter')
    -- budget: 500, items totaling 600 tokens -> truncated: true

  it('returns empty when no items provided')
    -- [] -> truncated: false, items: [], tokenEstimate: 0
```

Use a simple `formatResult` function for testing: `(item: string) => item`.
  </action>
  <verify>
File `.mcp.json` exists at project root and is valid JSON (parseable with JSON.parse).
Run `npm test -- src/mcp/__tests__/token-budget.test.ts` -- all token budget tests pass.
  </verify>
  <done>
.mcp.json plugin manifest at project root with correct format (top-level server name key, command: npx, args: tsx src/index.ts). Token budget unit tests pass covering estimation, truncation, minimum-1-item guarantee, metadata reserve, and custom budget.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests proving all Phase 2 success criteria</name>
  <files>
    src/mcp/__tests__/tools.test.ts
  </files>
  <action>
Create `src/mcp/__tests__/tools.test.ts` with integration tests that exercise the tool logic through the storage layer directly.

**Test database setup pattern** (reuse from Phase 1 tests):
```typescript
import { mkdtempSync, rmSync } from 'node:fs';
import { tmpdir } from 'node:os';
import { join } from 'node:path';
import { openDatabase } from '../../storage/database.js';
import { ObservationRepository } from '../../storage/observations.js';
import { SearchEngine } from '../../storage/search.js';
import { generateTitle } from '../tools/save-memory.js';

let tmpDir: string;
let db: ReturnType<typeof openDatabase>;
let repo: ObservationRepository;
let search: SearchEngine;
const PROJECT_HASH = 'test_project_hash';

beforeEach(() => {
  tmpDir = mkdtempSync(join(tmpdir(), 'laminark-test-'));
  db = openDatabase({ dbPath: join(tmpDir, 'test.db'), busyTimeout: 5000 });
  repo = new ObservationRepository(db.db, PROJECT_HASH);
  search = new SearchEngine(db.db, PROJECT_HASH);
});

afterEach(() => {
  db.close();
  rmSync(tmpDir, { recursive: true, force: true });
});
```

**Test groups (organized by success criterion):**

**SC-1: Keyword search returns ranked results**
```
describe('SC-1: keyword search')
  it('returns BM25-ranked results for keyword query')
    -- Insert 3 observations: "TypeScript compiler options" / "Python web framework" / "TypeScript type inference"
    -- Search "TypeScript" -> expect 2 results, both contain "TypeScript"
    -- Verify results have score > 0 and are sorted by relevance

  it('searches both title and content')
    -- Insert observation with title "Auth decisions" and content "We decided to use JWT"
    -- Search "Auth" -> expect 1 result (matches title)
    -- Search "JWT" -> expect 1 result (matches content)

  it('returns empty array for no matches')
    -- Insert observation, search for unrelated term -> expect []

  it('respects limit parameter')
    -- Insert 5 observations matching "test", search with limit 2 -> expect 2 results
```

**SC-2: save_memory persists with title**
```
describe('SC-2: save_memory')
  it('saves observation with user-provided title')
    -- repo.create({ content: 'Some text', title: 'My Title', source: 'manual' })
    -- Verify returned observation has title 'My Title'
    -- Verify getById returns same title

  it('accepts null title (auto-title applied at tool level)')
    -- repo.create({ content: 'Some text', source: 'manual' })
    -- Verify title is null in DB (title generation happens in tool handler, not repo)

  describe('generateTitle')
    it('extracts first sentence for short text')
      -- generateTitle('Hello world. More text.') -> 'Hello world.'
    it('returns full text when under 80 chars')
      -- generateTitle('Short text') -> 'Short text'
    it('truncates at 80 chars with ellipsis for long text')
      -- generateTitle('A'.repeat(200)) -> 'A'.repeat(80) + '...'
    it('handles text with no sentence boundary')
      -- generateTitle('A'.repeat(200)) -> first 80 + '...'
```

**SC-3: Purge/restore**
```
describe('SC-3: purge and restore')
  it('purge soft-deletes: memory disappears from normal search')
    -- Create observation with keyword "unique_test_word"
    -- Search "unique_test_word" -> expect 1 result
    -- softDelete(id) -> expect true
    -- Search "unique_test_word" -> expect 0 results

  it('purged memory still exists in database')
    -- Create and softDelete
    -- getByIdIncludingDeleted(id) -> expect non-null, deletedAt is not null

  it('restore un-deletes: memory reappears in search')
    -- Create, softDelete, restore(id) -> expect true
    -- Search keyword -> expect 1 result again

  it('softDelete returns false for non-existent ID')
    -- softDelete('nonexistent') -> expect false

  it('include_purged finds soft-deleted items')
    -- Create and softDelete
    -- listIncludingDeleted() -> expect to find the item with deletedAt set
```

**SC-4: Progressive disclosure and token budget**
```
describe('SC-4: progressive disclosure and token budget')
  it('compact format returns expected fields')
    -- Create observation with title and content
    -- Format as compact (id_short | title | score/- | snippet | date)
    -- Verify all fields present in output string

  it('search results respect 2000 token budget')
    -- Insert 50 observations with 200-char content each
    -- Search with a keyword that matches many
    -- Verify the returned result count is limited by token budget
    -- Use enforceTokenBudget to verify: estimateTokens(formattedResults) <= 2000

  it('large result sets report truncation')
    -- Same setup as above
    -- Verify truncated flag is true when budget exceeded

  it('single-item full view allows up to 4000 tokens')
    -- Create observation with 12000-char content (~3000 tokens)
    -- Verify full view of this single item fits within FULL_VIEW_BUDGET
```

**SC-5: Tool discoverability**
```
describe('SC-5: tool discoverability')
  it('MCP server registers both save_memory and recall tools')
    -- Import createServer from server.ts
    -- Import registerSaveMemory and registerRecall
    -- Create server, register both tools
    -- Verify no errors thrown during registration
    -- This tests the registration path without starting stdio transport

  it('.mcp.json exists and is valid')
    -- Read .mcp.json from project root
    -- Parse JSON, verify 'laminark' key exists
    -- Verify command is 'npx' and args include 'tsx' and 'src/index.ts'
```

**IMPORTANT testing approach:** Test through the storage layer functions directly (ObservationRepository, SearchEngine). Do NOT try to send JSON-RPC messages through stdin/stdout -- that would test the MCP SDK, not our tool logic. The MCP SDK is a trusted dependency; we test what we build on top of it.

Use Vitest matchers: `expect(x).toBe(y)`, `expect(x).toBeNull()`, `expect(x).toHaveLength(n)`, `expect(x).toBeGreaterThan(0)`, `expect(x).toContain('substring')`.
  </action>
  <verify>
Run `npm test` -- ALL tests pass (existing 78+ plus new token-budget and tools tests).
Verify test output shows passing tests mapped to each success criterion:
  - SC-1: At least 4 keyword search tests
  - SC-2: At least 4 save/title tests
  - SC-3: At least 5 purge/restore tests
  - SC-4: At least 4 progressive disclosure/budget tests
  - SC-5: At least 2 discoverability tests
Total new tests: 19+ (aim for 20-25).
  </verify>
  <done>
Integration test suite passes with 20+ new tests covering all 5 Phase 2 success criteria. Token budget unit tests pass (6+ tests). Combined with existing 78 tests, total passes 98+. Each success criterion has multiple test cases proving it. .mcp.json validated by test. No regressions in existing tests.
  </done>
</task>

</tasks>

<verification>
- `npm test` passes all tests: existing 78+ plus 25+ new = 100+ total
- .mcp.json is valid JSON at project root with correct plugin manifest format
- Each Phase 2 success criterion has automated test proof:
  1. SC-1: Keyword search returns BM25-ranked results (4+ tests)
  2. SC-2: save_memory persists with user or auto-generated title (4+ tests)
  3. SC-3: Purge soft-deletes, memory recoverable via restore (5+ tests)
  4. SC-4: Progressive disclosure respects 2000 token budget (4+ tests)
  5. SC-5: Both tools registered and discoverable (2+ tests)
- No console.log in any src/ file
- No separate forget/restore/timeline tools -- only save_memory and recall
</verification>

<success_criteria>
- .mcp.json exists at project root and enables Claude Code to discover Laminark tools
- 25+ new tests pass covering all Phase 2 success criteria
- All existing 78+ tests continue to pass (zero regressions)
- Phase 2 is complete: MCP server with 2 tools (save_memory + recall), keyword search, progressive disclosure, token budgets, purge/restore, plugin manifest
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-interface-and-search/02-03-SUMMARY.md`
</output>
