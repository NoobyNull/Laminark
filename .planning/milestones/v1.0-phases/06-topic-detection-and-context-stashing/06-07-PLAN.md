---
phase: 06-topic-detection-and-context-stashing
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - src/index.ts
  - src/storage/notifications.ts
  - src/mcp/tools/recall.ts
  - src/mcp/tools/topic-context.ts
  - src/mcp/tools/save-memory.ts
  - tests/integration/topic-shift-integration.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "After an observation's embedding is generated, the system evaluates it for topic shift and stashes context if shifted"
    - "When a topic shift is detected, a notification is persisted and surfaced to the user via the next MCP tool response"
    - "All existing 431 tests continue passing with zero regressions"
  artifacts:
    - path: "src/index.ts"
      provides: "TopicShiftHandler wired into processUnembedded loop"
      contains: "TopicShiftHandler"
    - path: "src/storage/notifications.ts"
      provides: "NotificationStore for pending topic shift notifications"
      exports: ["NotificationStore"]
    - path: "tests/integration/topic-shift-integration.test.ts"
      provides: "Integration tests proving SC1 and SC2"
  key_links:
    - from: "src/index.ts processUnembedded()"
      to: "TopicShiftHandler.handleObservation()"
      via: "call after embeddingStore.store()"
      pattern: "topicShiftHandler\\.handleObservation"
    - from: "src/index.ts processUnembedded()"
      to: "NotificationStore.add()"
      via: "store notification when shift detected"
      pattern: "notificationStore\\.add"
    - from: "src/mcp/tools/recall.ts"
      to: "NotificationStore.consumePending()"
      via: "prepend pending notifications to tool response"
      pattern: "consumePending|notificationStore"
---

<objective>
Wire TopicShiftHandler into the MCP server's background embedding loop and add notification delivery via MCP tool responses.

Purpose: Close 2 failing success criteria from Phase 6 verification -- automatic topic detection (SC1) and notification delivery (SC2). All detection infrastructure exists but is orphaned; this plan connects it to the live system.

Output: TopicShiftHandler called after each embedding generation in src/index.ts. Notification persisted in database and delivered piggybacked on MCP tool responses.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/index.ts
@src/hooks/topic-shift-handler.ts
@src/intelligence/topic-detector.ts
@src/intelligence/adaptive-threshold.ts
@src/intelligence/decision-logger.ts
@src/config/topic-detection-config.ts
@src/storage/stash-manager.ts
@src/storage/threshold-store.ts
@src/storage/observations.ts
@src/storage/embeddings.ts
@src/analysis/worker-bridge.ts
@src/mcp/tools/recall.ts
@src/mcp/tools/topic-context.ts
@src/mcp/tools/save-memory.ts
@src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire TopicShiftHandler into MCP server embedding loop and add notification store</name>
  <files>
    src/storage/notifications.ts
    src/index.ts
  </files>
  <action>
CRITICAL DESIGN CONTEXT: Embeddings are generated asynchronously by the MCP server's background worker, NOT in the hook process. The hook process (handler.ts) stores observations without embeddings. The MCP server's processUnembedded() loop generates embeddings every 5 seconds. Topic detection MUST happen here -- after embeddings exist -- not in the hook.

**Step 1: Create NotificationStore (src/storage/notifications.ts)**

Create a simple notification persistence layer with prepared-statement constructor pattern matching StashManager/ThresholdStore:

```typescript
import type BetterSqlite3 from 'better-sqlite3';
import { randomBytes } from 'node:crypto';
import { debug } from '../shared/debug.js';

export interface PendingNotification {
  id: string;
  projectId: string;
  message: string;
  createdAt: string;
}

export class NotificationStore {
  private readonly stmtInsert: BetterSqlite3.Statement;
  private readonly stmtConsume: BetterSqlite3.Statement;
  private readonly stmtSelect: BetterSqlite3.Statement;

  constructor(db: BetterSqlite3.Database) {
    // Create table inline (no migration needed -- simple transient store)
    db.exec(`
      CREATE TABLE IF NOT EXISTS pending_notifications (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        message TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime('now'))
      )
    `);

    this.stmtInsert = db.prepare(
      'INSERT INTO pending_notifications (id, project_id, message) VALUES (?, ?, ?)'
    );
    this.stmtSelect = db.prepare(
      'SELECT * FROM pending_notifications WHERE project_id = ? ORDER BY created_at ASC LIMIT 10'
    );
    this.stmtConsume = db.prepare(
      'DELETE FROM pending_notifications WHERE project_id = ?'
    );
    debug('db', 'NotificationStore initialized');
  }

  add(projectId: string, message: string): void {
    const id = randomBytes(16).toString('hex');
    this.stmtInsert.run(id, projectId, message);
    debug('db', 'Notification added', { projectId });
  }

  /** Fetch and delete all pending notifications for a project (consume pattern). */
  consumePending(projectId: string): PendingNotification[] {
    const rows = this.stmtSelect.all(projectId) as Array<{
      id: string; project_id: string; message: string; created_at: string;
    }>;
    if (rows.length > 0) {
      this.stmtConsume.run(projectId);
    }
    return rows.map(r => ({
      id: r.id,
      projectId: r.project_id,
      message: r.message,
      createdAt: r.created_at,
    }));
  }
}
```

Use `CREATE TABLE IF NOT EXISTS` inline in the constructor rather than a numbered migration. This is a transient notification queue -- not core data. This avoids migration numbering conflicts and keeps the store self-contained.

**Step 2: Wire TopicShiftHandler into src/index.ts processUnembedded()**

Add imports at the top of src/index.ts:
```typescript
import { TopicShiftHandler } from './hooks/topic-shift-handler.js';
import { TopicShiftDetector } from './intelligence/topic-detector.js';
import { AdaptiveThresholdManager } from './intelligence/adaptive-threshold.js';
import { TopicShiftDecisionLogger } from './intelligence/decision-logger.js';
import { loadTopicDetectionConfig, applyConfig } from './config/topic-detection-config.js';
import { StashManager } from './storage/stash-manager.js';
import { ThresholdStore } from './storage/threshold-store.js';
import { NotificationStore } from './storage/notifications.js';
```

After the existing `embeddingStore` and `worker` initialization block (around line 29), add topic detection setup:

```typescript
// ---------------------------------------------------------------------------
// Topic shift detection (runs in background embedding loop)
// ---------------------------------------------------------------------------

const topicConfig = loadTopicDetectionConfig();
const detector = new TopicShiftDetector();
const adaptiveManager = new AdaptiveThresholdManager({
  sensitivityMultiplier: topicConfig.sensitivityMultiplier,
  alpha: topicConfig.ewmaAlpha,
});
applyConfig(topicConfig, detector, adaptiveManager);

// Seed adaptive threshold from history (cold start handling)
const thresholdStore = new ThresholdStore(db.db);
const historicalSeed = thresholdStore.loadHistoricalSeed(projectHash);
if (historicalSeed) {
  adaptiveManager.seedFromHistory(historicalSeed.averageDistance, historicalSeed.averageVariance);
  applyConfig(topicConfig, detector, adaptiveManager);
}

const stashManager = new StashManager(db.db);
const decisionLogger = new TopicShiftDecisionLogger(db.db);
const notificationStore = new NotificationStore(db.db);
const obsRepoForTopicDetection = new ObservationRepository(db.db, projectHash);

const topicShiftHandler = new TopicShiftHandler({
  detector,
  stashManager,
  observationStore: obsRepoForTopicDetection,
  config: topicConfig,
  decisionLogger,
  adaptiveManager,
});
```

Then modify `processUnembedded()` to call the topic shift handler after storing each embedding. Inside the `for (const id of ids)` loop, after the `embeddingStore.store(id, embedding)` and `obsRepo.update(...)` block, add:

```typescript
    // Topic shift detection -- evaluate the newly embedded observation
    if (topicConfig.enabled) {
      try {
        // Re-fetch the observation with its new embedding
        const updatedObs = obsRepoForTopicDetection.getById(id);
        if (updatedObs && updatedObs.embedding) {
          const result = await topicShiftHandler.handleObservation(
            updatedObs,
            updatedObs.sessionId ?? 'unknown',
            projectHash,
          );
          if (result.stashed && result.notification) {
            notificationStore.add(projectHash, result.notification);
            debug('embed', 'Topic shift detected, notification queued', { id });
          }
        }
      } catch (topicErr) {
        const msg = topicErr instanceof Error ? topicErr.message : String(topicErr);
        debug('embed', 'Topic shift detection error (non-fatal)', { error: msg });
      }
    }
```

IMPORTANT: The `obsRepo.update()` call updates the observation's embeddingModel/embeddingVersion columns, but it does NOT store the embedding in the observations table (the embedding is stored in the vec0 table by embeddingStore.store()). However, ObservationRepository.getById returns the observation with its embedding from the observations table. Since obsRepo.update does NOT set the embedding column, we need to construct the Observation manually with the embedding we already have:

Actually, looking at the code more carefully: `obsRepo.update(id, { embeddingModel, embeddingVersion })` only updates those metadata fields. The observation.embedding in the observations table is populated at creation time (typically null from hooks). So instead of re-fetching, construct the observation with the embedding:

```typescript
    if (topicConfig.enabled && obs) {
      try {
        // Build the observation with its newly generated embedding
        const obsWithEmbedding = { ...obs, embedding };
        const result = await topicShiftHandler.handleObservation(
          obsWithEmbedding,
          obs.sessionId ?? 'unknown',
          projectHash,
        );
        if (result.stashed && result.notification) {
          notificationStore.add(projectHash, result.notification);
          debug('embed', 'Topic shift detected, notification queued', { id });
        }
      } catch (topicErr) {
        const msg = topicErr instanceof Error ? topicErr.message : String(topicErr);
        debug('embed', 'Topic shift detection error (non-fatal)', { error: msg });
      }
    }
```

This approach is correct because we already have `obs` (from `obsRepo.getById(id)` earlier in the loop) and `embedding` (the Float32Array from `worker.embed(text)`). We merge them to create a complete observation for the handler.

Also export `notificationStore` for MCP tools to use. The cleanest pattern: keep it as a module-level variable and pass it to MCP tool registration functions.

Update registerRecall, registerTopicContext, and registerSaveMemory signatures to accept an optional notificationStore parameter.

**Step 3: Pass notificationStore to MCP tool registration**

Update the MCP server setup section in src/index.ts to pass notificationStore:

```typescript
registerSaveMemory(server, db.db, projectHash, notificationStore);
registerRecall(server, db.db, projectHash, worker, embeddingStore, notificationStore);
registerTopicContext(server, db.db, projectHash, notificationStore);
```
  </action>
  <verify>
    - `npx tsc --noEmit` passes (type checking)
    - `npx vitest run` -- all 431+ existing tests pass
    - Manually inspect src/index.ts to confirm TopicShiftHandler is instantiated and called inside processUnembedded() loop
    - Manually inspect src/storage/notifications.ts exports NotificationStore with add() and consumePending()
  </verify>
  <done>
    - TopicShiftHandler instantiated in src/index.ts with all dependencies (detector, stashManager, obsRepo, config, decisionLogger, adaptiveManager)
    - processUnembedded() calls topicShiftHandler.handleObservation() after each embedding is stored
    - Topic shift result.notification stored in NotificationStore when shift detected
    - notificationStore passed to all MCP tool registration functions
    - All errors in topic detection are caught and logged but never crash the embedding loop
  </done>
</task>

<task type="auto">
  <name>Task 2: Piggyback notifications on MCP tool responses and add integration tests</name>
  <files>
    src/mcp/tools/recall.ts
    src/mcp/tools/topic-context.ts
    src/mcp/tools/save-memory.ts
    tests/integration/topic-shift-integration.test.ts
  </files>
  <action>
**Step 1: Add notification consumption to MCP tools**

For each MCP tool (recall, topic-context, save-memory), update the registration function to accept an optional NotificationStore parameter and prepend any pending notifications to the tool response.

Create a shared helper in a new file or inline:

```typescript
function prependNotifications(
  notificationStore: NotificationStore | null,
  projectHash: string,
  responseText: string,
): string {
  if (!notificationStore) return responseText;
  const pending = notificationStore.consumePending(projectHash);
  if (pending.length === 0) return responseText;
  const banner = pending.map(n => `[Laminark] ${n.message}`).join('\n');
  return banner + '\n\n' + responseText;
}
```

For recall.ts (`registerRecall`):
- Add optional `notificationStore?: NotificationStore | null` parameter after the existing parameters
- Before returning the response text in each handler branch, wrap through prependNotifications
- Import NotificationStore type from '../storage/notifications.js'

For topic-context.ts (`registerTopicContext`):
- Same pattern: add optional notificationStore parameter
- Wrap response through prependNotifications before returning

For save-memory.ts (`registerSaveMemory`):
- Same pattern: add optional notificationStore parameter
- Wrap response through prependNotifications before returning

This is the lightest-weight notification delivery mechanism possible:
- No polling, no separate endpoints
- Claude Code regularly calls MCP tools during normal operation
- Topic shift notification piggybacks on the very next tool response
- Consume-on-read ensures notifications are shown exactly once
- If Claude doesn't call any tools for a while, the notification waits in the database (no data loss)

The notification format matches the existing SessionStart banner pattern: `[Laminark] Topic shift detected. Previous context stashed: "topic label". Use /laminark:resume to return.`

**Step 2: Create integration tests (tests/integration/topic-shift-integration.test.ts)**

Write integration tests that prove:

1. **SC1 test: Topic shift detection triggers stash creation**
   - Create a temp database with all migrations
   - Instantiate TopicShiftHandler with all dependencies
   - Create two observations with very different embeddings (high cosine distance)
   - Call handleObservation for each
   - Assert: second call returns `{ stashed: true, notification: "Topic shift detected..." }`
   - Assert: StashManager.listStashes returns 1 stash
   - Assert: DecisionLogger.getSessionDecisions returns 2 decisions

2. **SC2 test: Notification stored and consumed via NotificationStore**
   - Create NotificationStore on temp database
   - Add a notification
   - consumePending returns it
   - Second consumePending returns empty array (consumed)

3. **SC1+SC2 integration test: Full pipeline from embedding to notification**
   - Create temp database
   - Set up all topic detection dependencies
   - Create 2 observations via ObservationRepository
   - Generate synthetic embeddings (one cluster, then a distant one)
   - Call handleObservation with each
   - When shift detected, store notification
   - Assert notification exists in NotificationStore
   - Call consumePending -- notification returned
   - Assert consumePending second call returns empty

4. **Graceful degradation test: Detection disabled doesn't break embedding loop**
   - Create handler with config.enabled = false
   - Call handleObservation
   - Assert: returns { stashed: false, notification: null }
   - No crash, no side effects

Use `createTempDb()` from existing test utilities for database setup. Generate synthetic embeddings as Float32Array with known cosine distances (e.g., two orthogonal 384-dim vectors for guaranteed shift, two similar vectors for no shift).

Import patterns from existing test files in tests/ directory.
  </action>
  <verify>
    - `npx vitest run` -- all tests pass (431 existing + new integration tests)
    - `npx tsc --noEmit` passes
    - New tests specifically verify:
      - TopicShiftHandler creates stash when embeddings diverge
      - NotificationStore add/consume lifecycle works correctly
      - Notifications are prepended to MCP tool responses
      - Config.enabled=false disables detection gracefully
  </verify>
  <done>
    - All three MCP tools (recall, topic-context, save-memory) check for and prepend pending notifications
    - NotificationStore consume-on-read ensures notifications shown exactly once
    - Integration tests prove: topic shift creates stash (SC1), notification delivered via tool response (SC2)
    - All 431+ existing tests pass with zero regressions
    - Notification format: "[Laminark] Topic shift detected. Previous context stashed: ..."
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `npx tsc --noEmit` -- zero type errors
2. `npx vitest run` -- all tests pass (431 existing + new integration tests, zero regressions)
3. Manual code inspection confirms:
   - src/index.ts creates TopicShiftHandler with all 6 dependencies
   - src/index.ts processUnembedded() calls topicShiftHandler.handleObservation() after each embedding
   - src/storage/notifications.ts implements add/consumePending with CREATE TABLE IF NOT EXISTS
   - All 3 MCP tools consume and prepend pending notifications
   - Topic detection errors are caught and never crash the embedding loop
4. Trace the data flow: observation captured by hook -> embedding generated in MCP server -> topic shift detected -> stash created -> notification stored -> next MCP tool call delivers notification to Claude -> Claude sees "[Laminark] Topic shift detected..."
</verification>

<success_criteria>
- SC1 CLOSED: After the background embedding loop generates a new embedding, TopicShiftHandler.handleObservation() is called, and if a shift is detected, a context stash is created automatically
- SC2 CLOSED: When a topic shift notification is generated, it is persisted via NotificationStore and delivered piggybacked on the next MCP tool response Claude makes
- Zero regressions: All 431 existing tests pass
- New integration tests prove both success criteria
</success_criteria>

<output>
After completion, create `.planning/phases/06-topic-detection-and-context-stashing/06-07-SUMMARY.md`
</output>
