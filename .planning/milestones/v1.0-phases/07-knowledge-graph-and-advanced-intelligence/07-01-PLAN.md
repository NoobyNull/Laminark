---
phase: 07-knowledge-graph-and-advanced-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graph/schema.ts
  - src/graph/types.ts
  - src/graph/migrations/001-graph-tables.ts
  - src/db/migrations.ts
autonomous: true

must_haves:
  truths:
    - "Graph nodes table exists in SQLite with columns: id, type, name, metadata, created_at, updated_at"
    - "Graph edges table exists in SQLite with columns: id, source_id, target_id, type, weight, metadata, created_at"
    - "Entity type taxonomy is defined as a strict TypeScript union: Project | File | Decision | Problem | Solution | Tool | Person"
    - "Relationship type taxonomy is defined as a strict TypeScript union: uses | depends_on | decided_by | related_to | part_of | caused_by | solved_by"
    - "Recursive CTE graph traversal query returns connected nodes up to configurable depth"
  artifacts:
    - path: "src/graph/types.ts"
      provides: "Entity type union, relationship type union, GraphNode interface, GraphEdge interface"
      exports: ["EntityType", "RelationshipType", "GraphNode", "GraphEdge", "ENTITY_TYPES", "RELATIONSHIP_TYPES"]
    - path: "src/graph/schema.ts"
      provides: "Graph schema initialization, table creation, index creation, traversal query builders"
      exports: ["initGraphSchema", "traverseFrom", "getNodesByType", "getEdgesForNode"]
    - path: "src/graph/migrations/001-graph-tables.ts"
      provides: "Migration to create graph_nodes and graph_edges tables with indexes"
      exports: ["up", "down"]
  key_links:
    - from: "src/graph/schema.ts"
      to: "src/graph/types.ts"
      via: "imports EntityType and RelationshipType for type-safe queries"
      pattern: "import.*EntityType.*RelationshipType.*from.*types"
    - from: "src/graph/schema.ts"
      to: "SQLite database"
      via: "better-sqlite3 database handle for DDL and queries"
      pattern: "db\\.(exec|prepare|run)"
---

<objective>
Create the knowledge graph storage foundation: SQLite tables for graph nodes and edges, TypeScript type definitions for the fixed entity/relationship taxonomy, and recursive CTE-based graph traversal queries.

Purpose: Every other Phase 7 plan depends on having a well-typed graph schema to write nodes/edges into and query from. This is the horizontal foundation that must exist first.
Output: Graph type definitions, SQLite migration for graph tables, and traversal query builders.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define graph type taxonomy and interfaces</name>
  <files>src/graph/types.ts</files>
  <action>
Create src/graph/types.ts with strict type definitions for the knowledge graph:

1. Entity type union (FIXED taxonomy -- no other types allowed):
   ```typescript
   export const ENTITY_TYPES = ['Project', 'File', 'Decision', 'Problem', 'Solution', 'Tool', 'Person'] as const;
   export type EntityType = typeof ENTITY_TYPES[number];
   ```

2. Relationship type union (FIXED taxonomy):
   ```typescript
   export const RELATIONSHIP_TYPES = ['uses', 'depends_on', 'decided_by', 'related_to', 'part_of', 'caused_by', 'solved_by'] as const;
   export type RelationshipType = typeof RELATIONSHIP_TYPES[number];
   ```

3. GraphNode interface:
   - id: string (UUID)
   - type: EntityType
   - name: string (canonical name, e.g., "src/auth/login.ts" for File, "Use JWT" for Decision)
   - metadata: Record<string, unknown> (flexible JSON for type-specific data)
   - observation_ids: string[] (source observations this entity was extracted from)
   - created_at: string (ISO 8601)
   - updated_at: string (ISO 8601)

4. GraphEdge interface:
   - id: string (UUID)
   - source_id: string (references GraphNode.id)
   - target_id: string (references GraphNode.id)
   - type: RelationshipType
   - weight: number (0.0-1.0, confidence/strength)
   - metadata: Record<string, unknown>
   - created_at: string (ISO 8601)

5. Helper type guards: isEntityType(s: string): s is EntityType and isRelationshipType(s: string): s is RelationshipType

6. MAX_NODE_DEGREE constant = 50 (exported, used by constraint enforcement in Plan 05)

Do NOT use enums -- use const arrays + typeof for better type inference and runtime validation.
  </action>
  <verify>npx tsc --noEmit src/graph/types.ts (no type errors). Grep for ENTITY_TYPES and RELATIONSHIP_TYPES exports.</verify>
  <done>All 7 entity types and 7 relationship types defined as const arrays with derived union types. GraphNode and GraphEdge interfaces exported. Type guard functions exported. MAX_NODE_DEGREE = 50 exported.</done>
</task>

<task type="auto">
  <name>Task 2: Create graph tables migration and schema initialization with traversal queries</name>
  <files>src/graph/migrations/001-graph-tables.ts, src/graph/schema.ts</files>
  <action>
Create the SQLite migration and schema module:

**Migration file (src/graph/migrations/001-graph-tables.ts):**

```sql
CREATE TABLE IF NOT EXISTS graph_nodes (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL CHECK(type IN ('Project','File','Decision','Problem','Solution','Tool','Person')),
  name TEXT NOT NULL,
  metadata TEXT DEFAULT '{}',
  observation_ids TEXT DEFAULT '[]',
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE IF NOT EXISTS graph_edges (
  id TEXT PRIMARY KEY,
  source_id TEXT NOT NULL REFERENCES graph_nodes(id) ON DELETE CASCADE,
  target_id TEXT NOT NULL REFERENCES graph_nodes(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK(type IN ('uses','depends_on','decided_by','related_to','part_of','caused_by','solved_by')),
  weight REAL NOT NULL DEFAULT 1.0 CHECK(weight >= 0.0 AND weight <= 1.0),
  metadata TEXT DEFAULT '{}',
  created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_graph_nodes_type ON graph_nodes(type);
CREATE INDEX IF NOT EXISTS idx_graph_nodes_name ON graph_nodes(name);
CREATE INDEX IF NOT EXISTS idx_graph_edges_source ON graph_edges(source_id);
CREATE INDEX IF NOT EXISTS idx_graph_edges_target ON graph_edges(target_id);
CREATE INDEX IF NOT EXISTS idx_graph_edges_type ON graph_edges(type);
CREATE UNIQUE INDEX IF NOT EXISTS idx_graph_edges_unique ON graph_edges(source_id, target_id, type);
```

Export up() and down() functions following the project's existing migration pattern (check src/db/migrations.ts for the pattern used by Phase 1).

**Schema module (src/graph/schema.ts):**

Export functions that accept a better-sqlite3 Database handle:

1. `initGraphSchema(db: Database)` -- runs the migration if graph tables don't exist
2. `traverseFrom(db: Database, nodeId: string, opts: { depth?: number, edgeTypes?: RelationshipType[], direction?: 'outgoing' | 'incoming' | 'both' })` -- recursive CTE traversal. Default depth = 2. Returns array of { node: GraphNode, edge: GraphEdge, depth: number }.
3. `getNodesByType(db: Database, type: EntityType)` -- returns all nodes of a type
4. `getEdgesForNode(db: Database, nodeId: string, opts?: { direction?: 'outgoing' | 'incoming' | 'both' })` -- returns edges connected to a node
5. `upsertNode(db: Database, node: Omit<GraphNode, 'id' | 'created_at' | 'updated_at'> & { id?: string })` -- insert or update by name+type composite (same name+type = same entity). Generate UUID if id not provided.
6. `insertEdge(db: Database, edge: Omit<GraphEdge, 'id' | 'created_at'> & { id?: string })` -- insert edge, ON CONFLICT (source_id, target_id, type) update weight to max(existing, new).
7. `getNodeByNameAndType(db: Database, name: string, type: EntityType)` -- lookup for dedup.
8. `countEdgesForNode(db: Database, nodeId: string)` -- returns edge count (for degree enforcement).

The recursive CTE for traverseFrom should look like:
```sql
WITH RECURSIVE traverse(node_id, depth) AS (
  SELECT ?, 0
  UNION ALL
  SELECT e.target_id, t.depth + 1
  FROM graph_edges e
  JOIN traverse t ON e.source_id = t.node_id
  WHERE t.depth < ?
)
SELECT DISTINCT n.*, e.*, t.depth
FROM traverse t
JOIN graph_nodes n ON n.id = t.node_id
LEFT JOIN graph_edges e ON (e.source_id = t.node_id OR e.target_id = t.node_id)
WHERE t.depth > 0
```

For bidirectional traversal, union source->target and target->source in the recursive part.

Import types from src/graph/types.ts. Use prepared statements for all queries (better-sqlite3 pattern). Parse metadata and observation_ids from JSON strings when returning GraphNode/GraphEdge objects.
  </action>
  <verify>Write a small test script or use the project's test runner to: (1) initialize the schema on an in-memory SQLite DB, (2) upsert a node, (3) insert an edge, (4) traverse from that node. All operations succeed without errors. `npx tsc --noEmit src/graph/schema.ts` passes.</verify>
  <done>graph_nodes and graph_edges tables can be created via migration. traverseFrom returns connected subgraph via recursive CTE. upsertNode handles insert-or-update by name+type. insertEdge handles ON CONFLICT weight update. All functions accept a Database handle and are fully typed.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes for all files in src/graph/
- graph_nodes table has CHECK constraint limiting type to the 7 entity types
- graph_edges table has CHECK constraint limiting type to the 7 relationship types
- graph_edges has UNIQUE constraint on (source_id, target_id, type) preventing duplicate edges
- traverseFrom with depth=2 returns nodes 2 hops away from a starting node
- Foreign key cascade: deleting a node deletes its edges
</verification>

<success_criteria>
Graph schema is fully defined in SQLite with type constraints, indexes, and foreign keys. TypeScript types provide compile-time safety for all entity and relationship operations. Traversal queries work via recursive CTEs. All other Phase 7 plans can import from src/graph/types.ts and src/graph/schema.ts.
</success_criteria>

<output>
After completion, create `.planning/phases/07-knowledge-graph-and-advanced-intelligence/07-01-SUMMARY.md`
</output>
