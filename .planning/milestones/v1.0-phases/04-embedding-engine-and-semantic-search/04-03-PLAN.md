---
phase: 04-embedding-engine-and-semantic-search
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/search/hybrid.ts
  - src/index.ts
  - src/mcp/tools/recall.ts
  - src/storage/index.ts
autonomous: true

must_haves:
  truths:
    - "Hybrid search combines FTS5 keyword results and vec0 vector results using reciprocal rank fusion"
    - "recall tool search action uses hybrid search when embeddings are available, falls back to keyword-only transparently"
    - "MCP server starts a background worker thread and processes unembedded observations asynchronously"
    - "Plugin startup adds zero perceptible latency -- worker thread creation is fast, model loads lazily on first embed"
  artifacts:
    - path: "src/search/hybrid.ts"
      provides: "reciprocalRankFusion() and hybridSearch() combining FTS5 + vector results"
      exports: ["reciprocalRankFusion", "hybridSearch"]
    - path: "src/index.ts"
      provides: "MCP server with worker thread lifecycle and background embedding loop"
      contains: "AnalysisWorker"
    - path: "src/mcp/tools/recall.ts"
      provides: "Updated recall tool using hybrid search when available"
      contains: "hybridSearch"
  key_links:
    - from: "src/search/hybrid.ts"
      to: "src/storage/search.ts"
      via: "Calls SearchEngine.searchKeyword() for FTS5 results"
      pattern: "searchKeyword"
    - from: "src/search/hybrid.ts"
      to: "src/storage/embeddings.ts"
      via: "Calls EmbeddingStore.search() for vector results"
      pattern: "EmbeddingStore.*search"
    - from: "src/index.ts"
      to: "src/analysis/worker-bridge.ts"
      via: "Creates AnalysisWorker, starts it, and uses it for background embedding"
      pattern: "AnalysisWorker"
    - from: "src/mcp/tools/recall.ts"
      to: "src/search/hybrid.ts"
      via: "Calls hybridSearch() instead of searchKeyword() for search action"
      pattern: "hybridSearch"
---

<objective>
Implement hybrid search with reciprocal rank fusion and wire the embedding pipeline into the MCP server lifecycle.

Purpose: This is the integration plan that connects all Phase 4 components into a working system. Users get better search results through hybrid keyword+semantic search, and observations are automatically embedded in the background without blocking any MCP tool responses.

Output: Hybrid search module, updated MCP server with worker lifecycle, updated recall tool.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-embedding-engine-and-semantic-search/04-RESEARCH.md
@.planning/phases/04-embedding-engine-and-semantic-search/04-01-SUMMARY.md
@.planning/phases/04-embedding-engine-and-semantic-search/04-02-SUMMARY.md
@src/storage/search.ts
@src/storage/embeddings.ts
@src/analysis/worker-bridge.ts
@src/index.ts
@src/mcp/tools/recall.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hybrid search with reciprocal rank fusion</name>
  <files>
    src/search/hybrid.ts
  </files>
  <action>
Create the hybrid search module that combines FTS5 keyword and vector semantic search:

**src/search/hybrid.ts**:

1. `reciprocalRankFusion(rankedLists, k)` function:
   - Takes `Array<Array<{ id: string; [key: string]: unknown }>>` ranked lists and `k = 60` constant
   - For each document across all lists, compute fused score: `sum(1 / (k + rank + 1))` where rank is 0-based position
   - Return `Array<{ id: string; fusedScore: number }>` sorted by fusedScore descending
   - This is a pure function with no side effects

2. `hybridSearch(params)` function:
   - Parameters:
     ```typescript
     {
       searchEngine: SearchEngine,
       embeddingStore: EmbeddingStore,
       worker: AnalysisWorker | null,
       query: string,
       options?: { limit?: number; sessionId?: string }
     }
     ```
   - Step 1: Run FTS5 keyword search via `searchEngine.searchKeyword(query, options)` -- always runs
   - Step 2: If `worker` is non-null and `worker.isReady()`:
     - Call `worker.embed(query)` to get query embedding
     - If embedding is non-null, call `embeddingStore.search(embedding, (options?.limit ?? 20) * 2)` to get vector results
   - Step 3: If only keyword results (no vector), return keyword results as-is with `matchType: 'fts'`
   - Step 4: If both keyword and vector results:
     - Build two ranked lists: keyword list (ordered by BM25 score), vector list (ordered by distance ascending)
     - Apply `reciprocalRankFusion()` to merge
     - For each fused result, find the observation from whichever source has it:
       - If in both: `matchType: 'hybrid'`, use keyword snippet
       - If keyword only: `matchType: 'fts'`, use keyword snippet
       - If vector only: `matchType: 'vector'`, generate snippet from first 100 chars of content
     - Compute final score as fusedScore
     - Return merged results up to limit, sorted by fusedScore descending
   - Return type: `SearchResult[]` (same type as keyword search returns)

Use debug() logging with category 'search' for hybrid search operations including timing.

Export both `reciprocalRankFusion` and `hybridSearch`.
  </action>
  <verify>
`npx tsc --noEmit` passes. Verify hybrid.ts exports both functions. The function signatures accept the types from SearchEngine, EmbeddingStore, and AnalysisWorker.
  </verify>
  <done>reciprocalRankFusion implements standard RRF with k=60. hybridSearch combines FTS5 keyword and vector results, falls back to keyword-only when worker unavailable, and returns SearchResult[] with correct matchType values.</done>
</task>

<task type="auto">
  <name>Task 2: Wire worker lifecycle and hybrid search into MCP server</name>
  <files>
    src/index.ts
    src/mcp/tools/recall.ts
    src/storage/index.ts
  </files>
  <action>
Integrate the embedding pipeline into the MCP server and update the recall tool:

**src/index.ts** -- Add worker lifecycle and background embedding:

1. After opening the database and creating projectHash, create shared instances:
   - `const embeddingStore = new EmbeddingStore(db.db, projectHash)` (only if `db.hasVectorSupport`)
   - `const worker = new AnalysisWorker()` (always create, starts lazily)

2. Start the worker asynchronously (non-blocking for server startup):
   ```typescript
   // Start worker in background -- do NOT await during server startup (DQ-04)
   const workerReady = worker.start().catch(() => {
     debug('mcp', 'Worker failed to start, keyword-only mode');
   });
   ```

3. Add a background embedding function that processes unembedded observations:
   ```typescript
   async function processUnembedded(): Promise<void> {
     if (!embeddingStore || !worker.isReady()) return;
     const ids = embeddingStore.findUnembedded(10);
     if (ids.length === 0) return;
     const obsRepo = new ObservationRepository(db.db, projectHash);
     for (const id of ids) {
       const obs = obsRepo.getById(id);
       if (!obs) continue;
       const text = obs.title ? `${obs.title}\n${obs.content}` : obs.content;
       const embedding = await worker.embed(text);
       if (embedding) {
         embeddingStore.store(id, embedding);
         // Also update the observations table metadata
         obsRepo.update(id, {
           embeddingModel: worker.getEngineName(),
           embeddingVersion: '1',
         });
       }
     }
   }
   ```

4. Set up a periodic timer to process unembedded observations:
   ```typescript
   // Process unembedded observations every 5 seconds
   const embedTimer = setInterval(() => {
     processUnembedded().catch((err) => {
       debug('embed', 'Background embedding error', { error: err.message });
     });
   }, 5000);
   ```

5. Update shutdown handlers (SIGINT, SIGTERM, uncaughtException):
   - Clear embedTimer: `clearInterval(embedTimer)`
   - Shutdown worker: `await worker.shutdown()` (or sync attempt)
   - Then close db as before

6. Pass `worker` and `embeddingStore` to tool registration functions that need them:
   ```typescript
   registerRecall(server, db.db, projectHash, worker, embeddingStore ?? null);
   ```

**src/mcp/tools/recall.ts** -- Update search action to use hybrid search:
- Add `worker: AnalysisWorker | null` and `embeddingStore: EmbeddingStore | null` parameters to `registerRecall()`
- In the search action handler, replace direct `searchEngine.searchKeyword()` call with:
  ```typescript
  const results = await hybridSearch({
    searchEngine,
    embeddingStore: embeddingStore!,
    worker,
    query: args.query,
    options: { limit: args.limit }
  });
  ```
- If embeddingStore is null (no vector support), fall back to `searchEngine.searchKeyword()` directly
- The rest of the recall tool (view, purge, restore actions) stays unchanged
- Note: the search action handler needs to become async since hybridSearch involves awaiting the worker

**src/storage/index.ts** -- Add EmbeddingStore to barrel export:
- Export `EmbeddingStore` from `./embeddings.js`

Handle the async conversion carefully: the recall tool's search action already runs inside an async MCP handler, so awaiting hybridSearch() is safe.
  </action>
  <verify>
`npx tsc --noEmit` passes. `npm test` passes (existing recall tests should still work since hybrid search falls back to keyword when worker is null). `npx tsdown` builds successfully. Verify the MCP server entry point creates AnalysisWorker and sets up background embedding timer.
  </verify>
  <done>MCP server creates worker thread on startup (fast, model loads lazily), processes unembedded observations every 5s in background, and recall tool uses hybrid search combining FTS5+vector when available. Plugin startup adds zero perceptible latency.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm test` passes with all existing tests green
- `npx tsdown` builds all three entry points successfully
- `src/search/hybrid.ts` exports reciprocalRankFusion and hybridSearch
- `src/index.ts` creates AnalysisWorker, EmbeddingStore, background embedding timer
- `src/mcp/tools/recall.ts` uses hybridSearch for search action
- Background embedding loop processes observations without blocking MCP responses
</verification>

<success_criteria>
1. Hybrid search returns better results than keyword-only by combining both signals (SRC-03)
2. recall tool transparently uses hybrid search when available, keyword-only when not (DQ-03)
3. Worker thread starts during server startup without blocking (DQ-04, INT-04)
4. Background loop automatically embeds new observations (INT-01)
5. Shutdown cleanly stops worker and embedding timer
</success_criteria>

<output>
After completion, create `.planning/phases/04-embedding-engine-and-semantic-search/04-03-SUMMARY.md`
</output>
