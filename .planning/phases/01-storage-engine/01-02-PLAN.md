---
phase: 01-storage-engine
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/storage/database.ts
  - src/storage/migrations.ts
  - src/storage/index.ts
autonomous: true

must_haves:
  truths:
    - "Opening the database creates a laminark.db file at the project-scoped path"
    - "Database operates in WAL mode with busy_timeout of 5000ms"
    - "Schema includes observations table with columns for text, embedding (nullable BLOB), and model version metadata"
    - "FTS5 virtual table exists and is synchronized with observations content"
    - "Closing and reopening the database preserves all data and schema"
    - "Migration system tracks applied migrations and skips already-applied ones"
  artifacts:
    - path: "src/storage/database.ts"
      provides: "Database connection management with WAL mode, PRAGMA setup, extension loading"
      exports: ["Database", "openDatabase", "closeDatabase"]
      min_lines: 80
    - path: "src/storage/migrations.ts"
      provides: "Schema migration system with version tracking"
      exports: ["runMigrations"]
      min_lines: 60
  key_links:
    - from: "src/storage/database.ts"
      to: "better-sqlite3"
      via: "new BetterSqlite3(dbPath) constructor"
      pattern: "import.*better-sqlite3"
    - from: "src/storage/database.ts"
      to: "sqlite-vec"
      via: "db.loadExtension(sqliteVecPath)"
      pattern: "loadExtension"
    - from: "src/storage/database.ts"
      to: "src/storage/migrations.ts"
      via: "runMigrations called after connection setup"
      pattern: "runMigrations"
    - from: "src/storage/database.ts"
      to: "src/shared/config.ts"
      via: "getDbPath for file location"
      pattern: "getDbPath|getConfig"
---

<objective>
SQLite database initialization with WAL mode, schema creation, FTS5 virtual table, sqlite-vec extension loading, and a migration system.

Purpose: Establish the durable storage foundation that every subsequent plan reads from and writes to. WAL mode and proper PRAGMAs prevent the SQLite corruption pitfall identified in research. The migration system enables schema evolution across phases without data loss.
Output: A Database class that opens a properly configured SQLite database with WAL mode, creates the observation/session schema, sets up FTS5 full-text indexing, and loads the sqlite-vec extension for future vector search.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/01-storage-engine/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database connection manager with WAL mode, PRAGMAs, and sqlite-vec extension</name>
  <files>
    src/storage/database.ts
  </files>
  <action>
    Create `src/storage/database.ts` that exports a `Database` class wrapping better-sqlite3.

    **Connection setup (constructor or openDatabase factory):**
    1. Accept `DatabaseConfig` from shared/config.ts (dbPath, busyTimeout, walMode)
    2. Ensure the directory for dbPath exists (mkdirSync recursive)
    3. Create the better-sqlite3 connection: `new BetterSqlite3(config.dbPath)`
    4. Set PRAGMAs in this EXACT order (order matters for WAL):
       ```sql
       PRAGMA journal_mode = WAL;          -- MUST be first PRAGMA (MEM-08)
       PRAGMA busy_timeout = 5000;         -- >= 5000ms per research (MEM-07)
       PRAGMA synchronous = NORMAL;        -- Safe with WAL, faster than FULL
       PRAGMA cache_size = -64000;         -- 64MB cache (negative = KB)
       PRAGMA foreign_keys = ON;           -- Enforce referential integrity
       PRAGMA temp_store = MEMORY;         -- Temp tables in memory
       ```
    5. Load sqlite-vec extension:
       ```typescript
       import * as sqliteVec from 'sqlite-vec';
       sqliteVec.load(db);
       ```
       Wrap in try/catch -- if sqlite-vec fails to load, log a warning and continue. The system degrades gracefully to keyword-only search (no vector search). Set a flag `this.hasVectorSupport: boolean` to track availability.
    6. Enable WAL auto-checkpoint at 1000 pages (default, but be explicit):
       ```sql
       PRAGMA wal_autocheckpoint = 1000;
       ```

    **Close method:**
    - Run `PRAGMA wal_checkpoint(PASSIVE)` before closing (flush WAL)
    - Call `db.close()`

    **Public API:**
    - `get db(): BetterSqlite3.Database` -- expose the raw connection for queries
    - `get hasVectorSupport(): boolean` -- whether sqlite-vec loaded successfully
    - `close(): void` -- graceful shutdown with WAL checkpoint
    - `checkpoint(): void` -- manual WAL checkpoint for periodic maintenance

    **Important:** Do NOT open multiple connections to the same database file. This class manages a single connection. The single-writer pattern is enforced architecturally (one Database instance per process).

    Import types from `../shared/config.js` and `../shared/types.js` (use .js extension for ESM imports even though source is .ts -- this is the NodeNext resolution pattern).
  </action>
  <verify>
    1. `npx tsc --noEmit` passes
    2. Write a quick inline test or script:
       ```typescript
       const config = getConfig('/tmp/test-laminark');
       const database = openDatabase(config);
       // Verify WAL mode
       const walMode = database.db.pragma('journal_mode', { simple: true });
       assert(walMode === 'wal');
       // Verify busy_timeout
       const timeout = database.db.pragma('busy_timeout', { simple: true });
       assert(timeout === 5000);
       database.close();
       // Verify file exists
       assert(fs.existsSync(config.dbPath));
       ```
    3. Check that sqlite-vec loads without error (or gracefully reports unavailability)
  </verify>
  <done>
    Database class opens a WAL-mode SQLite connection at the project-scoped path with correct PRAGMAs (journal_mode=WAL first, busy_timeout=5000, synchronous=NORMAL, foreign_keys=ON). sqlite-vec extension loads or gracefully degrades. Close method checkpoints WAL before shutdown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create migration system and initial schema (observations, sessions, FTS5)</name>
  <files>
    src/storage/migrations.ts
    src/storage/index.ts
  </files>
  <action>
    1. Create `src/storage/migrations.ts` with a version-tracked migration system:

       **Migration tracking table:**
       ```sql
       CREATE TABLE IF NOT EXISTS _migrations (
         version INTEGER PRIMARY KEY,
         name TEXT NOT NULL,
         applied_at TEXT NOT NULL DEFAULT (datetime('now'))
       );
       ```

       **Migration interface:**
       ```typescript
       interface Migration {
         version: number;
         name: string;
         up: string;  // SQL to apply
       }
       ```

       **Migration runner (`runMigrations(db: BetterSqlite3.Database, hasVectorSupport: boolean)`):**
       - Create _migrations table if not exists
       - Get max applied version
       - Run each unapplied migration in a transaction (db.transaction)
       - Insert into _migrations after each successful migration
       - Log each applied migration name

       **Migration 001 - Initial Schema:**
       ```sql
       CREATE TABLE observations (
         id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
         project_hash TEXT NOT NULL,
         content TEXT NOT NULL,
         source TEXT NOT NULL DEFAULT 'unknown',
         session_id TEXT,
         embedding BLOB,
         embedding_model TEXT,
         embedding_version TEXT,
         created_at TEXT NOT NULL DEFAULT (datetime('now')),
         updated_at TEXT NOT NULL DEFAULT (datetime('now')),
         deleted_at TEXT
       );

       CREATE INDEX idx_observations_project ON observations(project_hash);
       CREATE INDEX idx_observations_session ON observations(session_id);
       CREATE INDEX idx_observations_created ON observations(created_at);
       CREATE INDEX idx_observations_deleted ON observations(deleted_at);
       ```

       Note on id: Use 32 hex char random ID (UUID-like but without dashes) generated by SQLite's `randomblob(16)`. This is simpler than importing a UUID library and works natively in SQLite.

       **Migration 002 - Sessions table:**
       ```sql
       CREATE TABLE sessions (
         id TEXT PRIMARY KEY,
         project_hash TEXT NOT NULL,
         started_at TEXT NOT NULL DEFAULT (datetime('now')),
         ended_at TEXT,
         summary TEXT
       );

       CREATE INDEX idx_sessions_project ON sessions(project_hash);
       CREATE INDEX idx_sessions_started ON sessions(started_at);
       ```

       **Migration 003 - FTS5 full-text index:**
       ```sql
       CREATE VIRTUAL TABLE observations_fts USING fts5(
         content,
         content_rowid='rowid',
         tokenize='porter unicode61'
       );
       ```

       IMPORTANT: Use an external-content FTS5 table pattern. The FTS5 table indexes `content` but does NOT store it redundantly. This requires triggers to keep it in sync:

       ```sql
       -- Trigger to insert into FTS when observation is created
       CREATE TRIGGER observations_ai AFTER INSERT ON observations BEGIN
         INSERT INTO observations_fts(rowid, content) VALUES (new.rowid, new.content);
       END;

       -- Trigger to update FTS when observation is updated
       CREATE TRIGGER observations_au AFTER UPDATE ON observations BEGIN
         INSERT INTO observations_fts(observations_fts, rowid, content) VALUES('delete', old.rowid, old.content);
         INSERT INTO observations_fts(rowid, content) VALUES (new.rowid, new.content);
       END;

       -- Trigger to delete from FTS when observation is deleted
       CREATE TRIGGER observations_ad AFTER DELETE ON observations BEGIN
         INSERT INTO observations_fts(observations_fts, rowid, content) VALUES('delete', old.rowid, old.content);
       END;
       ```

       Wait -- FTS5 external content tables use `content=''` (contentless) or `content='observations'` (content-backed). For our use case, use `content='observations', content_rowid='rowid'` so FTS reads from the observations table directly. With external content tables, we MUST use triggers to keep the FTS index in sync. The triggers above handle this.

       Actually, revise the FTS5 table to use proper external content:
       ```sql
       CREATE VIRTUAL TABLE observations_fts USING fts5(
         content,
         content='observations',
         content_rowid='rowid',
         tokenize='porter unicode61'
       );
       ```

       **Migration 004 - Vector table (conditional on hasVectorSupport):**
       Only run if `hasVectorSupport` is true. Create a sqlite-vec virtual table:
       ```sql
       CREATE VIRTUAL TABLE IF NOT EXISTS observation_embeddings USING vec0(
         observation_id TEXT PRIMARY KEY,
         embedding float[384]
       );
       ```
       384 dimensions matches the default embedding model (all-MiniLM-L6-v2 / BGE Small EN v1.5).

       If hasVectorSupport is false, skip this migration silently (it will be applied later if sqlite-vec becomes available).

    2. Update `src/storage/index.ts` to export from database.ts and migrations.ts:
       ```typescript
       export { Database, openDatabase, closeDatabase } from './database.js';
       export { runMigrations } from './migrations.js';
       ```

    3. Wire migrations into the Database class: after PRAGMAs and extension loading, call `runMigrations(this.db, this.hasVectorSupport)`.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes
    2. Write a test script or use vitest:
       - Open database at a temp path
       - Verify _migrations table exists with 3 or 4 rows (depending on vector support)
       - Verify observations table exists with all columns (embedding, embedding_model, embedding_version nullable)
       - Verify sessions table exists
       - Verify observations_fts virtual table exists
       - Insert a test observation manually via SQL
       - Query `SELECT * FROM observations_fts WHERE content MATCH 'test'` and verify it returns the row (trigger sync works)
       - Close and reopen database -- verify migrations are NOT re-run (idempotent)
       - Verify all data persists after close/reopen
    3. `npx tsdown` builds successfully
  </verify>
  <done>
    Migration system tracks schema versions in _migrations table. Initial schema creates: observations table with project_hash, content, nullable embedding/model/version columns (MEM-09); sessions table with project_hash scoping (MEM-06); FTS5 external content virtual table with porter tokenizer and sync triggers; conditional sqlite-vec virtual table for 384-dim vectors. Reopening the database skips already-applied migrations. FTS5 triggers keep full-text index in sync with observation writes.
  </done>
</task>

</tasks>

<verification>
- Database opens with WAL mode as first PRAGMA, busy_timeout = 5000ms
- observations table has: id, project_hash, content, source, session_id, embedding (BLOB nullable), embedding_model (nullable), embedding_version (nullable), created_at, updated_at, deleted_at
- sessions table has: id, project_hash, started_at, ended_at, summary
- FTS5 virtual table syncs with observations via triggers
- sqlite-vec virtual table created if extension available, graceful skip otherwise
- Data persists across close/reopen
- Migrations are idempotent (skip if already applied)
</verification>

<success_criteria>
- WAL mode confirmed via `PRAGMA journal_mode` query (MEM-01, MEM-08)
- Schema stores embedding + model version metadata alongside original text (MEM-09)
- Project hash column exists on observations and sessions (MEM-06)
- busy_timeout >= 5000ms set (MEM-07)
- FTS5 search returns results for inserted observations (SRC-05 foundation)
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-engine/01-02-SUMMARY.md`
</output>
