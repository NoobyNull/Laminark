---
phase: 01-storage-engine
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/storage/observations.ts
  - src/storage/sessions.ts
  - src/storage/search.ts
  - src/storage/index.ts
autonomous: true

must_haves:
  truths:
    - "Creating an observation with project A's hash and querying with project B's hash returns zero results"
    - "Full-text search for a keyword returns observations containing that keyword, ranked by BM25 relevance"
    - "Soft-deleted observations do not appear in search results or list queries"
    - "Observations can be created, read, updated, and soft-deleted through the repository API"
    - "Sessions can be created, ended, and queried by project hash"
  artifacts:
    - path: "src/storage/observations.ts"
      provides: "Observation CRUD operations with project scoping"
      exports: ["ObservationRepository"]
      min_lines: 100
    - path: "src/storage/sessions.ts"
      provides: "Session lifecycle management"
      exports: ["SessionRepository"]
      min_lines: 40
    - path: "src/storage/search.ts"
      provides: "FTS5 keyword search with BM25 ranking and project scoping"
      exports: ["SearchEngine"]
      min_lines: 60
  key_links:
    - from: "src/storage/observations.ts"
      to: "better-sqlite3"
      via: "prepared statements for CRUD operations"
      pattern: "db\\.prepare"
    - from: "src/storage/observations.ts"
      to: "src/shared/types.ts"
      via: "uses Observation and ObservationInsert types"
      pattern: "import.*types"
    - from: "src/storage/search.ts"
      to: "observations_fts"
      via: "FTS5 MATCH query with BM25 ranking"
      pattern: "MATCH|bm25"
    - from: "src/storage/search.ts"
      to: "src/storage/observations.ts"
      via: "joins FTS results with observation data"
      pattern: "JOIN.*observations"
---

<objective>
Observation CRUD operations with strict project scoping, session lifecycle management, and FTS5 keyword search with BM25 ranking.

Purpose: Provide the data access layer that all higher-level features (MCP tools, hooks, search) will use. Project scoping enforcement here guarantees observations from project A never leak to project B (MEM-06, SRC-05). FTS5 search enables keyword-based memory retrieval.
Output: Repository classes for observations and sessions, plus a search engine using FTS5 with BM25 scoring.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-storage-engine/01-01-SUMMARY.md
@.planning/phases/01-storage-engine/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ObservationRepository and SessionRepository with project-scoped CRUD</name>
  <files>
    src/storage/observations.ts
    src/storage/sessions.ts
  </files>
  <action>
    1. Create `src/storage/observations.ts` with class `ObservationRepository`:

       **Constructor:** Takes `BetterSqlite3.Database` instance and `projectHash: string`. The projectHash is set at construction time and used in EVERY query -- this enforces project scoping at the repository level (not caller's responsibility).

       **Use prepared statements** for all queries. Prepare them once in the constructor and reuse. better-sqlite3 prepared statements are significantly faster than ad-hoc queries.

       **Methods:**

       - `create(input: ObservationInsert): Observation` -- INSERT into observations. Validate input with ObservationInsertSchema (Zod). Set project_hash from constructor. Returns the created observation with generated id and timestamps.

       - `getById(id: string): Observation | null` -- SELECT by id WHERE project_hash = this.projectHash AND deleted_at IS NULL. Always scope by project hash.

       - `list(options?: { limit?: number; offset?: number; sessionId?: string; since?: string }): Observation[]` -- SELECT with project scoping, ordered by created_at DESC. Default limit 50. Filter by sessionId if provided. Filter by since (created_at >= since) if provided. EXCLUDE soft-deleted (WHERE deleted_at IS NULL).

       - `update(id: string, updates: Partial<Pick<Observation, 'content' | 'embedding' | 'embeddingModel' | 'embeddingVersion'>>): Observation | null` -- UPDATE with project scoping. Sets updated_at = datetime('now'). Returns updated observation or null if not found.

       - `softDelete(id: string): boolean` -- SET deleted_at = datetime('now') WHERE id = ? AND project_hash = ? AND deleted_at IS NULL. Returns true if a row was affected.

       - `restore(id: string): boolean` -- SET deleted_at = NULL WHERE id = ? AND project_hash = ?. Returns true if restored.

       - `count(): number` -- COUNT(*) WHERE project_hash = ? AND deleted_at IS NULL.

       **Important implementation notes:**
       - EVERY query includes `WHERE project_hash = ?` -- never allow cross-project access
       - Use `db.prepare(sql).bind(params)` pattern for all queries
       - Store embedding as BLOB: `Buffer.from(float32Array.buffer)` for write, `new Float32Array(buffer)` for read
       - Map between snake_case SQL columns and camelCase TypeScript properties in a private helper method
       - All timestamps are ISO 8601 strings stored as TEXT in SQLite

    2. Create `src/storage/sessions.ts` with class `SessionRepository`:

       **Constructor:** Takes `BetterSqlite3.Database` and `projectHash: string`.

       **Methods:**

       - `create(id: string): Session` -- INSERT into sessions with the given id and project_hash. Returns created session.

       - `end(id: string, summary?: string): Session | null` -- UPDATE ended_at = datetime('now'), optionally set summary. Returns updated session or null.

       - `getById(id: string): Session | null` -- SELECT by id WHERE project_hash = ?

       - `getLatest(limit?: number): Session[]` -- SELECT ordered by started_at DESC, project-scoped. Default limit 10.

       - `getActive(): Session | null` -- SELECT WHERE ended_at IS NULL AND project_hash = ?, ordered by started_at DESC, LIMIT 1.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes
    2. Write a test (vitest) that:
       - Opens a database at a temp path
       - Creates ObservationRepository with projectHash "aaa"
       - Creates 3 observations
       - Verifies list() returns 3
       - Creates ObservationRepository with projectHash "bbb"
       - Verifies list() returns 0 (project scoping works -- MEM-06, SRC-05)
       - Soft-deletes one observation in project "aaa"
       - Verifies list() returns 2 (soft delete excludes)
       - Restores the soft-deleted observation
       - Verifies list() returns 3 again
       - Creates a Session, ends it, verifies getLatest returns it
    3. `npx vitest run` passes
  </verify>
  <done>
    ObservationRepository provides create, getById, list, update, softDelete, restore, count -- all enforcing project_hash scoping. SessionRepository provides create, end, getById, getLatest, getActive -- all project-scoped. No query can return data from a different project. Soft-deleted observations are excluded from list/search. Tests verify project isolation and soft-delete behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FTS5 search engine with BM25 ranking and project scoping</name>
  <files>
    src/storage/search.ts
    src/storage/index.ts
  </files>
  <action>
    1. Create `src/storage/search.ts` with class `SearchEngine`:

       **Constructor:** Takes `BetterSqlite3.Database` and `projectHash: string`.

       **Methods:**

       - `searchKeyword(query: string, options?: { limit?: number; sessionId?: string }): SearchResult[]`

         Use FTS5 MATCH query with BM25 ranking:
         ```sql
         SELECT
           o.*,
           bm25(observations_fts) AS rank,
           snippet(observations_fts, 0, '<b>', '</b>', '...', 32) AS snippet
         FROM observations_fts
         JOIN observations o ON o.rowid = observations_fts.rowid
         WHERE observations_fts MATCH ?
           AND o.project_hash = ?
           AND o.deleted_at IS NULL
         ORDER BY rank
         LIMIT ?
         ```

         Note: bm25() returns negative values where more negative = more relevant. ORDER BY rank (ascending) puts best matches first.

         Sanitize the query input: escape FTS5 special characters (`*`, `"`, `(`, `)`, `OR`, `AND`, `NOT`, `NEAR`). If the query is a simple phrase, wrap in double quotes for exact phrase matching. If it contains multiple words, join with implicit AND (FTS5 default).

         Map results to `SearchResult[]` with `matchType: 'fts'`.

         Default limit: 20.

         If sessionId provided, add `AND o.session_id = ?` to the WHERE clause.

       - `searchByPrefix(prefix: string, limit?: number): SearchResult[]`

         For autocomplete-style search. Uses FTS5 prefix queries:
         ```sql
         WHERE observations_fts MATCH ? || '*'
         ```

       - `rebuildIndex(): void`

         Rebuild the FTS5 index if it gets out of sync:
         ```sql
         INSERT INTO observations_fts(observations_fts) VALUES('rebuild');
         ```

    2. Update `src/storage/index.ts` to export all modules:
       ```typescript
       export { Database, openDatabase, closeDatabase } from './database.js';
       export { runMigrations } from './migrations.js';
       export { ObservationRepository } from './observations.js';
       export { SessionRepository } from './sessions.js';
       export { SearchEngine } from './search.js';
       ```

    3. Write comprehensive tests in `src/storage/search.test.ts`:
       - Insert 5 observations across 2 projects
       - Search in project A: returns only project A observations
       - Search in project B: returns only project B observations
       - Search for a keyword present in 2 observations: both returned, ranked
       - Soft-delete one matching observation: search returns only the non-deleted one
       - Search for a keyword not present: returns empty array
       - Prefix search works
       - Snippet contains match context
  </action>
  <verify>
    1. `npx tsc --noEmit` passes
    2. `npx vitest run` passes all search tests
    3. Verify project isolation: searching project A never returns project B results
    4. Verify soft-delete exclusion: deleted observations never appear in search
    5. Verify BM25 ranking: results are ordered by relevance
    6. `npx tsdown` builds successfully
  </verify>
  <done>
    SearchEngine provides FTS5 keyword search with BM25 ranking, snippet extraction, and strict project scoping. Search queries are sanitized for FTS5 safety. Results never include soft-deleted observations. Results never include observations from other projects. Tests prove project isolation, soft-delete exclusion, and ranking. The full storage module (Database, ObservationRepository, SessionRepository, SearchEngine) is exported from the barrel file and builds to dist/.
  </done>
</task>

</tasks>

<verification>
- Creating observations in project "aaa" and searching from project "bbb" returns zero results
- FTS5 search returns results ranked by BM25 relevance with snippets
- Soft-deleted observations excluded from all queries (list, search, count)
- All CRUD operations work: create, read, update, soft-delete, restore
- Session lifecycle works: create, end, get active, get latest
- All tests pass: `npx vitest run`
- Build succeeds: `npx tsdown`
</verification>

<success_criteria>
- Project scoping is absolute: no cross-project data leakage (MEM-06, SRC-05)
- Full-text search works with BM25 ranking (SRC-05 foundation)
- Soft-delete enables future "forget" MCP tool (MEM-05 foundation)
- Observation schema includes embedding fields for future use (MEM-09)
- All storage operations use prepared statements for performance
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-engine/01-03-SUMMARY.md`
</output>
