---
phase: 01-storage-engine
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/storage/observations.ts
  - src/storage/sessions.ts
  - src/storage/search.ts
  - src/storage/index.ts
autonomous: true

must_haves:
  truths:
    - "Creating an observation with project A's hash and querying with project B's hash returns zero results"
    - "Full-text search for a keyword returns observations containing that keyword, ranked by BM25 relevance"
    - "Soft-deleted observations do not appear in search results or list queries"
    - "Observations can be created, read, updated, and soft-deleted through the repository API"
    - "Sessions can be created, ended, and queried by project hash"
    - "FTS5 search respects project scoping -- never returns results from other projects"
  artifacts:
    - path: "src/storage/observations.ts"
      provides: "Observation CRUD with project scoping and prepared statements"
      exports: ["ObservationRepository"]
      min_lines: 100
    - path: "src/storage/sessions.ts"
      provides: "Session lifecycle management with project scoping"
      exports: ["SessionRepository"]
      min_lines: 40
    - path: "src/storage/search.ts"
      provides: "FTS5 keyword search with BM25 ranking, snippets, and project scoping"
      exports: ["SearchEngine"]
      min_lines: 60
  key_links:
    - from: "src/storage/observations.ts"
      to: "better-sqlite3"
      via: "prepared statements for all CRUD operations"
      pattern: "db\\.prepare"
    - from: "src/storage/observations.ts"
      to: "src/shared/types.ts"
      via: "uses ObservationInsert, Observation, rowToObservation types"
      pattern: "import.*types"
    - from: "src/storage/search.ts"
      to: "observations_fts"
      via: "FTS5 MATCH query with bm25() ranking and snippet()"
      pattern: "MATCH.*bm25"
    - from: "src/storage/search.ts"
      to: "src/storage/observations.ts"
      via: "search joins FTS results with observations table via rowid"
      pattern: "JOIN.*observations.*ON.*rowid"
---

<objective>
Observation CRUD operations, session lifecycle management, and FTS5 keyword search -- all with strict project scoping.

Purpose: Provide the data access layer that all higher-level features (MCP tools, hooks, search) will use. Project scoping enforcement at the repository level guarantees observations from project A never leak to project B (MEM-06, SRC-05). FTS5 search enables keyword-based memory retrieval with BM25 relevance ranking.
Output: ObservationRepository, SessionRepository, and SearchEngine classes -- the complete storage API for Phase 1.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-storage-engine/01-RESEARCH.md
@.planning/phases/01-storage-engine/01-01-SUMMARY.md
@.planning/phases/01-storage-engine/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ObservationRepository and SessionRepository with project-scoped CRUD</name>
  <files>
    src/storage/observations.ts
    src/storage/sessions.ts
  </files>
  <action>
    1. Create `src/storage/observations.ts` with class `ObservationRepository`:

       **Constructor:** Takes `BetterSqlite3.Database` instance and `projectHash: string`. The projectHash is set at construction time and baked into EVERY query -- callers cannot accidentally query the wrong project.

       **Prepared statements:** Prepare ALL SQL statements once in the constructor. Reuse for every call. This is significantly faster than ad-hoc queries per better-sqlite3 performance docs.

       **Methods:**

       - `create(input: ObservationInsert): Observation`
         - Validate input with `ObservationInsertSchema.parse(input)` (Zod runtime validation)
         - INSERT into observations with project_hash from constructor
         - Use `RETURNING *` or fetch via `lastInsertRowid` to get the created row including generated id and timestamps
         - Convert embedding Float32Array to Buffer for storage: `input.embedding ? Buffer.from(input.embedding.buffer) : null`
         - Map result through `rowToObservation()` before returning

       - `getById(id: string): Observation | null`
         - SELECT * WHERE id = ? AND project_hash = ? AND deleted_at IS NULL
         - Always scope by project hash
         - Map through rowToObservation or return null

       - `list(options?: { limit?: number; offset?: number; sessionId?: string; since?: string }): Observation[]`
         - SELECT with project scoping, ordered by created_at DESC
         - Default limit 50, offset 0
         - If sessionId provided: add `AND session_id = ?`
         - If since provided: add `AND created_at >= ?`
         - EXCLUDE soft-deleted: `AND deleted_at IS NULL`
         - Map all results through rowToObservation

       - `update(id: string, updates: Partial<Pick<Observation, 'content' | 'embedding' | 'embeddingModel' | 'embeddingVersion'>>): Observation | null`
         - Build SET clause dynamically from provided fields
         - Always set `updated_at = datetime('now')`
         - WHERE id = ? AND project_hash = ? AND deleted_at IS NULL
         - Return updated observation or null if not found/not owned

       - `softDelete(id: string): boolean`
         - SET deleted_at = datetime('now') WHERE id = ? AND project_hash = ? AND deleted_at IS NULL
         - Return true if changes > 0

       - `restore(id: string): boolean`
         - SET deleted_at = NULL WHERE id = ? AND project_hash = ?
         - Return true if changes > 0

       - `count(): number`
         - SELECT COUNT(*) WHERE project_hash = ? AND deleted_at IS NULL

       **Implementation notes:**
       - EVERY query includes `AND project_hash = ?` -- no exceptions. This is the project isolation guarantee.
       - Embedding storage: Float32Array -> `Buffer.from(float32Array.buffer, float32Array.byteOffset, float32Array.byteLength)` for write. Read reversal is handled by rowToObservation.
       - better-sqlite3's `db.transaction()` uses BEGIN IMMEDIATE by default (per research), which correctly handles busy_timeout under concurrent load. Use it for any multi-statement operation.
       - Use `.js` extension in imports for NodeNext ESM resolution.

    2. Create `src/storage/sessions.ts` with class `SessionRepository`:

       **Constructor:** Takes `BetterSqlite3.Database` and `projectHash: string`.

       **Methods:**

       - `create(id: string): Session`
         - INSERT with given id and project_hash
         - Return created session

       - `end(id: string, summary?: string): Session | null`
         - SET ended_at = datetime('now'), optionally set summary
         - WHERE id = ? AND project_hash = ?
         - Return updated session or null

       - `getById(id: string): Session | null`
         - SELECT WHERE id = ? AND project_hash = ?

       - `getLatest(limit?: number): Session[]`
         - SELECT ordered by started_at DESC, project-scoped, default limit 10

       - `getActive(): Session | null`
         - SELECT WHERE ended_at IS NULL AND project_hash = ?, ordered by started_at DESC, LIMIT 1

       Map between snake_case columns and camelCase Session interface in a private helper.

    3. Write tests in `src/storage/__tests__/repositories.test.ts`:
       - Open database via openDatabase at a temp path
       - Create ObservationRepository with projectHash "aaa"
       - Create 3 observations with varying content
       - Verify list() returns 3
       - Verify getById returns correct observation
       - Create ObservationRepository with projectHash "bbb"
       - Verify list() returns 0 (project isolation -- MEM-06, SRC-05)
       - Verify count() for "bbb" is 0
       - Soft-delete one observation in project "aaa"
       - Verify list() returns 2 (soft delete excludes)
       - Verify count() returns 2
       - Restore the soft-deleted observation
       - Verify list() returns 3 again
       - Test update: change content, verify updated_at changed
       - Test embedding roundtrip: create with Float32Array, read back, compare values
       - Create and end a Session, verify getLatest and getActive work
       - Clean up temp database
  </action>
  <verify>
    1. `npx tsc --noEmit` passes
    2. `npx vitest run` passes all repository tests
    3. Verify project isolation: project "bbb" never sees project "aaa" data
    4. Verify soft-delete: deleted observations excluded from list and count
    5. Verify embedding roundtrip: Float32Array -> Buffer -> Float32Array matches
    6. Verify session lifecycle: create, end, getActive, getLatest all work correctly
  </verify>
  <done>
    ObservationRepository provides create, getById, list, update, softDelete, restore, count -- all enforcing project_hash scoping via constructor-bound prepared statements. SessionRepository provides create, end, getById, getLatest, getActive -- all project-scoped. No query can return data from a different project. Soft-deleted observations are excluded from list and count. Embedding Float32Array roundtrips correctly through Buffer storage. Tests prove project isolation, soft-delete, and session lifecycle.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FTS5 search engine with BM25 ranking, snippets, and project scoping</name>
  <files>
    src/storage/search.ts
    src/storage/index.ts
  </files>
  <action>
    1. Create `src/storage/search.ts` with class `SearchEngine`:

       **Constructor:** Takes `BetterSqlite3.Database` and `projectHash: string`.

       **Methods:**

       - `searchKeyword(query: string, options?: { limit?: number; sessionId?: string }): SearchResult[]`

         Core FTS5 search query:
         ```sql
         SELECT
           o.*,
           bm25(observations_fts) AS rank,
           snippet(observations_fts, 0, '<mark>', '</mark>', '...', 32) AS snippet
         FROM observations_fts
         JOIN observations o ON o.rowid = observations_fts.rowid
         WHERE observations_fts MATCH ?
           AND o.project_hash = ?
           AND o.deleted_at IS NULL
         ORDER BY rank
         LIMIT ?
         ```

         Note on BM25: `bm25()` returns NEGATIVE values where more negative = more relevant. `ORDER BY rank` (ascending) puts best matches first without needing DESC.

         **Query sanitization:** Before passing to FTS5 MATCH, sanitize the user's query:
         - Escape or remove FTS5 operators: `"`, `*`, `(`, `)`, `NEAR`, `OR`, `AND`, `NOT` when used as operators
         - For simple multi-word queries: join words with spaces (FTS5 defaults to implicit AND)
         - For single words: pass directly
         - If the query is empty or all-whitespace after sanitization: return empty array

         If sessionId provided in options, add `AND o.session_id = ?` to WHERE clause.
         Default limit: 20.

         Map results to SearchResult[] with `matchType: 'fts'`, using rowToObservation for the observation field.

       - `searchByPrefix(prefix: string, limit?: number): SearchResult[]`
         For autocomplete-style search. Appends `*` to each word for prefix matching:
         ```sql
         WHERE observations_fts MATCH ?  -- query becomes "word1* word2*"
         ```
         Project-scoped and soft-delete filtered like searchKeyword.

       - `rebuildIndex(): void`
         Rebuild the FTS5 index if it gets out of sync:
         ```sql
         INSERT INTO observations_fts(observations_fts) VALUES('rebuild');
         ```

    2. Update `src/storage/index.ts` to export all storage modules:
       ```typescript
       export { openDatabase } from './database.js';
       export type { LaminarkDatabase } from './database.js';
       export { runMigrations, MIGRATIONS } from './migrations.js';
       export { ObservationRepository } from './observations.js';
       export { SessionRepository } from './sessions.js';
       export { SearchEngine } from './search.js';
       // Re-export types that consumers need
       export type { Observation, ObservationInsert, Session, SearchResult, DatabaseConfig } from '../shared/types.js';
       export { getProjectHash, getDbPath, getDatabaseConfig } from '../shared/config.js';
       ```

    3. Write tests in `src/storage/__tests__/search.test.ts`:
       - Open database at temp path
       - Insert 5 observations: 3 in project "aaa" (with varied content including "authentication", "database", "migration"), 2 in project "bbb" (with "authentication", "testing")
       - Search "authentication" in project "aaa": returns 1 result (only project A's)
       - Search "authentication" in project "bbb": returns 1 result (only project B's)
       - Search "database migration" in project "aaa": returns results ranked by BM25 (both words match gets higher rank than one)
       - Search a keyword not present: returns empty array
       - Soft-delete one matching observation: search returns one fewer result
       - Verify snippet contains match context with <mark> tags
       - Test prefix search: "authen" matches "authentication"
       - Test empty query: returns empty array
       - Test query with special characters: safely handled (no SQL injection, no FTS5 syntax error)
       - Clean up temp database
  </action>
  <verify>
    1. `npx tsc --noEmit` passes
    2. `npx vitest run` passes all search tests
    3. Verify project isolation: searching project A never returns project B results
    4. Verify soft-delete exclusion: deleted observations never appear in search
    5. Verify BM25 ranking: results ordered by relevance (most matches first)
    6. Verify snippets: search results include highlighted match context
    7. Verify query sanitization: special characters don't cause errors
    8. `npx tsdown` builds successfully
  </verify>
  <done>
    SearchEngine provides FTS5 keyword search with BM25 ranking, snippet extraction, and strict project scoping. Queries are sanitized for FTS5 safety. Prefix search supports autocomplete use cases. Results never include soft-deleted observations. Results never include observations from other projects. rebuildIndex() available for maintenance. The full storage module (openDatabase, ObservationRepository, SessionRepository, SearchEngine) is exported from the barrel file with config and type re-exports. All tests pass.
  </done>
</task>

</tasks>

<verification>
- Creating observations in project "aaa" and searching from project "bbb" returns zero results
- FTS5 search returns results ranked by BM25 relevance with snippets
- Soft-deleted observations excluded from all queries (list, search, count)
- All CRUD operations work: create, read, update, soft-delete, restore
- Session lifecycle works: create, end, get active, get latest
- FTS5 query sanitization prevents injection and syntax errors
- All tests pass: `npx vitest run`
- Build succeeds: `npx tsdown`
</verification>

<success_criteria>
- Project scoping is absolute: no cross-project data leakage (MEM-06, SRC-05)
- Full-text search works with BM25 ranking and snippets (SRC-05 foundation)
- Soft-delete enables future "forget" MCP tool (MEM-05 foundation)
- Observation schema includes embedding fields for future use (MEM-09)
- All storage operations use prepared statements for performance (research best practice)
- Barrel export provides complete storage API for Phase 2 consumption
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-engine/01-03-SUMMARY.md`
</output>
