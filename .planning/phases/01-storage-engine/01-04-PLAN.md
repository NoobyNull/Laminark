---
phase: 01-storage-engine
plan: 04
type: tdd
wave: 4
depends_on: ["01-03"]
files_modified:
  - src/storage/__tests__/concurrency.test.ts
  - src/storage/__tests__/crash-recovery.test.ts
  - src/storage/__tests__/persistence.test.ts
autonomous: true

must_haves:
  truths:
    - "Three concurrent processes can read and write observations without corruption or data loss"
    - "A process crash mid-write leaves the database in a consistent state with no partial records"
    - "Observations written in one session are readable in a new session after process restart"
    - "Observations from project A are never returned when querying from project B"
    - "Schema stores original text, embedding vector (nullable), and model version metadata in every observation row"
  artifacts:
    - path: "src/storage/__tests__/concurrency.test.ts"
      provides: "Tests proving concurrent read/write safety"
      min_lines: 80
    - path: "src/storage/__tests__/crash-recovery.test.ts"
      provides: "Tests proving crash recovery and WAL consistency"
      min_lines: 40
    - path: "src/storage/__tests__/persistence.test.ts"
      provides: "Tests proving cross-session data persistence and project isolation"
      min_lines: 60
  key_links:
    - from: "src/storage/__tests__/concurrency.test.ts"
      to: "src/storage/database.ts"
      via: "opens multiple Database instances against same file"
      pattern: "openDatabase"
    - from: "src/storage/__tests__/concurrency.test.ts"
      to: "child_process"
      via: "spawns concurrent worker processes for true multi-process testing"
      pattern: "fork|spawn|execFile"
    - from: "src/storage/__tests__/crash-recovery.test.ts"
      to: "src/storage/database.ts"
      via: "opens database, writes mid-transaction, simulates crash, reopens"
      pattern: "openDatabase.*close"
---

<objective>
Concurrency safety testing and crash recovery validation via TDD -- proving the five success criteria for Phase 1.

Purpose: The Phase 1 success criteria are the contract this entire storage engine must satisfy. These tests ARE the acceptance criteria. Writing them first (RED) ensures the criteria are unambiguous, then verifying they pass (GREEN) proves the storage engine is production-ready.
Output: A comprehensive test suite proving concurrent safety, crash recovery, persistence, project isolation, and schema correctness.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-storage-engine/01-01-SUMMARY.md
@.planning/phases/01-storage-engine/01-02-SUMMARY.md
@.planning/phases/01-storage-engine/01-03-SUMMARY.md
</context>

<feature>
  <name>Storage Engine Acceptance Tests</name>
  <files>
    src/storage/__tests__/concurrency.test.ts
    src/storage/__tests__/crash-recovery.test.ts
    src/storage/__tests__/persistence.test.ts
  </files>
  <behavior>
    **Concurrency (MEM-07):**
    - 3 concurrent processes write 100 observations each to the same database
    - After all complete, database has exactly 300 observations (zero lost writes)
    - No SQLITE_BUSY errors propagate (busy_timeout handles contention)
    - Concurrent reads during writes return consistent (not corrupted) data

    **Crash Recovery (MEM-08):**
    - Open database, begin a multi-row insert transaction
    - Kill the process mid-transaction (simulate crash by NOT calling close)
    - Reopen database -- it should be consistent
    - The incomplete transaction's rows should NOT be present (atomic rollback)
    - Previously committed data should be intact

    **Persistence (MEM-01):**
    - Write observations in "session 1" (open DB, write, close)
    - Open DB again as "session 2"
    - All session 1 observations are readable
    - Timestamps, content, source, and metadata are intact

    **Project Isolation (MEM-06, SRC-05):**
    - Write observations to project A (hash "aaaa")
    - Query from project B (hash "bbbb") -- zero results
    - Search from project B -- zero results
    - Write to project B, query project A -- only project A results

    **Schema Completeness (MEM-09):**
    - Insert observation with all fields: content, source, embedding (Float32Array), embeddingModel, embeddingVersion
    - Read it back -- all fields match
    - Insert observation WITHOUT embedding fields (nullable)
    - Read it back -- embedding fields are null
  </behavior>
  <implementation>
    **Test Structure:**

    1. `concurrency.test.ts` -- Uses `child_process.fork()` to spawn actual separate Node.js processes (NOT just async functions -- true multi-process concurrency). Each child process:
       - Opens its own Database connection to the SAME file
       - Writes N observations in a loop
       - Closes and exits

       The parent process waits for all children, then opens the database and counts total observations.

       Create a small helper script `src/storage/__tests__/concurrent-writer.ts` that the test forks. It receives dbPath and projectHash via process.argv, writes observations, and exits.

       Also test concurrent reads: one process writes continuously while another reads continuously. The reader should never see corrupted data (partial rows, garbled text).

    2. `crash-recovery.test.ts` -- Simulates crash by:
       - Opening database
       - Inserting some "committed" observations (outside transaction)
       - Starting a transaction with `db.db.exec('BEGIN')`
       - Inserting "uncommitted" observations inside the transaction
       - Destroying the connection WITHOUT committing (simulates crash: just let the better-sqlite3 object be garbage collected, or explicitly call process.exit in a forked child)
       - Reopening the database
       - Verifying: committed observations present, uncommitted observations absent

    3. `persistence.test.ts` -- Straightforward open/write/close/reopen/read cycle:
       - Tests data persistence
       - Tests project isolation across sessions
       - Tests schema field roundtrip (especially embedding BLOB to Float32Array)
       - Tests FTS5 search works after reopen (index persists)

    **TDD Cycle:**
    - RED: Write all tests first. They should fail because the test infrastructure (helper scripts, test utils) may need setup.
    - GREEN: Verify all tests pass against the existing storage implementation from Plans 01-03. If any fail, fix the storage implementation.
    - REFACTOR: Clean up test helpers, ensure tests are deterministic (use temp directories, clean up after).

    **Test Utilities:**
    Create a shared test helper `src/storage/__tests__/test-utils.ts`:
    - `createTempDb()` -- creates a temp directory, returns config + cleanup function
    - `cleanupTempDb(path)` -- removes temp database files
    - Each test uses its own temp directory to avoid cross-test interference
  </implementation>
</feature>

<verification>
- `npx vitest run` passes ALL tests with zero failures
- Concurrency test proves 3 processes write without data loss (300 observations from 3x100)
- Crash recovery test proves incomplete transactions roll back cleanly
- Persistence test proves data survives close/reopen cycle
- Project isolation test proves zero cross-project leakage in both CRUD and search
- Schema test proves embedding BLOB roundtrips correctly with model metadata
</verification>

<success_criteria>
All five Phase 1 success criteria from ROADMAP.md are proven by passing tests:
1. Observations written in one session are readable in a new session after process restart
2. Three concurrent processes can read and write observations without corruption or data loss
3. A process crash mid-write leaves the database in a consistent state with no partial records
4. Observations from project A are never returned when querying from project B
5. Schema stores original text, embedding vector (nullable), and model version metadata in every observation row
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-engine/01-04-SUMMARY.md`
</output>
