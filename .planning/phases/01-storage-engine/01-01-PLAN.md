---
phase: 01-storage-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - tsdown.config.ts
  - vitest.config.ts
  - .gitignore
  - src/shared/types.ts
  - src/shared/config.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "npm install completes without errors"
    - "tsc --noEmit passes with zero type errors"
    - "vitest runs (infrastructure works even with no tests)"
    - "tsdown builds src/index.ts to dist/ without errors"
    - "package.json name is @laminark/memory with bin entry laminark-server"
  artifacts:
    - path: "package.json"
      provides: "npm package manifest with Phase 1 deps and correct scoped name"
      contains: "@laminark/memory"
    - path: "tsconfig.json"
      provides: "TypeScript configuration for Node.js 22 ESM"
      contains: "NodeNext"
    - path: "src/shared/types.ts"
      provides: "Core type definitions with Zod schemas for observations, sessions, search results"
      exports: ["Observation", "ObservationRow", "ObservationInsert", "Session", "SearchResult", "DatabaseConfig"]
    - path: "src/shared/config.ts"
      provides: "Database path resolution and project hashing"
      exports: ["getProjectHash", "getDbPath", "getConfigDir", "DEFAULT_BUSY_TIMEOUT"]
    - path: "src/index.ts"
      provides: "Package entry point (placeholder for MCP server in Phase 2)"
  key_links:
    - from: "src/shared/config.ts"
      to: "~/.laminark/data.db"
      via: "getDbPath returns single database path per user decision"
      pattern: "join.*\\.laminark.*data\\.db"
    - from: "src/shared/config.ts"
      to: "node:crypto"
      via: "getProjectHash uses SHA-256 on canonical path"
      pattern: "createHash.*sha256"
    - from: "package.json"
      to: "dist/index.js"
      via: "bin entry for npx and global install"
      pattern: "laminark-server.*dist/index\\.js"
---

<objective>
Project scaffolding, TypeScript configuration, core type definitions, and configuration utilities for the @laminark/memory package.

Purpose: Establish the build toolchain, npm package structure, type system, and configuration layer so all subsequent plans can import types, resolve paths, and compile code without setup friction. The package.json must support both `npx @laminark/memory` and global install via `laminark-server` per user decision.
Output: A buildable, testable TypeScript project with core type definitions, config utilities, and correct npm package structure.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-storage-engine/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize npm package with TypeScript toolchain and Phase 1 dependencies</name>
  <files>
    package.json
    tsconfig.json
    tsdown.config.ts
    vitest.config.ts
    .gitignore
    src/index.ts
  </files>
  <action>
    1. Run `npm init -y` to create package.json. Then update it to:
       ```json
       {
         "name": "@laminark/memory",
         "version": "0.1.0",
         "description": "Persistent adaptive memory for Claude Code",
         "type": "module",
         "bin": {
           "laminark-server": "./dist/index.js"
         },
         "main": "./dist/index.js",
         "types": "./dist/index.d.ts",
         "files": ["dist"],
         "engines": { "node": ">=22.0.0" },
         "scripts": {
           "build": "tsdown",
           "check": "tsc --noEmit",
           "test": "vitest run",
           "test:watch": "vitest",
           "prepublishOnly": "npm run build"
         }
       }
       ```

       The `bin` entry is CRITICAL -- it enables:
       - `npx @laminark/memory` (downloads package, runs the bin entry)
       - `npm i -g @laminark/memory` then `laminark-server` (global command)

    2. Install production dependencies:
       ```bash
       npm install better-sqlite3 sqlite-vec zod
       ```
       Do NOT install MCP SDK, hono, huggingface, or any Phase 2+ dependency.

    3. Install dev dependencies:
       ```bash
       npm install -D typescript @types/better-sqlite3 @types/node tsdown vitest
       ```

    4. Create tsconfig.json:
       - `"target": "ES2024"` (Node.js 22 supports this)
       - `"module": "NodeNext"`, `"moduleResolution": "NodeNext"`
       - `"outDir": "dist"`, `"rootDir": "src"`
       - `"strict": true`, `"esModuleInterop": true`, `"skipLibCheck": true`
       - `"declaration": true`, `"declarationMap": true`, `"sourceMap": true`
       - Include: `["src/**/*.ts"]`, Exclude: `["node_modules", "dist", "**/*.test.ts"]`

    5. Create tsdown.config.ts:
       ```typescript
       import { defineConfig } from 'tsdown';
       export default defineConfig({
         entry: ['src/index.ts'],
         format: ['esm'],
         dts: true,
         clean: true,
         outDir: 'dist',
       });
       ```
       Note: entry is src/index.ts (not src/storage/index.ts). This will be the MCP server entry point in Phase 2, but for now it just re-exports the storage module.

    6. Create vitest.config.ts:
       ```typescript
       import { defineConfig } from 'vitest/config';
       export default defineConfig({
         test: {
           globals: true,
           include: ['src/**/*.test.ts'],
         },
       });
       ```

    7. Create .gitignore with: node_modules/, dist/, *.db, *.db-wal, *.db-shm, .env, .DS_Store, coverage/

    8. Create src/index.ts with a shebang line and placeholder:
       ```typescript
       #!/usr/bin/env node
       // Laminark MCP server entry point (Phase 2)
       // For now, re-export the storage module
       export * from './storage/index.js';
       ```
       The shebang line is REQUIRED for the bin entry to work with npx and global install. If tsdown strips it during build, add a post-build script to prepend it. Verify after build.

    After setup, run `npx tsc --noEmit` and `npx tsdown` to verify the toolchain works (may need empty storage/index.ts first).
  </action>
  <verify>
    1. `npm install` completes with exit code 0
    2. package.json contains `"name": "@laminark/memory"` and `"bin": { "laminark-server": "./dist/index.js" }`
    3. `npx tsc --noEmit` exits 0 (once source files exist)
    4. `npx vitest run` exits 0 (no tests yet, should report 0 tests)
    5. `npx tsdown` builds to dist/ and dist/index.js exists
    6. `head -1 dist/index.js` shows `#!/usr/bin/env node` (if not, add post-build fix)
  </verify>
  <done>
    package.json is @laminark/memory with bin entry laminark-server pointing to dist/index.js. Production deps: better-sqlite3, sqlite-vec, zod. Dev deps: typescript, @types/better-sqlite3, @types/node, tsdown, vitest. TypeScript configured for Node.js 22 ESM with NodeNext resolution. Build, check, and test commands all work. Entry point has shebang for CLI execution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create core type definitions and configuration utilities</name>
  <files>
    src/shared/types.ts
    src/shared/config.ts
    src/storage/index.ts
  </files>
  <action>
    1. Create `src/shared/types.ts` with Zod schemas and inferred TypeScript types:

       **ObservationRow** -- the raw database row shape (snake_case, matches SQL columns):
       ```typescript
       export const ObservationRowSchema = z.object({
         rowid: z.number(),  // INTEGER PRIMARY KEY AUTOINCREMENT (for FTS5 content_rowid)
         id: z.string(),     // TEXT NOT NULL UNIQUE (hex random, the public-facing ID)
         project_hash: z.string(),
         content: z.string(),
         source: z.string(),
         session_id: z.string().nullable(),
         embedding: z.instanceof(Buffer).nullable(),  // BLOB in SQLite
         embedding_model: z.string().nullable(),
         embedding_version: z.string().nullable(),
         created_at: z.string(),  // ISO 8601 TEXT
         updated_at: z.string(),
         deleted_at: z.string().nullable(),
       });
       export type ObservationRow = z.infer<typeof ObservationRowSchema>;
       ```

       **Observation** -- the application-layer shape (camelCase, embedding as Float32Array):
       ```typescript
       export interface Observation {
         rowid: number;
         id: string;
         projectHash: string;
         content: string;
         source: string;
         sessionId: string | null;
         embedding: Float32Array | null;
         embeddingModel: string | null;
         embeddingVersion: string | null;
         createdAt: string;
         updatedAt: string;
         deletedAt: string | null;
       }
       ```
       Note: `rowid` is included because FTS5 external content requires it. It is an internal detail but must be accessible for joins.

       **ObservationInsert** -- input for creating observations:
       ```typescript
       export const ObservationInsertSchema = z.object({
         content: z.string().min(1).max(100_000),  // Reasonable size limit
         source: z.string().default('unknown'),
         sessionId: z.string().nullable().default(null),
         embedding: z.instanceof(Float32Array).nullable().default(null),
         embeddingModel: z.string().nullable().default(null),
         embeddingVersion: z.string().nullable().default(null),
       });
       export type ObservationInsert = z.infer<typeof ObservationInsertSchema>;
       ```

       **Session:**
       ```typescript
       export interface Session {
         id: string;
         projectHash: string;
         startedAt: string;
         endedAt: string | null;
         summary: string | null;
       }
       ```

       **SearchResult:**
       ```typescript
       export interface SearchResult {
         observation: Observation;
         score: number;        // BM25 rank (negative, more negative = more relevant)
         matchType: 'fts' | 'vector' | 'hybrid';
         snippet: string;      // FTS5 snippet with match highlighting
       }
       ```

       **DatabaseConfig:**
       ```typescript
       export interface DatabaseConfig {
         dbPath: string;
         busyTimeout: number;
       }
       ```

       Export a **rowToObservation** helper function that maps snake_case ObservationRow to camelCase Observation, converting embedding Buffer to Float32Array:
       ```typescript
       export function rowToObservation(row: ObservationRow): Observation {
         return {
           rowid: row.rowid,
           id: row.id,
           projectHash: row.project_hash,
           content: row.content,
           source: row.source,
           sessionId: row.session_id,
           embedding: row.embedding ? new Float32Array(row.embedding.buffer, row.embedding.byteOffset, row.embedding.byteLength / 4) : null,
           embeddingModel: row.embedding_model,
           embeddingVersion: row.embedding_version,
           createdAt: row.created_at,
           updatedAt: row.updated_at,
           deletedAt: row.deleted_at,
         };
       }
       ```

    2. Create `src/shared/config.ts`:

       - `DEFAULT_BUSY_TIMEOUT = 5000` -- exported constant (>=5000ms per research to prevent SQLITE_BUSY)

       - `getConfigDir(): string` -- returns `~/.laminark/`. Uses `os.homedir()`. Creates directory recursively if it does not exist.

       - `getDbPath(): string` -- returns `join(getConfigDir(), 'data.db')`. This is a SINGLE database file for ALL projects per user locked decision. NOT per-project paths.

       - `getProjectHash(projectDir: string): string` -- creates a deterministic SHA-256 hash of the canonicalized absolute path, truncated to first 16 hex chars. Use `realpathSync(resolve(projectDir))` to canonicalize (resolves symlinks), then `createHash('sha256').update(canonical).digest('hex').slice(0, 16)`.

       - `getDatabaseConfig(): DatabaseConfig` -- returns `{ dbPath: getDbPath(), busyTimeout: DEFAULT_BUSY_TIMEOUT }`.

       Import from `node:crypto`, `node:os`, `node:path`, `node:fs`.

    3. Create `src/storage/index.ts` as a placeholder barrel export:
       ```typescript
       // Storage module - populated in Plan 01-02
       export {};
       ```

    After creating files, run `npx tsc --noEmit` to verify types compile, and `npx tsdown` to verify the build succeeds.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes with zero errors
    2. `npx tsdown` builds to dist/ successfully
    3. Grep confirms: types.ts exports Observation, ObservationRow, ObservationInsert, Session, SearchResult, DatabaseConfig, rowToObservation
    4. Grep confirms: config.ts exports getProjectHash, getDbPath, getConfigDir, getDatabaseConfig, DEFAULT_BUSY_TIMEOUT
    5. Grep confirms: config.ts contains `data.db` (single database, NOT per-project paths)
    6. Grep confirms: config.ts uses `createHash('sha256')` and `realpathSync`
    7. Grep confirms: types.ts ObservationRow has `rowid: z.number()` (INTEGER PRIMARY KEY for FTS5)
  </verify>
  <done>
    Core types defined with Zod schemas: ObservationRow (DB-layer, snake_case with integer rowid for FTS5), Observation (app-layer, camelCase), ObservationInsert (validated input with size limit), Session, SearchResult, DatabaseConfig. rowToObservation helper handles snake_case-to-camelCase mapping including Buffer-to-Float32Array conversion. Config utilities resolve single database at ~/.laminark/data.db (per user decision) and compute deterministic project hashes via SHA-256 on canonical paths. tsc and tsdown both succeed.
  </done>
</task>

</tasks>

<verification>
- `npm install && npx tsc --noEmit && npx vitest run && npx tsdown` all pass
- package.json is @laminark/memory with bin entry laminark-server
- src/shared/types.ts defines all core types with Zod schemas including integer rowid
- src/shared/config.ts resolves single database at ~/.laminark/data.db
- No Phase 2+ dependencies installed (no MCP SDK, no hono, no huggingface)
</verification>

<success_criteria>
- Package named @laminark/memory with correct bin entry (user locked decision)
- ObservationRow includes rowid INTEGER field for FTS5 compatibility (research finding)
- Database path is ~/.laminark/data.db single file (user locked decision, NOT per-project)
- Config defaults include busyTimeout = 5000ms (research: prevents SQLITE_BUSY)
- Types include embedding + model version fields (MEM-09)
- Project hash uses canonical path via realpathSync (research: prevents duplicate paths)
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-engine/01-01-SUMMARY.md`
</output>
