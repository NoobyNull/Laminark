---
phase: 19-path-detection-and-storage
plan: 03
type: execute
wave: 2
depends_on: ["19-01", "19-02"]
files_modified:
  - src/paths/path-tracker.ts
  - src/intelligence/haiku-processor.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "System automatically detects debug sessions from error patterns without manual intervention"
    - "Waypoints are captured during active debug paths with noise filtered out"
    - "System detects resolution when consecutive success signals meet threshold"
    - "Dead ends are tracked as failure waypoint types"
    - "PathTracker lives in MCP server process, not hook handler"
  artifacts:
    - path: "src/paths/path-tracker.ts"
      provides: "State machine singleton for debug path lifecycle"
      exports: ["PathTracker"]
    - path: "src/intelligence/haiku-processor.ts"
      provides: "Path detection step between classify and extract"
      contains: "pathTracker"
    - path: "src/index.ts"
      provides: "PathTracker instantiation and wiring"
      contains: "PathTracker"
  key_links:
    - from: "src/paths/path-tracker.ts"
      to: "src/paths/path-repository.ts"
      via: "PathRepository for persistence"
      pattern: "PathRepository"
    - from: "src/paths/path-tracker.ts"
      to: "src/intelligence/haiku-classifier-agent.ts"
      via: "Consumes ClassificationResult.debug_signal"
      pattern: "debug_signal|DebugSignal"
    - from: "src/intelligence/haiku-processor.ts"
      to: "src/paths/path-tracker.ts"
      via: "Calls pathTracker.processSignal after classification"
      pattern: "pathTracker.*process"
    - from: "src/index.ts"
      to: "src/paths/path-tracker.ts"
      via: "Creates PathTracker and passes to HaikuProcessor"
      pattern: "new PathTracker"
---

<objective>
Build the PathTracker state machine, integrate it into the Haiku processing pipeline, and wire everything together in the server entry point.

Purpose: This plan implements the core intelligence — PATH-01 (auto-detect), PATH-02 (waypoint capture), PATH-03 (resolution detection), and PATH-05 (dead end tracking). The state machine consumes debug signals from the extended classifier (Plan 02) and persists paths/waypoints via PathRepository (Plan 01). Per locked decision: PathTracker lives in MCP server process (not hook handler, which is ephemeral).

Output: Working end-to-end debug path detection integrated into the existing Haiku processing pipeline.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-path-detection-and-storage/19-01-SUMMARY.md
@.planning/phases/19-path-detection-and-storage/19-02-SUMMARY.md
@src/intelligence/haiku-processor.ts
@src/intelligence/haiku-classifier-agent.ts
@src/paths/types.ts
@src/paths/path-repository.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: PathTracker state machine</name>
  <files>src/paths/path-tracker.ts</files>
  <action>
Create `src/paths/path-tracker.ts` implementing a 4-state state machine:

**States:** `idle` -> `potential_debug` -> `active_debug` -> `resolved`

**Constructor:**
```typescript
export class PathTracker {
  constructor(
    private readonly repo: PathRepository,
    private readonly opts?: {
      errorThreshold?: number;      // Errors needed to confirm debug (default: 3)
      windowMs?: number;            // Time window for error threshold (default: 5 * 60 * 1000 = 5min)
      resolutionThreshold?: number; // Consecutive successes to auto-resolve (default: 3)
      maxWaypoints?: number;        // Cap per path (default: 30)
    }
  )
```

**Internal state (in-memory, NOT persisted):**
- `state`: current state ('idle' | 'potential_debug' | 'active_debug' | 'resolved')
- `errorBuffer`: array of `{ timestamp: number, summary: string }` for temporal confirmation
- `consecutiveSuccesses`: counter for resolution detection
- `currentPathId`: string | null

**On construction:** Check `repo.getActivePath()`. If an active path exists (server restart recovery), set state to `active_debug` and `currentPathId` to that path's ID. This handles PATH-04 (persistence across restarts).

**Main method — `processSignal(signal: DebugSignal, observationId: string, observationContent: string): void`:**

Implement state transitions:

**idle state:**
- If `signal.is_error` and `signal.confidence >= 0.5`: add to errorBuffer, transition to `potential_debug`
- Otherwise: no-op

**potential_debug state:**
- If `signal.is_error` and `signal.confidence >= 0.5`: add to errorBuffer
- Prune errorBuffer entries older than `windowMs`
- If errorBuffer.length >= `errorThreshold`: transition to `active_debug`
  - Call `repo.createPath(triggerSummary)` where triggerSummary is the first error's summary
  - Store currentPathId
  - Add waypoints for all buffered errors: `repo.addWaypoint(pathId, 'error', summary, observationId)`
- If no errors in buffer (all expired): transition back to `idle`

**active_debug state:**
- Filter: only add waypoints for significant signals (confidence >= 0.3)
- Cap enforcement: if `repo.countWaypoints(currentPathId) >= maxWaypoints`, skip adding more
- Waypoint type: use `signal.waypoint_hint` if not null, otherwise infer:
  - `signal.is_error` -> 'error'
  - `signal.is_resolution` -> 'success'
  - else -> 'attempt'
- Dead end detection (PATH-05): if previous waypoint was 'attempt' and current is 'error' or a new 'attempt', upgrade previous to 'failure' type? No — simpler: if `signal.waypoint_hint === 'failure'`, use 'failure' type directly. Haiku is smart enough to detect "this fix didn't work" patterns.
- Resolution detection (PATH-03): if `signal.is_resolution`, increment consecutiveSuccesses. If consecutiveSuccesses >= resolutionThreshold, auto-resolve:
  - Call `repo.resolvePath(currentPathId, summary)`
  - Add final 'resolution' waypoint
  - Reset state to `idle`, clear currentPathId, reset consecutiveSuccesses
- If `signal.is_error`: reset consecutiveSuccesses to 0
- Add waypoint via `repo.addWaypoint(currentPathId, waypointType, summary, observationId)`
  - Use first 200 chars of observationContent as summary, or signal.waypoint_hint context

**resolved state:**
- Immediately transition to `idle` (resolved is transient)

**Waypoint filtering (noise reduction):**
Only process signals where `signal.confidence >= 0.3`. Skip signals with null debug_signal entirely. This prevents noise observations from creating waypoints.

**Summary generation for waypoints:**
Use first 200 chars of observationContent, trimmed. This is a simple heuristic — Phase 20 will add Haiku-generated summaries.

Export the PathTracker class. Use `debug('paths', ...)` for logging (import from shared/debug.js).
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors.</verify>
  <done>PathTracker state machine with 4 states, temporal error confirmation, automatic resolution detection, waypoint capture with filtering, dead end tracking via failure waypoint type, and server restart recovery.</done>
</task>

<task type="auto">
  <name>Task 2: HaikuProcessor integration and server wiring</name>
  <files>src/intelligence/haiku-processor.ts, src/index.ts</files>
  <action>
**Modify `src/intelligence/haiku-processor.ts`:**

1. Add PathTracker as an optional dependency (backward compatible):
   - Add `pathTracker?: PathTracker` to constructor options (import PathTracker from '../paths/path-tracker.js')
   - Store as `private readonly pathTracker: PathTracker | null`

2. In `processOne()`, after Step 1 (classification) and BEFORE the noise early-return, add path detection:
   ```typescript
   // Step 1.5: Feed debug signal to path tracker (between classify and extract)
   if (this.pathTracker && result.debug_signal) {
     try {
       this.pathTracker.processSignal(result.debug_signal, obs.id, obs.content);
     } catch (pathErr) {
       const msg = pathErr instanceof Error ? pathErr.message : String(pathErr);
       debug('haiku', 'Path tracking failed (non-fatal)', { id: obs.id, error: msg });
     }
   }
   ```

   IMPORTANT: This must run BEFORE the noise early-return (`if (result.signal === 'noise') { ... return; }`). Even noise observations can contain error signals relevant to debug detection. Move the path tracker call to right after the classification result is obtained, before any early returns.

3. Also feed debug signals from noise observations: the path tracker needs to see errors even in "noise" classified content (e.g., raw test output with failures is classified as noise but contains error signals).

**Modify `src/index.ts`:**

1. Add imports:
   ```typescript
   import { initPathSchema } from './paths/schema.js';
   import { PathRepository } from './paths/path-repository.js';
   import { PathTracker } from './paths/path-tracker.js';
   ```

2. After `initGraphSchema(db.db)`, add:
   ```typescript
   initPathSchema(db.db);
   ```

3. Before the HaikuProcessor construction, create PathTracker:
   ```typescript
   const pathRepo = new PathRepository(db.db, projectHash);
   const pathTracker = new PathTracker(pathRepo);
   ```

4. Pass pathTracker to HaikuProcessor constructor:
   ```typescript
   const haikuProcessor = new HaikuProcessor(db.db, projectHash, {
     intervalMs: 30_000,
     batchSize: 10,
     concurrency: 3,
     pathTracker,  // NEW
   });
   ```

5. Add pathTracker stop to shutdown handler (no-op needed since PathTracker has no timer, but add a comment for clarity).
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Run `npm test` to confirm existing tests still pass (path tracking is additive, should not break anything). Grep for "pathTracker" in haiku-processor.ts and index.ts to confirm wiring.</verify>
  <done>PathTracker integrated into Haiku pipeline — every classified observation feeds its debug signal to the state machine. Server creates PathTracker on startup with restart recovery. Existing functionality unchanged (pathTracker is optional in HaikuProcessor).</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm test` passes (existing tests unbroken)
- PathTracker created in index.ts and passed to HaikuProcessor
- initPathSchema called during server startup
- HaikuProcessor.processOne feeds debug_signal to pathTracker before noise early-return
- PathTracker recovers active path on construction (restart resilience)
- Waypoints capped at 30 per path
- Resolution detected after 3 consecutive successes
- Debug detection requires 3 errors within 5-minute window
</verification>

<success_criteria>
- End-to-end flow: observation -> classify -> debug signal -> path tracker -> SQLite persistence
- Automatic detection: repeated errors trigger path creation without manual intervention
- Automatic resolution: consecutive successes close the path
- Dead ends: failure waypoint type distinguishes failed attempts
- Restart resilient: active paths recovered from SQLite on server start
- Zero regression: all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-path-detection-and-storage/19-03-SUMMARY.md`
</output>
