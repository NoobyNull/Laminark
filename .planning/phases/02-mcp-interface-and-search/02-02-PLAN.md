---
phase: 02-mcp-interface-and-search
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/mcp/tools/recall.ts
  - src/mcp/server.ts
  - src/storage/observations.ts
autonomous: true

must_haves:
  truths:
    - "Claude can search memories by keyword and receive compact ranked results"
    - "Claude can view memory details at three disclosure levels: compact, timeline, full"
    - "Claude can purge (soft-delete) a memory by ID, hiding it from normal search"
    - "Claude can restore a previously purged memory, making it searchable again"
    - "Search results never exceed 2000 tokens"
    - "Multi-result operations require explicit ID selection (no blind act-on-all)"
  artifacts:
    - path: "src/mcp/tools/recall.ts"
      provides: "Unified recall tool with search, view, purge, restore actions"
      exports: ["registerRecall"]
    - path: "src/storage/observations.ts"
      provides: "Extended observation queries for purged items and title search"
  key_links:
    - from: "src/mcp/tools/recall.ts"
      to: "src/storage/search.ts"
      via: "SearchEngine.searchKeyword() for FTS5 search"
      pattern: "searchEngine\\.searchKeyword"
    - from: "src/mcp/tools/recall.ts"
      to: "src/storage/observations.ts"
      via: "ObservationRepository for getById, softDelete, restore, list"
      pattern: "obsRepo\\.(getById|softDelete|restore|list)"
    - from: "src/mcp/tools/recall.ts"
      to: "src/mcp/token-budget.ts"
      via: "enforceTokenBudget for response size control"
      pattern: "enforceTokenBudget"
    - from: "src/mcp/server.ts"
      to: "src/mcp/tools/recall.ts"
      via: "registerRecall() called during server setup"
      pattern: "registerRecall"
---

<objective>
Implement the unified recall tool -- the primary memory retrieval and management interface per user's locked decision.

Purpose: The recall tool is the single interface for searching, viewing, purging, and restoring memories. It replaces what would have been 4-5 separate tools. The multi-step interaction pattern (search -> select -> act) prevents blind bulk operations.

Output: Working recall tool with all four actions (search/view/purge/restore), token-budget-enforced responses, and three-level progressive disclosure.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-mcp-interface-and-search/02-CONTEXT.md
@.planning/phases/02-mcp-interface-and-search/02-RESEARCH.md
@.planning/phases/02-mcp-interface-and-search/02-01-SUMMARY.md
@src/mcp/server.ts
@src/mcp/tools/save-memory.ts
@src/mcp/token-budget.ts
@src/storage/observations.ts
@src/storage/search.ts
@src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ObservationRepository for recall tool needs</name>
  <files>
    src/storage/observations.ts
  </files>
  <action>
Add three new methods to ObservationRepository (keeping all existing methods intact):

1. `getByIdIncludingDeleted(id: string): Observation | null`
   - Like getById but WITHOUT the `deleted_at IS NULL` filter
   - Needed for restore operations (must find purged items)
   - Add prepared statement in constructor: SELECT * FROM observations WHERE id = ? AND project_hash = ?

2. `listIncludingDeleted(options?: { limit?: number; offset?: number }): Observation[]`
   - Like list() but WITHOUT the `deleted_at IS NULL` filter
   - Needed for recall with include_purged=true
   - Default limit 50, ordered by created_at DESC, rowid DESC

3. `getByTitle(title: string, options?: { limit?: number; includePurged?: boolean }): Observation[]`
   - Search observations by exact or LIKE title match
   - Use `WHERE project_hash = ? AND title LIKE ?` with `%title%` pattern
   - Respect includePurged flag (default false: adds AND deleted_at IS NULL)
   - Default limit 20
   - Ordered by created_at DESC, rowid DESC

All methods MUST scope to this.projectHash (following established pattern). All prepared statements that can be prepared in constructor should be. For getByTitle with optional includePurged, use dynamic SQL since the WHERE clause varies.

IMPORTANT: Do NOT modify any existing method signatures or behavior. Only ADD new methods.
  </action>
  <verify>
    Run `npm run check` (TypeScript compilation succeeds).
    Run `npm test` (all existing repository tests pass -- no regressions).
  </verify>
  <done>
    ObservationRepository has getByIdIncludingDeleted, listIncludingDeleted, and getByTitle methods.
    All new methods enforce project_hash scoping.
    All existing methods unchanged.
    All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement unified recall tool with progressive disclosure</name>
  <files>
    src/mcp/tools/recall.ts
    src/mcp/server.ts
  </files>
  <action>
1. Create `src/mcp/tools/recall.ts`:
   - Export `registerRecall(server, db, projectHash)` function
   - Use `server.registerTool('recall', config, callback)` (NOT deprecated server.tool())
   - Tool config:
     - title: 'Recall Memories'
     - description: 'Search, view, purge, or restore memories. Search first to find matches, then act on specific results by ID.'
     - inputSchema with Zod:
       - query: z.string().optional().describe('FTS5 keyword search query')
       - id: z.string().optional().describe('Direct lookup by observation ID')
       - title: z.string().optional().describe('Search by title (partial match)')
       - action: z.enum(['view', 'purge', 'restore']).default('view').describe('Action: view (show details), purge (soft-delete), restore (un-delete)')
       - ids: z.array(z.string()).optional().describe('Specific observation IDs to act on (from previous search)')
       - detail: z.enum(['compact', 'timeline', 'full']).default('compact').describe('View detail level: compact (index), timeline (chronological context), full (complete text)')
       - limit: z.number().int().min(1).max(50).default(10).describe('Maximum results to return')
       - include_purged: z.boolean().default(false).describe('Include soft-deleted items (for restore operations)')

   - Callback implementation logic:

   **SEARCH PHASE** (when query, id, or title is provided WITHOUT ids):
   - If `id` provided: direct lookup via obsRepo.getById() or obsRepo.getByIdIncludingDeleted() based on include_purged
   - If `query` provided: FTS5 search via searchEngine.searchKeyword(query, { limit })
   - If `title` provided: title search via obsRepo.getByTitle(title, { limit, includePurged: include_purged })
   - If none provided and action is 'view': list recent via obsRepo.list({ limit }) or obsRepo.listIncludingDeleted({ limit })

   **FORMAT PHASE** (format results based on detail level):
   - `compact`: For each result, output: `[{index}] {id_short} | {title} | {score if search} | {snippet_100chars} | {created_date}`
     - id_short = first 8 chars of observation ID
     - snippet = first 100 chars of content, no newlines
     - Use enforceTokenBudget() from token-budget.ts with TOKEN_BUDGET (2000)
     - Append total count and truncation notice if truncated
   - `timeline`: Group results by date (YYYY-MM-DD), for each: `{time} | {title} | {source} | {snippet_150chars}`
     - Use enforceTokenBudget() with TOKEN_BUDGET
   - `full`: Return complete observation text for each result
     - Use enforceTokenBudget() -- if a single observation exceeds budget, truncate text with "[truncated at {N} tokens]"
     - For full detail on a single ID lookup, allow up to 4000 tokens (FULL_DETAIL_BUDGET constant)

   **ACTION PHASE** (when ids array is provided with purge or restore action):
   - `purge`: For each id in ids array, call obsRepo.softDelete(id). Collect results (success/not-found).
     - Return: "Purged {N}/{total} memories. {failures if any}"
   - `restore`: For each id in ids array, call obsRepo.restore(id). Collect results.
     - Return: "Restored {N}/{total} memories. {failures if any}"
   - `view` with ids: Fetch each by ID, format at requested detail level

   **ERROR HANDLING:**
   - No results found: Return helpful message "No memories found matching '{query}'. Try broader search terms."
   - Invalid combination (ids + query): Return error "Provide either a search (query/id/title) or IDs to act on, not both."
   - Action on empty ids: Return error "Provide ids array to specify which memories to {action}."

   **RESPONSE FORMAT:**
   - All responses are CallToolResult with content: [{ type: 'text', text: formattedResponse }]
   - Add metadata footer to search results: `\n---\n{total} result(s) | {tokenEstimate} est. tokens | detail: {detail}`
   - If truncated: append ` | truncated (use 'id' param for full detail)`

2. Update `src/mcp/server.ts`:
   - Import registerRecall from './tools/recall.js'
   - Call registerRecall(server, db, projectHash) alongside registerSaveMemory in createServer or startServer

CRITICAL PER USER DECISION: The recall tool is a SINGLE unified tool. Do NOT create separate tools for search, forget, restore, get_observations, or timeline. Everything goes through recall with action parameter.

CRITICAL PER USER DECISION: Multi-result selection -- search always returns a list first. Purge/restore require explicit ids array. Never act on all matches blindly.
  </action>
  <verify>
    Run `npm run check` (TypeScript compilation succeeds).
    Run `npm test` (all tests pass).
    Verify recall tool is registered in server.ts alongside save_memory.
    Verify token budget enforcement is applied to all response paths.
    Verify no console.log calls in src/mcp/ directory.
  </verify>
  <done>
    Unified recall tool is registered with search, view, purge, restore actions.
    Compact/timeline/full progressive disclosure levels work with token budget enforcement.
    Purge and restore operate on explicit IDs (multi-result selection pattern).
    FTS5 keyword search, direct ID lookup, and title search all work as recall modes.
    include_purged flag allows finding soft-deleted items for restore.
    All responses stay within 2000 token budget (4000 for single-item full detail).
  </done>
</task>

</tasks>

<verification>
- `npm run check` passes with no type errors
- `npm test` passes (all existing tests + no regressions)
- recall tool registered alongside save_memory
- No separate forget/restore/get_observations/timeline tools exist (unified recall only)
- Token budget enforced on all recall response paths
- No console.log in src/mcp/ (grep verification)
</verification>

<success_criteria>
- Recall tool handles all 4 actions: search (FTS5/id/title), view (compact/timeline/full), purge, restore
- Progressive disclosure works at 3 levels with token budget enforcement
- Purge/restore require explicit ID selection (no blind bulk operations)
- include_purged flag enables finding soft-deleted items
- All responses include metadata footer with result count and token estimate
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-interface-and-search/02-02-SUMMARY.md`
</output>
