---
phase: 02-mcp-interface-and-search
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/mcp/tools/save-memory.ts
  - src/mcp/tools/forget.ts
  - src/mcp/tools/get-observations.ts
  - src/mcp/server.ts
autonomous: true

must_haves:
  truths:
    - "Claude can call save_memory tool to persist user-provided text as a new observation"
    - "Claude can call forget tool to soft-delete a memory that disappears from search but is recoverable"
    - "Claude can call get_observations tool with specific IDs to retrieve full observation details"
  artifacts:
    - path: "src/mcp/tools/save-memory.ts"
      provides: "MCP tool for manually saving observations"
      exports: ["registerSaveMemoryTool"]
    - path: "src/mcp/tools/forget.ts"
      provides: "MCP tool for soft-deleting observations"
      exports: ["registerForgetTool"]
    - path: "src/mcp/tools/get-observations.ts"
      provides: "MCP tool for retrieving full observation details by ID"
      exports: ["registerGetObservationsTool"]
  key_links:
    - from: "src/mcp/tools/save-memory.ts"
      to: "src/storage/"
      via: "calls Phase 1 storage layer to INSERT observation"
      pattern: "insert|create.*observation"
    - from: "src/mcp/tools/forget.ts"
      to: "src/storage/"
      via: "calls Phase 1 storage layer to SET deleted_at timestamp"
      pattern: "update.*deleted_at|soft.?delete"
    - from: "src/mcp/tools/get-observations.ts"
      to: "src/storage/"
      via: "calls Phase 1 storage layer to SELECT observations by ID"
      pattern: "select.*where.*id"
    - from: "src/mcp/server.ts"
      to: "src/mcp/tools/"
      via: "registers all three tools via server.tool()"
      pattern: "server\\.tool\\("
---

<objective>
Implement save_memory, forget, and get_observations MCP tools -- the CRUD operations that let Claude manage memories.

Purpose: These three tools complete the core memory management interface. save_memory satisfies MEM-04 (manual memory saving). forget satisfies MEM-05 (soft delete with recovery). get_observations is the third layer of progressive disclosure (full details after compact index from search).

Output: Three working MCP tools registered on the server, each with Zod input validation and proper error handling.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/02-mcp-interface-and-search/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement save_memory and forget tools</name>
  <files>
    src/mcp/tools/save-memory.ts
    src/mcp/tools/forget.ts
  </files>
  <action>
Create src/mcp/tools/save-memory.ts:

Tool name: "save_memory"
Description: "Save a new memory observation. Use this when the user explicitly asks you to remember something, or when you encounter information worth preserving."

Zod input schema:
- text: z.string().min(1).max(5000).describe("The text content to save as a memory")
- source: z.string().default("manual").describe("Source of the memory (e.g., 'manual', 'conversation')")
- projectId: z.string().optional().describe("Project to associate with (defaults to current)")

Handler implementation:
1. Generate a UUID v4 for the observation ID (use crypto.randomUUID()).
2. Get or derive the projectId (use provided value, or fall back to a default project ID from server config / environment variable like MEMORITE_PROJECT_ID or process.cwd()).
3. Get the current sessionId from the server context (if available) or generate a placeholder.
4. Call the Phase 1 storage layer to INSERT into observations table: { id, text, source, session_id, project_id, created_at: new Date().toISOString(), updated_at: new Date().toISOString(), deleted_at: null, embedding: null, model_version: null }.
5. Return ToolResponse with confirmation: "Memory saved (id: {id}). Text: {first 80 chars}..."
6. On error, return ToolResponse with isError: true.

Create src/mcp/tools/forget.ts:

Tool name: "forget"
Description: "Soft-delete a memory observation. The memory disappears from search results but can be recovered later. Use this when the user asks to forget or remove a specific memory."

Zod input schema:
- id: z.string().uuid().describe("The ID of the observation to forget")
- projectId: z.string().optional().describe("Project scope for verification")

Handler implementation:
1. Verify the observation exists and belongs to the specified project (or current project).
2. Verify it is not already deleted (deleted_at IS NULL).
3. UPDATE the observation: SET deleted_at = new Date().toISOString(), updated_at = new Date().toISOString().
4. Return ToolResponse confirming: "Memory forgotten (id: {id}). It has been removed from search but can be recovered."
5. If observation not found, return error: "No observation found with id: {id}"
6. If already deleted, return: "Observation {id} was already forgotten."
  </action>
  <verify>
Run: npx tsc --noEmit (no type errors)
Verify save_memory creates a row in observations table.
Verify forget sets deleted_at timestamp without removing the row.
Verify a forgotten observation no longer appears in search results (search tool from Plan 01 filters by deleted_at IS NULL).
  </verify>
  <done>
save_memory tool accepts text input and persists it as a new observation with generated UUID. forget tool soft-deletes by setting deleted_at timestamp. Both tools validate input with Zod schemas and return proper ToolResponse format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement get_observations tool for full detail retrieval</name>
  <files>
    src/mcp/tools/get-observations.ts
    src/mcp/server.ts
  </files>
  <action>
Create src/mcp/tools/get-observations.ts:

Tool name: "get_observations"
Description: "Retrieve full details for specific observations by their IDs. This is the detail layer -- use search to find relevant IDs first, then get_observations for the complete text. Designed for progressive disclosure: search gives you the index, this gives you the content."

Zod input schema:
- ids: z.array(z.string().uuid()).min(1).max(10).describe("Array of observation IDs to retrieve (max 10)")
- projectId: z.string().optional().describe("Project scope for verification")

Handler implementation:
1. Query observations table for all matching IDs: SELECT * FROM observations WHERE id IN (?, ?, ...) AND project_id = ? AND deleted_at IS NULL
2. Use parameterized queries (NOT string interpolation) to prevent SQL injection. For the IN clause with better-sqlite3, construct the appropriate number of placeholders.
3. For each observation, format as full detail:
   - id, full text (no truncation), source, sessionId, createdAt, updatedAt
4. Return results as JSON array in ToolResponse.
5. If some IDs not found, include them in a "not_found" array in the response.
6. If no IDs found at all, return: "No observations found for the provided IDs."

Update src/mcp/server.ts to register all three new tools:
- Import registerSaveMemoryTool, registerForgetTool, registerGetObservationsTool
- Call each registration function during server setup, passing server and db handles
- Maintain the registration pattern established in Plan 01 for the search tool
  </action>
  <verify>
Run: npx tsc --noEmit (no type errors)
Save a memory via save_memory, note the returned ID. Call get_observations with that ID. Verify the full text matches what was saved.
Forget the memory via forget. Call get_observations with the same ID. Verify it returns "not found" (soft-deleted observations are excluded).
  </verify>
  <done>
get_observations tool accepts an array of observation IDs and returns full details for each. All three new tools (save_memory, forget, get_observations) are registered on the MCP server. The server now exposes 4 tools total (search + these 3). Input validation via Zod. SQL injection prevented via parameterized queries.
  </done>
</task>

</tasks>

<verification>
- save_memory: accepts text, persists observation, returns confirmation with ID
- forget: accepts ID, sets deleted_at, observation disappears from search
- get_observations: accepts array of IDs, returns full observation details
- All three tools registered on MCP server (total: 4 tools with search)
- Soft-deleted observations excluded from get_observations results
- Input validation via Zod schemas on all tools
- SQL queries use parameterized placeholders (no string interpolation)
- Error responses are graceful ToolResponse with isError: true
</verification>

<success_criteria>
Claude can save a memory, retrieve it by ID, and forget it. The forget operation is a soft delete (sets deleted_at) that hides the observation from search and get_observations but does not destroy the row. All tools compile and are registered on the MCP server.
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-interface-and-search/02-02-SUMMARY.md`
</output>
