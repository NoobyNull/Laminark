---
phase: 02-mcp-interface-and-search
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/mcp/tools/recall.ts
  - src/storage/observations.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Claude can search memories by keyword and receive BM25-ranked compact results"
    - "Claude can view memory details at three disclosure levels: compact index, timeline context, full text"
    - "Claude can purge (soft-delete) a memory by ID, which disappears from normal search but stays in DB"
    - "Claude can restore a previously purged memory, making it searchable again"
    - "Search results never exceed 2000 tokens (4000 for single-item full view)"
    - "Purge and restore require explicit IDs -- no blind act-on-all-matches"
  artifacts:
    - path: "src/mcp/tools/recall.ts"
      provides: "Unified recall tool with search, view, purge, restore actions and 3-level progressive disclosure"
      exports: ["registerRecall"]
    - path: "src/storage/observations.ts"
      provides: "Extended methods: getByIdIncludingDeleted, listIncludingDeleted, getByTitle"
  key_links:
    - from: "src/mcp/tools/recall.ts"
      to: "src/storage/search.ts"
      via: "SearchEngine.searchKeyword() for FTS5 keyword search"
      pattern: "searchEngine\\.searchKeyword"
    - from: "src/mcp/tools/recall.ts"
      to: "src/storage/observations.ts"
      via: "ObservationRepository for CRUD and extended query methods"
      pattern: "repo\\.(getById|softDelete|restore|list|getByTitle)"
    - from: "src/mcp/tools/recall.ts"
      to: "src/mcp/token-budget.ts"
      via: "enforceTokenBudget for response size control"
      pattern: "enforceTokenBudget"
    - from: "src/index.ts"
      to: "src/mcp/tools/recall.ts"
      via: "registerRecall() called during startup"
      pattern: "registerRecall"
---

<objective>
Implement the unified recall tool -- the single interface for searching, viewing, purging, and restoring memories -- per the user's locked decision.

Purpose: The recall tool consolidates what would be 4-5 separate tools into one unified interface. The multi-step interaction pattern (search returns list with IDs, then caller acts on specific IDs) prevents blind bulk operations and keeps Claude in control of selection. Progressive disclosure at 3 levels prevents context window poisoning.

Output: Working recall tool handling all four actions (search/view/purge/restore), token-budget-enforced responses at 3 detail levels, and ObservationRepository extensions for purged-item queries.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-mcp-interface-and-search/02-CONTEXT.md
@.planning/phases/02-mcp-interface-and-search/02-RESEARCH.md
@.planning/phases/02-mcp-interface-and-search/02-01-SUMMARY.md
@src/mcp/server.ts
@src/mcp/tools/save-memory.ts
@src/mcp/token-budget.ts
@src/storage/observations.ts
@src/storage/search.ts
@src/shared/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ObservationRepository for recall tool queries</name>
  <files>
    src/storage/observations.ts
  </files>
  <action>
Add three new methods to ObservationRepository. Keep ALL existing methods unchanged -- only ADD new functionality.

**Method 1: `getByIdIncludingDeleted(id: string): Observation | null`**

Add a new prepared statement in the constructor:
```sql
SELECT * FROM observations WHERE id = ? AND project_hash = ?
```
(Note: no `deleted_at IS NULL` filter -- this finds both active and soft-deleted observations.)

Used by the recall tool for restore operations (must find purged items to restore them).

**Method 2: `listIncludingDeleted(options?: { limit?: number; offset?: number }): Observation[]`**

Dynamic SQL query (not prepared -- limit/offset vary):
```sql
SELECT * FROM observations WHERE project_hash = ? ORDER BY created_at DESC, rowid DESC LIMIT ? OFFSET ?
```
Default limit: 50, default offset: 0. No `deleted_at IS NULL` filter.

Used by recall with `include_purged: true` to show all items including soft-deleted ones.

**Method 3: `getByTitle(title: string, options?: { limit?: number; includePurged?: boolean }): Observation[]`**

Dynamic SQL (WHERE clause varies based on includePurged):
```sql
SELECT * FROM observations
WHERE project_hash = ? AND title LIKE ?
  [AND deleted_at IS NULL]  -- omit when includePurged is true
ORDER BY created_at DESC, rowid DESC
LIMIT ?
```
Use `%${title}%` for the LIKE parameter (partial match). Default limit: 20, default includePurged: false.

Used by recall when caller searches by title substring.

All three methods MUST scope to `this.projectHash` (following the constructor-bound pattern established in Phase 1). Use `rowToObservation()` to map results. Add debug logging consistent with existing methods.

IMPORTANT: Do NOT modify any existing method. The existing `getById`, `list`, `softDelete`, `restore`, `create`, `update`, and `count` methods must remain exactly as they are.
  </action>
  <verify>
Run `npm run check` -- TypeScript compiles without errors.
Run `npm test` -- all existing 78+ repository tests pass unchanged.
Verify new methods exist by checking TypeScript compilation of a file importing them.
  </verify>
  <done>
ObservationRepository has 3 new methods: getByIdIncludingDeleted (finds purged items), listIncludingDeleted (lists all items), getByTitle (partial title match). All enforce project_hash scoping. All existing methods unchanged. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement unified recall tool with progressive disclosure</name>
  <files>
    src/mcp/tools/recall.ts
    src/index.ts
  </files>
  <action>
**Step 1: Create `src/mcp/tools/recall.ts`**

Export `registerRecall(server: McpServer, db: BetterSqlite3.Database, projectHash: string)`.

Use `server.registerTool('recall', config, callback)` (NOT deprecated `server.tool()`).

**Tool config:**
- title: `'Recall Memories'`
- description: `'Search, view, purge, or restore memories. Search first to find matches, then act on specific results by ID.'`
- inputSchema (Zod):
  - `query`: `z.string().optional().describe('FTS5 keyword search query')`
  - `id`: `z.string().optional().describe('Direct lookup by observation ID')`
  - `title`: `z.string().optional().describe('Search by title (partial match)')`
  - `action`: `z.enum(['view', 'purge', 'restore']).default('view').describe('Action to take on results: view (show details), purge (soft-delete), restore (un-delete)')`
  - `ids`: `z.array(z.string()).optional().describe('Specific observation IDs to act on (from a previous search result)')`
  - `detail`: `z.enum(['compact', 'timeline', 'full']).default('compact').describe('View detail level: compact (index ~80 tokens/result), timeline (date-grouped), full (complete text)')`
  - `limit`: `z.number().int().min(1).max(50).default(10).describe('Maximum results to return')`
  - `include_purged`: `z.boolean().default(false).describe('Include soft-deleted items in results (needed for restore)')`

**Callback implementation -- three phases:**

**PHASE A: Input Validation**

Check for conflicting parameters:
- If both `ids` and any of `query`/`id`/`title` are provided: return error "Provide either a search query or IDs to act on, not both."
- If action is 'purge' or 'restore' and `ids` is not provided and `id` is not provided: return error "Provide ids array or id to specify which memories to {action}."

**PHASE B: Resolve Observations**

Create `ObservationRepository(db, projectHash)` and `SearchEngine(db, projectHash)`.

Determine which observations to work with:

1. If `ids` provided: Fetch each ID via `repo.getByIdIncludingDeleted(id)`. Collect results, track not-found IDs.
2. If `id` provided (single): Fetch via `repo.getById(id)` or `repo.getByIdIncludingDeleted(id)` based on include_purged. Return single-item array.
3. If `query` provided: Call `searchEngine.searchKeyword(query, { limit })`. Note: SearchEngine already handles query sanitization and project scoping. The FTS5 search now covers both title and content columns (migration 005). For BM25 scoring with title weighting: update the SearchEngine.searchKeyword SQL to use `bm25(observations_fts, 2.0, 1.0)` instead of `bm25(observations_fts)` -- this weights title matches 2x content matches. **IMPORTANT: This BM25 weight change should be made in `src/storage/search.ts` searchKeyword() method** -- change `bm25(observations_fts) AS rank` to `bm25(observations_fts, 2.0, 1.0) AS rank`. Also update the `snippet()` call to use column index 1 for content snippets: `snippet(observations_fts, 1, '<mark>', '</mark>', '...', 32)` since title is now column 0.
4. If `title` provided: Call `repo.getByTitle(title, { limit, includePurged: include_purged })`.
5. If nothing provided (no query, id, title, ids): List recent via `repo.list({ limit })` or `repo.listIncludingDeleted({ limit })` based on include_purged.

**PHASE C: Execute Action**

**action = 'view'** (the default):
Format observations based on `detail` level.

- `compact`: For each observation, produce one line:
  ```
  [{index}] {id_short} | {title ?? 'untitled'} | {score or '-'} | {snippet_100} | {created_date}
  ```
  Where id_short = first 8 chars, snippet_100 = first 100 chars of content with newlines replaced by spaces, created_date = YYYY-MM-DD.
  Apply `enforceTokenBudget(observations, formatCompact, TOKEN_BUDGET)`.

- `timeline`: Group observations by date (YYYY-MM-DD). For each group, header is the date. Under each date, for each observation:
  ```
  {HH:MM} | {title ?? 'untitled'} | {source} | {snippet_150}
  ```
  Apply `enforceTokenBudget(observations, formatTimeline, TOKEN_BUDGET)`.

- `full`: For each observation, show:
  ```
  --- {id_short} | {title ?? 'untitled'} | {created_at} ---
  {full content text}
  ```
  For single-item lookups (by id), use `FULL_VIEW_BUDGET` (4000 tokens). For multi-item, use `TOKEN_BUDGET` (2000). If a single observation's content exceeds the budget, truncate with `[...truncated at ~{N} tokens]`.

Append metadata footer to all view responses:
```
---
{total} result(s) | ~{tokenEstimate} tokens | detail: {detail}
```
If truncated: append ` | truncated (use id for full view)`

**action = 'purge'**:
For each ID in `ids` (or single `id`), call `repo.softDelete(id)`. Track successes and failures.
Return: `"Purged {success}/{total} memories.{failures details if any}"`

**action = 'restore'**:
For each ID in `ids` (or single `id`), call `repo.restore(id)`. Track successes and failures.
Return: `"Restored {success}/{total} memories.{failures details if any}"`

**ERROR RESPONSES:**
- No results found: `"No memories found matching '{query}'. Try broader search terms or check the ID."`
- All errors use `{ content: [{ type: 'text', text: message }], isError: true }`

**Step 2: Update SearchEngine BM25 weights in `src/storage/search.ts`**

In `searchKeyword()`:
- Change `bm25(observations_fts) AS rank` to `bm25(observations_fts, 2.0, 1.0) AS rank`
- Change `snippet(observations_fts, 0, ...)` to `snippet(observations_fts, 1, ...)` (column index 1 = content, since title is now column 0)

In `searchByPrefix()`:
- Same changes: bm25 weights to `2.0, 1.0` and snippet column to `1`

**Step 3: Update `src/index.ts`**

Import `registerRecall` from `./mcp/tools/recall.js`. Add the registration call after `registerSaveMemory`:
```typescript
registerRecall(server, db.db, projectHash);
```

CRITICAL PER USER DECISION: This is a SINGLE unified tool. Do NOT create separate search, forget, restore, or timeline tools.

CRITICAL PER USER DECISION: Multi-result selection -- search always returns a list first. Purge/restore require explicit ids. No blind act-on-all.

CRITICAL: No console.log. All logging via debug(). better-sqlite3 calls are synchronous inside async handlers -- this is correct.
  </action>
  <verify>
Run `npm run check` -- TypeScript compiles without errors.
Run `npm test` -- all tests pass (BM25 weight change may affect ranking order in some search tests -- if so, the tests should still pass since they test for relevance, not exact scores; verify and adjust if needed).
Verify recall tool is registered by confirming registerRecall is called in src/index.ts.
Run `grep -r "console.log" src/` -- zero matches.
Verify no separate forget/restore/timeline tools exist -- only save_memory and recall.
  </verify>
  <done>
Unified recall tool registered with search (FTS5 query, ID, title), view (compact/timeline/full), purge (soft-delete), and restore (un-delete) actions. BM25 scoring weights title 2x content. Token budget enforcement applied to all view responses (2000 compact/timeline, 4000 single-item full). Purge/restore require explicit IDs. All responses include metadata footer. src/index.ts registers both save_memory and recall tools.
  </done>
</task>

</tasks>

<verification>
- `npm run check` passes with no type errors
- `npm test` passes all tests (existing + no regressions from BM25 weight/snippet changes)
- recall tool registered alongside save_memory in src/index.ts
- No separate forget/restore/get_observations/timeline tools exist (only recall)
- Token budget enforced on all recall response paths (compact, timeline, full)
- Purge and restore require explicit IDs -- error returned without them
- No console.log in src/mcp/ directory
- BM25 weights title 2x content: bm25(observations_fts, 2.0, 1.0)
- Snippet extracts from content column (index 1), not title (index 0)
</verification>

<success_criteria>
- Recall tool handles all 4 actions: search (FTS5/id/title), view (compact/timeline/full), purge, restore
- Progressive disclosure at 3 levels with token budget enforcement (2000 default, 4000 single-item full)
- Purge/restore require explicit ID selection (no blind bulk operations)
- include_purged flag enables finding soft-deleted items for restore workflow
- FTS5 search covers both title and content columns with title weighted 2x
- All responses include metadata footer with result count and token estimate
- Both MCP tools (save_memory + recall) registered in src/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-interface-and-search/02-02-SUMMARY.md`
</output>
