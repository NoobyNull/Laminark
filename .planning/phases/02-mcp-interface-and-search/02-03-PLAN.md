---
phase: 02-mcp-interface-and-search
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - .mcp.json
  - src/mcp/__tests__/tools.test.ts
  - src/mcp/__tests__/token-budget.test.ts
autonomous: true

must_haves:
  truths:
    - "Claude Code can discover and call all MCP tools via .mcp.json plugin manifest"
    - "save_memory persists text with auto-generated or user-provided title"
    - "recall search returns keyword-ranked results under 2000 token budget"
    - "recall purge soft-deletes a memory (disappears from search, recoverable)"
    - "recall restore un-deletes a previously purged memory"
    - "recall view shows 3 levels of progressive disclosure"
    - "All 5 phase success criteria are provable via automated tests"
  artifacts:
    - path: ".mcp.json"
      provides: "Claude Code plugin manifest for MCP server discovery"
      contains: "laminark"
    - path: "src/mcp/__tests__/tools.test.ts"
      provides: "Integration tests proving all Phase 2 success criteria"
    - path: "src/mcp/__tests__/token-budget.test.ts"
      provides: "Unit tests for token estimation and budget enforcement"
  key_links:
    - from: ".mcp.json"
      to: "src/index.ts"
      via: "npx tsx src/index.ts command"
      pattern: "tsx.*src/index.ts"
    - from: "src/mcp/__tests__/tools.test.ts"
      to: "src/mcp/tools/save-memory.ts"
      via: "Direct function calls testing save_memory behavior"
      pattern: "registerSaveMemory|save_memory"
    - from: "src/mcp/__tests__/tools.test.ts"
      to: "src/mcp/tools/recall.ts"
      via: "Direct function calls testing recall behavior"
      pattern: "registerRecall|recall"
---

<objective>
Plugin manifest for Claude Code integration and comprehensive test suite proving all Phase 2 success criteria.

Purpose: The .mcp.json manifest makes the tools discoverable by Claude Code. The test suite provides automated verification that all 5 success criteria are met: keyword search returns ranked results, save_memory persists with title, purge hides from search (recoverable), progressive disclosure respects token budget, and all tools are callable.

Output: Working .mcp.json plugin configuration and test suite covering all tool behaviors.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-mcp-interface-and-search/02-CONTEXT.md
@.planning/phases/02-mcp-interface-and-search/02-RESEARCH.md
@.planning/phases/02-mcp-interface-and-search/02-01-SUMMARY.md
@.planning/phases/02-mcp-interface-and-search/02-02-SUMMARY.md
@src/mcp/server.ts
@src/mcp/tools/save-memory.ts
@src/mcp/tools/recall.ts
@src/mcp/token-budget.ts
@src/storage/observations.ts
@src/storage/search.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create .mcp.json plugin manifest</name>
  <files>
    .mcp.json
  </files>
  <action>
Create `.mcp.json` in project root with the Claude Code plugin manifest format.

Per 02-RESEARCH.md: Plugin .mcp.json uses server names as top-level keys (NOT wrapped in mcpServers).

```json
{
  "laminark": {
    "command": "npx",
    "args": ["tsx", "src/index.ts"],
    "env": {}
  }
}
```

This tells Claude Code to start the Laminark MCP server using `npx tsx src/index.ts` which runs the TypeScript source directly via tsx (already a devDependency).

NOTE: For production distribution, this would change to `node dist/index.js` after build. The tsx approach is correct for development and local plugin usage.
  </action>
  <verify>
    File .mcp.json exists at project root.
    JSON is valid (parseable).
    Contains "laminark" key with command "npx" and args ["tsx", "src/index.ts"].
  </verify>
  <done>
    .mcp.json exists at project root with correct plugin manifest format.
    Claude Code can discover and launch the Laminark MCP server.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration and unit tests proving Phase 2 success criteria</name>
  <files>
    src/mcp/__tests__/tools.test.ts
    src/mcp/__tests__/token-budget.test.ts
  </files>
  <action>
Create two test files covering all Phase 2 success criteria.

1. Create `src/mcp/__tests__/token-budget.test.ts`:
   Unit tests for the token budget utility:
   - estimateTokens returns ceil(length/4) for various string lengths
   - enforceTokenBudget returns all items when under budget
   - enforceTokenBudget truncates when over budget (returns truncated: true)
   - enforceTokenBudget always includes at least 1 item even if it exceeds budget
   - enforceTokenBudget respects custom budget parameter
   - Metadata reserve (100 tokens) is subtracted from available budget

2. Create `src/mcp/__tests__/tools.test.ts`:
   Integration tests that exercise save_memory and recall tool logic through the storage layer (NOT through MCP protocol -- test the tool handler functions directly or test via repository layer).

   Use the same test database pattern from Phase 1 tests: create temp database, open with openDatabase(), create repositories.

   **Test group: save_memory (SC-2)**
   - "saves memory with user-provided title" -- create observation with title, verify title is stored
   - "auto-generates title from content when title omitted" -- test generateTitle() helper:
     - Short text (< 80 chars): title = full text
     - Text with first sentence: title = first sentence
     - Long text: title = first 80 chars + "..."
   - "saves memory and returns observation ID" -- verify observation is retrievable after save

   **Test group: recall search (SC-1)**
   - "keyword search returns BM25-ranked results" -- insert 3 observations with different content, search for a keyword, verify results ordered by relevance
   - "search by ID returns single observation" -- create observation, recall by ID, verify match
   - "search by title returns matching observations" -- create observations with titles, search by title substring
   - "empty search query returns recent observations" -- verify fallback to list

   **Test group: recall purge/restore (SC-3)**
   - "purge soft-deletes a memory" -- create observation, purge by ID, verify it disappears from normal search
   - "purged memory is recoverable via restore" -- purge, then restore, verify it reappears in search
   - "purge requires explicit IDs" -- verify error when ids array is empty
   - "include_purged flag shows soft-deleted items" -- purge an observation, search with include_purged=true, verify it appears

   **Test group: progressive disclosure and token budget (SC-4)**
   - "compact view returns id, title, snippet, score, date" -- verify compact format fields
   - "full view returns complete observation text" -- verify full content
   - "search results respect 2000 token budget" -- insert many observations, search, verify response token estimate <= 2000
   - "large result sets are truncated with notice" -- insert enough observations to exceed budget, verify truncated flag

   **Test group: tool discoverability (SC-5)**
   - "MCP server registers save_memory and recall tools" -- create server, verify both tools are registered (check server internals or registered tool count)

   For each test:
   - Use Vitest describe/it/expect
   - Create fresh temp database in beforeEach (use mkdtemp pattern from Phase 1 tests)
   - Close database in afterEach
   - Import directly from source modules (not through compiled dist)

IMPORTANT: Test the business logic, not the MCP protocol wire format. Do not try to simulate JSON-RPC stdin/stdout. Test the functions that tool handlers call.
  </action>
  <verify>
    Run `npm test` and verify ALL tests pass (existing 78+ plus new tests).
    Verify test coverage maps to all 5 Phase 2 success criteria:
      SC-1: keyword search with ranked results
      SC-2: save_memory with title
      SC-3: purge/restore (soft-delete + recovery)
      SC-4: progressive disclosure + token budget
      SC-5: tool discoverability
  </verify>
  <done>
    Token budget unit tests pass (6+ tests).
    Tool integration tests pass (15+ tests) covering all 5 Phase 2 success criteria.
    .mcp.json plugin manifest exists and is valid.
    Total test count is 78 (existing) + 20+ (new) = 98+ tests passing.
  </done>
</task>

</tasks>

<verification>
- `npm test` passes with all tests (existing + new)
- .mcp.json is valid JSON with correct plugin format
- Each Phase 2 success criterion has at least one test proving it:
  1. Keyword search returns ranked results (SC-1)
  2. save_memory persists with title (SC-2)
  3. Purge soft-deletes, recoverable via restore (SC-3)
  4. Progressive disclosure + token budget (SC-4)
  5. Tools are discoverable (SC-5)
- No console.log in any src/mcp/ file
</verification>

<success_criteria>
- .mcp.json exists at project root, Claude Code can discover tools
- 20+ new tests pass covering all Phase 2 success criteria
- All existing 78+ tests continue to pass (no regressions)
- Complete Phase 2: MCP server with 2 tools (save_memory + recall), keyword search, progressive disclosure, token budgets, purge/restore
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-interface-and-search/02-03-SUMMARY.md`
</output>
