---
phase: 02-mcp-interface-and-search
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/mcp/tools/timeline.ts
  - src/mcp/token-budget.ts
  - src/mcp/server.ts
autonomous: true

must_haves:
  truths:
    - "Claude can call timeline tool to see chronological observations around a time anchor"
    - "Search results never exceed 2000 tokens in the MCP response"
    - "Progressive disclosure works: compact index is small, timeline adds context, get_observations provides full detail"
  artifacts:
    - path: "src/mcp/tools/timeline.ts"
      provides: "MCP timeline tool showing chronological observation context"
      exports: ["registerTimelineTool"]
    - path: "src/mcp/token-budget.ts"
      provides: "Token estimation and budget enforcement utility"
      exports: ["estimateTokens", "enforceTokenBudget", "TOKEN_BUDGET"]
  key_links:
    - from: "src/mcp/tools/timeline.ts"
      to: "src/storage/"
      via: "queries observations ordered by created_at with time window filtering"
      pattern: "ORDER BY.*created_at"
    - from: "src/mcp/token-budget.ts"
      to: "src/mcp/tools/"
      via: "imported by search and timeline tools to enforce 2000 token limit"
      pattern: "enforceTokenBudget|TOKEN_BUDGET"
    - from: "src/mcp/tools/timeline.ts"
      to: "src/mcp/token-budget.ts"
      via: "imports token budget enforcement"
      pattern: "import.*token-budget"
---

<objective>
Implement the timeline tool and token budget enforcement layer that ensures MCP responses stay under 2000 tokens.

Purpose: The timeline tool is the second layer of progressive disclosure -- it shows chronological context around a time anchor (complementing search's ranked results). The token budget utility is critical for SRC-06 (preventing context window poisoning). Together they complete the 3-layer progressive disclosure pattern: search (compact index) -> timeline (chronological context) -> get_observations (full details).

Output: Working timeline tool and a reusable token budget module that caps all MCP tool responses at 2000 tokens.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/ARCHITECTURE.md
@.planning/research/FEATURES.md
@.planning/phases/02-mcp-interface-and-search/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement timeline tool with chronological observation context</name>
  <files>
    src/mcp/tools/timeline.ts
    src/mcp/server.ts
  </files>
  <action>
Create src/mcp/tools/timeline.ts:

Tool name: "timeline"
Description: "View observations in chronological order around a time anchor. Shows what happened before and after a specific point in time, useful for understanding the sequence of events. Returns a timeline view with observation summaries."

Zod input schema:
- anchor: z.string().datetime().optional().describe("ISO datetime to center the timeline on. Defaults to now.")
- before: z.number().int().min(1).max(20).default(5).describe("Number of observations to show before the anchor")
- after: z.number().int().min(0).max(20).default(5).describe("Number of observations to show after the anchor")
- sessionId: z.string().optional().describe("Filter to a specific session")
- projectId: z.string().optional().describe("Project scope (defaults to current)")

Handler implementation:
1. If no anchor provided, use current datetime.
2. Query observations BEFORE anchor:
   ```sql
   SELECT id, text, source, created_at, session_id
   FROM observations
   WHERE project_id = ? AND deleted_at IS NULL AND created_at <= ?
   ORDER BY created_at DESC
   LIMIT ?
   ```
   (Add session_id filter if provided)
3. Query observations AFTER anchor:
   ```sql
   SELECT id, text, source, created_at, session_id
   FROM observations
   WHERE project_id = ? AND deleted_at IS NULL AND created_at > ?
   ORDER BY created_at ASC
   LIMIT ?
   ```
4. Combine results in chronological order (reverse the "before" results, then append "after" results).
5. Format each entry as a TimelineEntry: { id, text (truncated to 200 chars), source, createdAt, sessionId }.
6. Include metadata: { anchor, totalBefore (actual count), totalAfter (actual count), hasMore: boolean }.
7. Return as JSON in ToolResponse.

Register timeline tool in server.ts alongside existing tools.
  </action>
  <verify>
Run: npx tsc --noEmit (no type errors)
Save 5+ observations with different timestamps. Call timeline with an anchor in the middle. Verify results are chronologically ordered and include observations from both sides of the anchor.
  </verify>
  <done>
Timeline tool returns chronological observations around a time anchor. Supports before/after counts, session filtering, and project scoping. Results include truncated text summaries and metadata about pagination.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement token budget enforcement for all MCP tool responses</name>
  <files>
    src/mcp/token-budget.ts
    src/mcp/tools/search.ts
    src/mcp/tools/timeline.ts
  </files>
  <action>
Create src/mcp/token-budget.ts:

Export constant TOKEN_BUDGET = 2000 (maximum tokens per MCP response).

Export function estimateTokens(text: string): number
- Use a simple heuristic: ~4 characters per token for English text (standard GPT-family approximation).
- Formula: Math.ceil(text.length / 4)
- This is intentionally conservative (overestimates) to stay safely under budget.
- Do NOT use a tokenizer library -- the heuristic is sufficient and avoids dependency overhead.

Export function enforceTokenBudget(results: any[], formatResult: (item: any) => string, budget: number = TOKEN_BUDGET): { items: any[], truncated: boolean, tokenEstimate: number }
- Iterates through results, formatting each with formatResult().
- Accumulates token estimates.
- Stops adding results when the next item would exceed the budget (reserve ~50 tokens for response metadata/framing).
- Returns: { items (those that fit), truncated (boolean, true if some were cut), tokenEstimate (actual estimate of returned items) }.

Integrate into search tool (src/mcp/tools/search.ts):
- After FTS5 query returns results, pass them through enforceTokenBudget().
- Use a formatResult function that produces the compact index line for each result (id, score, snippet).
- If truncated, append a note to the response: "Showing {N} of {total} results. Use a more specific query or reduce limit to see different results."
- Update the tokenEstimate field in CompactIndex to use the actual estimate from enforceTokenBudget().

Integrate into timeline tool (src/mcp/tools/timeline.ts):
- After combining before/after results, pass through enforceTokenBudget().
- Use a formatResult function that produces the timeline entry text.
- If truncated, include in metadata: truncated: true, message about using narrower time window.

Important: The 2000 token budget is for the ENTIRE tool response including framing JSON, not just the result list. Reserve ~100 tokens for response envelope (JSON structure, metadata fields). So the effective content budget is ~1900 tokens.
  </action>
  <verify>
Run: npx tsc --noEmit (no type errors)
Test: Create a large set of observations (20+), run search with limit 20. Verify the response token estimate stays under 2000 and the response indicates truncation if applicable.
Test: Call estimateTokens with a known string length and verify the estimate is reasonable (~length/4).
Test: Call enforceTokenBudget with items that would exceed budget, verify it truncates correctly.
  </verify>
  <done>
Token budget enforcement module exists with estimateTokens() and enforceTokenBudget() functions. Search and timeline tools integrate the budget enforcement. No MCP tool response exceeds 2000 estimated tokens. Truncation is clearly communicated to Claude with actionable guidance.
  </done>
</task>

</tasks>

<verification>
- Timeline tool registered and callable, returns chronological observations
- Timeline supports anchor datetime, before/after counts, session filter
- estimateTokens() returns reasonable estimates (~4 chars/token)
- enforceTokenBudget() truncates results that would exceed TOKEN_BUDGET (2000)
- Search tool responses stay under 2000 tokens (verified with 20+ observations)
- Timeline tool responses stay under 2000 tokens
- Truncation is clearly communicated in response text
- Both tools import from shared token-budget.ts (no duplicated logic)
</verification>

<success_criteria>
Timeline tool works as the second layer of progressive disclosure. Token budget enforcement is integrated into search and timeline tools. No MCP response exceeds 2000 estimated tokens. The 3-layer progressive disclosure pattern is complete: search (compact index, ~80 tokens/result) -> timeline (chronological context, ~120 tokens/entry) -> get_observations (full details, limited to 10 IDs per call).
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-interface-and-search/02-03-SUMMARY.md`
</output>
