---
phase: 02-mcp-interface-and-search
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - .mcp.json
  - .claude-plugin/plugin.json
autonomous: false

must_haves:
  truths:
    - "All 5 MCP tools are discoverable and callable from Claude Code"
    - "Plugin manifest correctly configures MCP server with stdio transport"
    - "Claude Code can start the MCP server as a child process and list available tools"
  artifacts:
    - path: ".mcp.json"
      provides: "MCP server configuration for Claude Code integration"
      contains: "memorite"
    - path: ".claude-plugin/plugin.json"
      provides: "Claude Code plugin manifest"
      contains: "memorite"
  key_links:
    - from: ".mcp.json"
      to: "src/index.ts"
      via: "command field points to the entry point that starts the MCP server"
      pattern: "src/index\\.ts|dist/index\\.js"
    - from: ".claude-plugin/plugin.json"
      to: ".mcp.json"
      via: "plugin manifest references MCP configuration"
      pattern: "mcp"
---

<objective>
Create the plugin manifest files and verify end-to-end Claude Code integration with all 5 MCP tools.

Purpose: This is the integration layer that makes Memorite discoverable by Claude Code. Without the plugin manifest and MCP config, the tools exist but Claude cannot find or call them. This plan also includes a human verification checkpoint to confirm the tools work in the actual Claude Code environment.

Output: Plugin manifest (.claude-plugin/plugin.json), MCP config (.mcp.json), and verified integration with Claude Code.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
@.planning/phases/02-mcp-interface-and-search/02-01-SUMMARY.md
@.planning/phases/02-mcp-interface-and-search/02-02-SUMMARY.md
@.planning/phases/02-mcp-interface-and-search/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create plugin manifest and MCP configuration</name>
  <files>
    .claude-plugin/plugin.json
    .mcp.json
  </files>
  <action>
Create .claude-plugin/plugin.json (Claude Code plugin manifest):
```json
{
  "name": "memorite",
  "version": "0.1.0",
  "description": "Persistent adaptive memory for Claude Code. Stores, searches, and manages observations across sessions.",
  "author": "matthew"
}
```

Create .mcp.json (MCP server configuration for Claude Code):
```json
{
  "mcpServers": {
    "memorite": {
      "command": "node",
      "args": ["--loader", "ts-node/esm", "src/index.ts"],
      "env": {
        "MEMORITE_PROJECT_ID": "${workspaceFolder}"
      }
    }
  }
}
```

Notes on the .mcp.json:
- The command starts the MCP server via ts-node for development. For production, this would point to the compiled dist/index.js.
- If tsdown build is configured in Phase 1, consider using "node dist/index.js" instead and ensure the build step runs first.
- The env section passes the workspace folder as the project ID for observation scoping.
- Claude Code reads .mcp.json from the project root to discover MCP servers.

If ts-node is not a dependency, add it: npm install -D ts-node. Alternatively, use tsx (npm install -D tsx) and change the args to ["--import", "tsx", "src/index.ts"] which handles ESM TypeScript natively.

Verify the manifest structure matches Claude Code's expected format by checking the research documentation. The plugin.json goes in .claude-plugin/ directory. The .mcp.json goes in the project root.
  </action>
  <verify>
Files exist at correct paths: .claude-plugin/plugin.json and .mcp.json
JSON is valid (no syntax errors): node -e "JSON.parse(require('fs').readFileSync('.mcp.json','utf8'))"
The command in .mcp.json actually starts the MCP server: run the command manually and verify it does not crash.
  </verify>
  <done>
Plugin manifest and MCP configuration files exist. Claude Code can discover the memorite MCP server via .mcp.json. The command correctly starts the MCP server via stdio transport.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify Claude Code integration with all MCP tools</name>
  <files>
    .mcp.json
    .claude-plugin/plugin.json
  </files>
  <action>
Human verification of the complete MCP interface. All automation is done -- this checkpoint confirms the 5 tools (search, save_memory, forget, timeline, get_observations) work end-to-end in the actual Claude Code environment. The user opens Claude Code in the Memorite project and tests each tool through natural conversation.
  </action>
  <verify>
1. Open Claude Code in the Memorite project directory.
2. Claude should auto-discover the memorite MCP server from .mcp.json.
3. Test each tool:
   a. Ask Claude to save a memory: "Remember that we decided to use BM25 ranking for search"
      - Expected: Claude calls save_memory, confirms the memory was saved with an ID
   b. Ask Claude to search: "Search my memories for ranking"
      - Expected: Claude calls search, returns compact index with the saved memory
   c. Ask Claude to get full details: "Show me the full details of that memory"
      - Expected: Claude calls get_observations with the ID, returns full text
   d. Ask Claude about timeline: "Show me the timeline of recent observations"
      - Expected: Claude calls timeline, returns chronological list
   e. Ask Claude to forget: "Forget that memory about BM25"
      - Expected: Claude calls forget, confirms soft-delete
   f. Search again: "Search for BM25"
      - Expected: No results (the forgotten memory is excluded)
4. Verify no tool response appears excessively long (token budget enforcement).
5. Verify errors are handled gracefully (e.g., forget with invalid ID returns error, not crash).
  </verify>
  <done>
All 5 MCP tools are discoverable and callable from Claude Code. End-to-end flow works: save -> search -> get details -> forget -> search confirms deletion. Token budgets are respected. User has approved the integration.
  </done>
</task>

</tasks>

<verification>
- .claude-plugin/plugin.json exists with valid JSON and correct plugin metadata
- .mcp.json exists with valid JSON, correct command to start MCP server
- MCP server starts successfully when invoked by the .mcp.json command
- All 5 tools are listed when Claude Code discovers the server
- Each tool accepts valid input and returns expected output
- Token budget enforcement keeps responses under 2000 tokens
- Soft-deleted observations are excluded from search and get_observations
- Error handling is graceful across all tools
</verification>

<success_criteria>
Claude Code discovers and connects to the Memorite MCP server. All 5 tools (search, save_memory, forget, timeline, get_observations) are callable from Claude Code. The end-to-end flow works: save -> search -> get details -> forget -> search confirms deletion. Token budgets are respected. Phase 2 success criteria are fully met.
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-interface-and-search/02-04-SUMMARY.md`
</output>
