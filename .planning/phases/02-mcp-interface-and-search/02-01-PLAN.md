---
phase: 02-mcp-interface-and-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/migrations.ts
  - src/storage/observations.ts
  - src/shared/types.ts
  - src/mcp/server.ts
  - src/mcp/tools/save-memory.ts
  - src/mcp/token-budget.ts
  - src/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "save_memory tool persists user-provided text as a new observation with optional title"
    - "Auto-generated title is derived from content when caller omits title parameter"
    - "MCP server starts on stdio transport and responds to tool listing requests"
    - "Title column exists in observations table and is indexed by FTS5 alongside content"
  artifacts:
    - path: "src/storage/migrations.ts"
      provides: "Migration 005: title column + FTS5 rebuild with title+content dual-column indexing"
      contains: "add_observation_title"
    - path: "src/mcp/server.ts"
      provides: "MCP server lifecycle: createServer() and startServer() with stdio transport"
      exports: ["createServer", "startServer"]
    - path: "src/mcp/tools/save-memory.ts"
      provides: "save_memory tool registration with auto-title generation"
      exports: ["registerSaveMemory", "generateTitle"]
    - path: "src/mcp/token-budget.ts"
      provides: "Token estimation and budget enforcement utility"
      exports: ["estimateTokens", "enforceTokenBudget", "TOKEN_BUDGET", "FULL_VIEW_BUDGET"]
    - path: "src/index.ts"
      provides: "MCP server entry point: opens DB, registers tools, connects stdio transport"
  key_links:
    - from: "src/mcp/tools/save-memory.ts"
      to: "src/storage/observations.ts"
      via: "ObservationRepository.create() to persist observation"
      pattern: "repo\\.create"
    - from: "src/index.ts"
      to: "src/mcp/server.ts"
      via: "createServer + startServer orchestration"
      pattern: "createServer|startServer"
    - from: "src/storage/migrations.ts"
      to: "observations table"
      via: "Migration 005 ALTER TABLE + FTS5 rebuild"
      pattern: "ALTER TABLE observations ADD COLUMN title"
---

<objective>
Add the title column to the observations schema, scaffold the MCP server with stdio transport, build the save_memory tool with auto-title generation, and create the token budget utility.

Purpose: Establishes the MCP server foundation and the first user-facing tool. The save_memory tool validates the full MCP stack end-to-end: SDK initialization, tool registration via registerTool(), database interaction through Phase 1 repositories, and stdio transport. The title column migration is prerequisite for save_memory's optional title parameter (locked user decision).

Output: A working MCP server that starts on stdio, registers save_memory, persists observations with auto-generated or user-provided titles, and stays within token budgets.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-mcp-interface-and-search/02-CONTEXT.md
@.planning/phases/02-mcp-interface-and-search/02-RESEARCH.md
@.planning/phases/01-storage-engine/01-02-SUMMARY.md
@.planning/phases/01-storage-engine/01-03-SUMMARY.md
@src/storage/migrations.ts
@src/storage/observations.ts
@src/storage/search.ts
@src/shared/types.ts
@src/shared/config.ts
@src/shared/debug.ts
@src/index.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema migration 005 for title column and type updates</name>
  <files>
    src/storage/migrations.ts
    src/shared/types.ts
    src/storage/observations.ts
    src/mcp/token-budget.ts
    package.json
  </files>
  <action>
**Step 1: Install MCP SDK**

Run `npm install @modelcontextprotocol/sdk` to add the dependency. Verify it appears in package.json dependencies.

**Step 2: Add migration 005 to `src/storage/migrations.ts`**

Append a new migration object to the MIGRATIONS array:

```typescript
{
  version: 5,
  name: 'add_observation_title',
  up: `
    ALTER TABLE observations ADD COLUMN title TEXT;

    DROP TRIGGER observations_ai;
    DROP TRIGGER observations_au;
    DROP TRIGGER observations_ad;
    DROP TABLE observations_fts;

    CREATE VIRTUAL TABLE observations_fts USING fts5(
      title,
      content,
      content='observations',
      content_rowid='rowid',
      tokenize='porter unicode61'
    );

    CREATE TRIGGER observations_ai AFTER INSERT ON observations BEGIN
      INSERT INTO observations_fts(rowid, title, content)
        VALUES (new.rowid, new.title, new.content);
    END;

    CREATE TRIGGER observations_au AFTER UPDATE ON observations BEGIN
      INSERT INTO observations_fts(observations_fts, rowid, title, content)
        VALUES('delete', old.rowid, old.title, old.content);
      INSERT INTO observations_fts(rowid, title, content)
        VALUES (new.rowid, new.title, new.content);
    END;

    CREATE TRIGGER observations_ad AFTER DELETE ON observations BEGIN
      INSERT INTO observations_fts(observations_fts, rowid, title, content)
        VALUES('delete', old.rowid, old.title, old.content);
    END;

    INSERT INTO observations_fts(observations_fts) VALUES('rebuild');
  `,
}
```

This migration is unconditional (no hasVectorSupport check needed). The FTS5 table now indexes BOTH title and content columns. The rebuild at the end re-indexes all existing rows (which will have NULL title -- that is fine, FTS5 handles NULL gracefully).

**Step 3: Update types in `src/shared/types.ts`**

1. Add `title: z.string().nullable()` to ObservationRowSchema (place it after the `content` field)
2. Add `title: string | null` to the Observation interface (after `content`)
3. Add `title: z.string().max(200).nullable().default(null)` to ObservationInsertSchema (after `content`)
4. Update `rowToObservation()` to include `title: row.title` in the returned object

**Step 4: Update ObservationRepository in `src/storage/observations.ts`**

The existing `stmtInsert` prepared statement in the constructor lists columns explicitly. Update it to include `title`:

```sql
INSERT INTO observations (id, project_hash, content, title, source, session_id, embedding, embedding_model, embedding_version)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
```

Update the `create()` method to pass `validated.title` as the 4th parameter (after content, before source) in the `stmtInsert.run()` call.

No other methods need changes -- `getById` uses `SELECT *` so it already returns the title column, and `rowToObservation()` (updated in Step 3) handles the mapping.

**Step 5: Create `src/mcp/token-budget.ts`**

Create the directory `src/mcp/` if it does not exist. Create the token budget utility:

```typescript
export const TOKEN_BUDGET = 2000;
export const FULL_VIEW_BUDGET = 4000;

export function estimateTokens(text: string): number {
  return Math.ceil(text.length / 4);
}

export function enforceTokenBudget<T>(
  results: T[],
  formatResult: (item: T) => string,
  budget: number = TOKEN_BUDGET,
): { items: T[]; truncated: boolean; tokenEstimate: number } {
  const METADATA_RESERVE = 100;
  const effectiveBudget = budget - METADATA_RESERVE;
  let totalTokens = 0;
  const items: T[] = [];

  for (const result of results) {
    const formatted = formatResult(result);
    const tokens = estimateTokens(formatted);
    if (totalTokens + tokens > effectiveBudget && items.length > 0) {
      return { items, truncated: true, tokenEstimate: totalTokens };
    }
    items.push(result);
    totalTokens += tokens;
  }

  return { items, truncated: false, tokenEstimate: totalTokens };
}
```

IMPORTANT: No console.log anywhere. All logging uses debug() from src/shared/debug.ts which writes to stderr.
  </action>
  <verify>
Run `npm run check` -- TypeScript compiles with no errors.
Run `npm test` -- all existing 78 tests pass (migration 005 is backward-compatible: title defaults to NULL, existing inserts still work since the INSERT statement is updated to include the column with a null default).
Verify migration version 5 exists in MIGRATIONS array.
Verify ObservationInsertSchema has a title field with z.string().max(200).nullable().
  </verify>
  <done>
Migration 005 adds title column to observations and rebuilds FTS5 with title+content dual-column indexing. ObservationRow, Observation, and ObservationInsert types all include title. ObservationRepository.create() accepts and persists title. Token budget utility exports estimateTokens, enforceTokenBudget, TOKEN_BUDGET, FULL_VIEW_BUDGET. @modelcontextprotocol/sdk installed. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: MCP server scaffold and save_memory tool</name>
  <files>
    src/mcp/server.ts
    src/mcp/tools/save-memory.ts
    src/index.ts
  </files>
  <action>
**Step 1: Create `src/mcp/server.ts`**

Import McpServer from `@modelcontextprotocol/sdk/server/mcp.js` and StdioServerTransport from `@modelcontextprotocol/sdk/server/stdio.js`.

Export two functions:

`createServer()` -- no parameters, returns McpServer:
```typescript
export function createServer(): McpServer {
  return new McpServer(
    { name: 'laminark', version: '0.1.0' },
    { capabilities: { tools: {} } }
  );
}
```

`startServer(server: McpServer)` -- connects server to stdio transport:
```typescript
export async function startServer(server: McpServer): Promise<void> {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  debug('mcp', 'MCP server started on stdio transport');
}
```

The separation lets callers create the server, register tools, then start transport. This is cleaner than embedding tool registration inside server creation.

**Step 2: Create `src/mcp/tools/save-memory.ts`**

Create directory `src/mcp/tools/` if it does not exist.

Export `generateTitle(content: string): string` helper:
```typescript
export function generateTitle(content: string): string {
  const firstSentence = content.match(/^[^.!?\n]+[.!?]?/);
  if (firstSentence && firstSentence[0].length <= 100) {
    return firstSentence[0].trim();
  }
  if (content.length <= 80) return content.trim();
  return content.slice(0, 80).trim() + '...';
}
```

Export `registerSaveMemory(server: McpServer, db: BetterSqlite3.Database, projectHash: string)`:

Use `server.registerTool()` (NOT the deprecated `server.tool()`):
- **Name:** `save_memory`
- **Config:**
  - title: `'Save Memory'`
  - description: `'Save a new memory observation. Provide text content and an optional title. If title is omitted, one is auto-generated from the text.'`
  - inputSchema (Zod):
    - `text`: `z.string().min(1).max(10000).describe('The text content to save as a memory')`
    - `title`: `z.string().max(200).optional().describe('Optional title for the memory. Auto-generated from text if omitted.')`
    - `source`: `z.string().default('manual').describe('Source identifier (e.g., manual, hook:PostToolUse)')`
- **Callback (async):**
  1. Instantiate `ObservationRepository(db, projectHash)` -- note: creating a new instance per call is fine since constructor is cheap (just prepares statements, which better-sqlite3 caches)
  2. Determine title: `args.title ?? generateTitle(args.text)`
  3. Call `repo.create({ content: args.text, title: resolvedTitle, source: args.source })`
  4. Log via `debug('mcp', 'save_memory: saved', { id: obs.id, title: resolvedTitle })`
  5. Return success: `{ content: [{ type: 'text', text: \`Saved memory "${resolvedTitle}" (id: ${obs.id})\` }] }`
  6. Wrap in try/catch -- on error return: `{ content: [{ type: 'text', text: \`Failed to save: ${err.message}\` }], isError: true }`

**Step 3: Update `src/index.ts`**

Replace the current placeholder content. The file must:
1. Keep the `#!/usr/bin/env node` shebang
2. Import and re-export storage API for library consumers: `export * from './storage/index.js'`
3. Import `openDatabase`, `getDatabaseConfig`, `getProjectHash` from storage
4. Import `debug` from shared/debug
5. Import `createServer`, `startServer` from mcp/server
6. Import `registerSaveMemory` from mcp/tools/save-memory

Main startup sequence:
```typescript
const db = openDatabase(getDatabaseConfig());
const projectHash = getProjectHash(process.cwd());

const server = createServer();
registerSaveMemory(server, db.db, projectHash);
// registerRecall will be added in Plan 02-02

startServer(server).catch((err) => {
  debug('mcp', 'Fatal: failed to start server', { error: err.message });
  db.close();
  process.exit(1);
});

process.on('SIGINT', () => { db.close(); process.exit(0); });
process.on('SIGTERM', () => { db.close(); process.exit(0); });
process.on('uncaughtException', (err) => {
  debug('mcp', 'Uncaught exception', { error: err.message });
  db.close();
  process.exit(1);
});
```

CRITICAL: Never use `console.log()` anywhere in MCP server code. All logging MUST use `debug()` which writes to stderr. stdout is reserved exclusively for the MCP JSON-RPC protocol stream. Any stdout pollution will corrupt the protocol and crash the connection.

CRITICAL: better-sqlite3 calls are synchronous. The MCP tool handlers are async (required by SDK), but internally call sync db methods directly. Do NOT wrap sync calls in unnecessary Promise/await.
  </action>
  <verify>
Run `npm run check` -- TypeScript compiles with no errors (including MCP SDK types).
Run `npm run build` -- tsdown produces dist/index.js with shebang.
Run `npm test` -- all tests still pass.
Start the server manually: `timeout 2 npx tsx src/index.ts 2>/dev/null || true` -- should exit without errors (exits because stdin closes).
Run `grep -r "console.log" src/` to verify zero matches.
  </verify>
  <done>
MCP server starts via `npx tsx src/index.ts` on stdio transport with zero stdout pollution. save_memory tool is registered via registerTool() and accepts text, optional title, and source. Auto-title generation produces titles from content. src/index.ts is the unified entry point with graceful shutdown on SIGINT/SIGTERM/uncaughtException. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
- `npm run check` passes with no type errors
- `npm test` passes all existing tests (78+) -- migration 005 is backward-compatible
- `npm run build` succeeds producing dist/index.js
- `grep -r "console.log" src/` returns zero matches (no stdout pollution)
- Migration 005 in MIGRATIONS array includes ALTER TABLE, DROP/CREATE FTS5, 3 triggers, and rebuild
- ObservationInsert accepts optional title (z.string().max(200).nullable().default(null))
- save_memory registered with registerTool() (not deprecated tool())
- src/index.ts opens database, creates server, registers tool, starts stdio transport
</verification>

<success_criteria>
- Migration 005 adds title column and rebuilds FTS5 for dual-column (title+content) indexing
- MCP server initializes with McpServer + StdioServerTransport from @modelcontextprotocol/sdk
- save_memory tool accepts text, optional title, and source parameters via Zod schema
- Auto-title generates from first sentence or first 80 chars when title omitted
- Token budget utility (estimateTokens, enforceTokenBudget) ready for recall tool (Plan 02-02)
- All 78+ existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-interface-and-search/02-01-SUMMARY.md`
</output>
