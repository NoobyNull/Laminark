---
phase: 02-mcp-interface-and-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/index.ts
  - src/mcp/server.ts
  - src/mcp/tools/search.ts
  - src/shared/types.ts
autonomous: true

must_haves:
  truths:
    - "MCP server starts via stdio transport and responds to tool list requests"
    - "Claude can call search tool and receive BM25-ranked keyword results from stored observations"
    - "Search results return compact index format with id, score, and snippet per result"
  artifacts:
    - path: "src/mcp/server.ts"
      provides: "MCP server with stdio transport and tool registration"
      exports: ["createServer", "startServer"]
    - path: "src/mcp/tools/search.ts"
      provides: "FTS5 keyword search tool with BM25 ranking"
      exports: ["searchTool"]
    - path: "src/shared/types.ts"
      provides: "Shared TypeScript types for observations, search results, tool responses"
      exports: ["Observation", "SearchResult", "CompactIndex"]
    - path: "src/index.ts"
      provides: "Entry point that starts MCP server"
  key_links:
    - from: "src/index.ts"
      to: "src/mcp/server.ts"
      via: "imports and calls startServer()"
      pattern: "import.*from.*mcp/server"
    - from: "src/mcp/server.ts"
      to: "src/mcp/tools/search.ts"
      via: "registers search tool with server.tool()"
      pattern: "server\\.tool\\("
    - from: "src/mcp/tools/search.ts"
      to: "src/storage/"
      via: "calls Phase 1 storage layer for FTS5 queries"
      pattern: "fts5|observations_fts|bm25"
---

<objective>
Create the MCP server scaffold with stdio transport and implement the search tool with FTS5 keyword search and BM25 ranking.

Purpose: This is the foundation for all Phase 2 MCP tools. The server scaffold provides tool registration infrastructure, and the search tool is the most complex tool (FTS5 query construction, BM25 ranking, result formatting) that validates the entire MCP-to-storage pipeline.

Output: Working MCP server that starts via stdio, registers tools, and responds to search queries with BM25-ranked results in compact index format.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md

Phase 1 SUMMARY will exist by execution time -- reference it for storage layer API:
@.planning/phases/01-storage-engine/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP server scaffold with stdio transport and shared types</name>
  <files>
    src/shared/types.ts
    src/mcp/server.ts
    src/index.ts
    package.json
  </files>
  <action>
Install @modelcontextprotocol/sdk (^1.26) and zod (^4.3) as dependencies if not already present from Phase 1.

Create src/shared/types.ts with TypeScript interfaces:
- Observation: { id: string, text: string, source: string, sessionId: string, projectId: string, createdAt: string, updatedAt: string, deletedAt: string | null, embedding: Float32Array | null, modelVersion: string | null }
- SearchResult: { id: string, score: number, snippet: string, source: string, createdAt: string }
- CompactIndex: { results: SearchResult[], totalCount: number, query: string, tokenEstimate: number }
- TimelineEntry: { id: string, text: string, source: string, createdAt: string, sessionId: string }
- ToolResponse: { content: Array<{ type: "text", text: string }>, isError?: boolean }

Create src/mcp/server.ts:
- Import McpServer from @modelcontextprotocol/sdk/server/mcp.js
- Import StdioServerTransport from @modelcontextprotocol/sdk/server/stdio.js
- Export createServer() that creates a new McpServer with name "laminark" and version from package.json
- Export startServer(db) that: creates server via createServer(), registers all tools (accepting a db handle from Phase 1 storage layer), creates StdioServerTransport, calls server.connect(transport)
- Tool registration takes the form: server.tool(name, description, zodSchema, handler)
- For now, only register the search tool (other tools added in Plans 02/03)
- Handle errors gracefully -- if db is not available, tools should return error responses, not crash

Create src/index.ts:
- Import startServer from src/mcp/server.ts
- Import database initialization from Phase 1 storage layer (src/storage/database.ts)
- Initialize database connection, then call startServer(db)
- Add process error handlers for uncaughtException and unhandledRejection (log and exit cleanly)

Important: Use ESM imports throughout (import/export, not require). The MCP SDK v1.26 uses deep path imports like @modelcontextprotocol/sdk/server/mcp.js -- include the .js extension in imports.
  </action>
  <verify>
Run: npx tsc --noEmit (no type errors)
Run: node --loader ts-node/esm src/index.ts (starts without crash, or gracefully handles missing DB if Phase 1 not yet complete)
  </verify>
  <done>
MCP server scaffold exists with stdio transport. Types are defined. Entry point initializes database and starts server. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement search tool with FTS5 keyword search and BM25 ranking</name>
  <files>
    src/mcp/tools/search.ts
    src/mcp/server.ts
  </files>
  <action>
Create src/mcp/tools/search.ts:

Define the search tool registration function that takes a server instance and db handle:

Zod input schema:
- query: z.string().min(1).max(500).describe("Search query keywords")
- limit: z.number().int().min(1).max(20).default(10).describe("Maximum results to return")
- projectId: z.string().optional().describe("Scope search to specific project (defaults to current)")

Tool handler implementation:
1. Construct FTS5 MATCH query from input query string. Escape special FTS5 characters (^ * " OR AND NOT) in user input to prevent query injection.
2. Execute SQL query against the FTS5 virtual table (observations_fts) created in Phase 1:
   ```sql
   SELECT o.id, o.text, o.source, o.created_at, o.session_id,
          bm25(observations_fts) as score
   FROM observations_fts
   JOIN observations o ON observations_fts.rowid = o.rowid
   WHERE observations_fts MATCH ?
     AND o.project_id = ?
     AND o.deleted_at IS NULL
   ORDER BY bm25(observations_fts)
   LIMIT ?
   ```
3. Note: bm25() returns negative values (more negative = better match). Sort ascending.
4. Format results as CompactIndex: for each result, create a snippet by truncating text to first 100 characters with "..." suffix if truncated.
5. Calculate tokenEstimate as roughly (results.length * 80) for compact format -- each result is ~80 tokens (id, score, snippet, source, date).
6. Return the CompactIndex as a JSON string wrapped in ToolResponse content array.
7. If query returns no results, return a friendly message: "No observations found matching '{query}'."
8. Wrap entire handler in try/catch -- on error, return ToolResponse with isError: true and error message.

Register the search tool in server.ts by importing from tools/search.ts and calling the registration function during server setup.

Tool name: "search"
Tool description: "Search stored observations by keyword. Returns a compact index of matching results ranked by relevance (BM25). Use get_observations with specific IDs to retrieve full details."
  </action>
  <verify>
Run: npx tsc --noEmit (no type errors)
Write a quick test script that creates an in-memory MCP client, calls the search tool with a test query, and verifies the response shape matches CompactIndex. Alternatively, use the MCP inspector: npx @modelcontextprotocol/inspector node src/index.ts
  </verify>
  <done>
Search tool registered on MCP server. Accepts query string, executes FTS5 MATCH with BM25 ranking, returns CompactIndex with id/score/snippet/source/date per result. Results are scoped to project and exclude soft-deleted observations. Token estimate is calculated. Error cases handled gracefully.
  </done>
</task>

</tasks>

<verification>
- MCP server starts via stdio without errors
- `server.tool("search", ...)` is registered and callable
- Search tool accepts { query, limit?, projectId? } input
- Search results are BM25-ranked (most relevant first)
- Results exclude soft-deleted observations (deleted_at IS NOT NULL)
- Results are project-scoped
- CompactIndex format: { results: [...], totalCount, query, tokenEstimate }
- Each SearchResult has: id, score, snippet (<=100 chars), source, createdAt
- Error responses are graceful (ToolResponse with isError: true)
</verification>

<success_criteria>
TypeScript compiles cleanly. MCP server starts and responds to tool list. Search tool returns BM25-ranked results in compact index format. The foundation is ready for additional tools in Plans 02 and 03.
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-interface-and-search/02-01-SUMMARY.md`
</output>
