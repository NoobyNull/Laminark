---
phase: 04-embedding-engine-and-semantic-search
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/analysis/worker.ts
  - src/analysis/worker-bridge.ts
  - src/storage/embeddings.ts
  - tsdown.config.ts
autonomous: true

must_haves:
  truths:
    - "Embedding computation runs in a worker thread and never blocks the main MCP process"
    - "AnalysisWorker.embed() returns a Promise that resolves to Float32Array or null"
    - "EmbeddingStore inserts and queries vec0 table with cosine distance for project-scoped KNN search"
    - "Worker thread file is compiled as a separate entry point by tsdown"
  artifacts:
    - path: "src/analysis/worker.ts"
      provides: "Worker thread entry point that receives embed messages and runs the embedding engine"
      exports: []
    - path: "src/analysis/worker-bridge.ts"
      provides: "Main-thread API for sending embed requests to worker and receiving results"
      exports: ["AnalysisWorker"]
    - path: "src/storage/embeddings.ts"
      provides: "EmbeddingStore for sqlite-vec vec0 insert, KNN query, and project-scoped vector search"
      exports: ["EmbeddingStore"]
    - path: "tsdown.config.ts"
      provides: "Third entry point for worker.ts compilation"
      contains: "src/analysis/worker.ts"
  key_links:
    - from: "src/analysis/worker-bridge.ts"
      to: "src/analysis/worker.ts"
      via: "new Worker() with postMessage/onMessage for embed requests"
      pattern: "new Worker"
    - from: "src/analysis/worker.ts"
      to: "src/analysis/embedder.ts"
      via: "createEmbeddingEngine() called inside worker thread"
      pattern: "createEmbeddingEngine"
    - from: "src/storage/embeddings.ts"
      to: "observation_embeddings vec0 table"
      via: "prepared statements for INSERT and MATCH queries"
      pattern: "observation_embeddings"
---

<objective>
Build the worker thread bridge for non-blocking embedding generation and the EmbeddingStore for sqlite-vec vector operations.

Purpose: Embedding computation (10-30ms per text) must never block MCP tool responses (INT-04). The worker thread handles all inference while the main thread manages the database. The EmbeddingStore provides the data layer for vector insert/query against the cosine-distance vec0 table.

Output: Worker thread entry point, AnalysisWorker bridge class, EmbeddingStore, updated tsdown config.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-embedding-engine-and-semantic-search/04-RESEARCH.md
@.planning/phases/04-embedding-engine-and-semantic-search/04-01-SUMMARY.md
@src/analysis/embedder.ts
@src/storage/database.ts
@tsdown.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create worker thread entry point and main-thread bridge</name>
  <files>
    src/analysis/worker.ts
    src/analysis/worker-bridge.ts
    tsdown.config.ts
  </files>
  <action>
Create the worker thread infrastructure for off-main-thread embedding:

**src/analysis/worker.ts** -- Worker thread entry point:
- Import `parentPort` from `node:worker_threads`
- Import `createEmbeddingEngine` from `./embedder.js`
- On startup, call `createEmbeddingEngine()` and store the engine reference
- Listen for messages on `parentPort` with types:
  - `{ type: 'embed', id: string, text: string }` -- embed single text
  - `{ type: 'embed_batch', id: string, texts: string[] }` -- embed batch
  - `{ type: 'shutdown' }` -- clean exit
- For 'embed' messages:
  - Call `engine.embed(text)`
  - If result is null, respond: `{ type: 'embed_result', id, embedding: null }`
  - If result is Float32Array, respond with transfer: `parentPort.postMessage({ type: 'embed_result', id, embedding }, [embedding.buffer])` -- zero-copy transfer
- For 'embed_batch' messages:
  - Call `engine.embedBatch(texts)`
  - Respond: `{ type: 'embed_batch_result', id, embeddings }` (transfer all non-null buffers)
- For 'shutdown': call `process.exit(0)`
- Send `{ type: 'ready', engineName: engine.name(), dimensions: engine.dimensions() }` after engine creation
- Wrap the entire init in try/catch -- if engine creation fails, still send `ready` with `engineName: 'keyword-only'`

**src/analysis/worker-bridge.ts** -- Main-thread API:
- Class `AnalysisWorker` with:
  - Private `worker: Worker | null`
  - Private `pending: Map<string, { resolve, reject, timer }>` for request-ID tracking
  - Private `nextId: number` counter
  - Private `ready: boolean` and `engineName: string`
  - Constructor takes optional `workerPath?: string` (defaults to resolving `./worker.js` relative to `import.meta.url` using `new URL('./worker.js', import.meta.url)` -- works with tsdown output)
  - `start(): Promise<void>` -- creates `new Worker(workerPath)`, sets up message handler, waits for 'ready' message (with 30s timeout)
  - `embed(text: string): Promise<Float32Array | null>` -- sends 'embed' message with unique ID, returns Promise that resolves when response arrives. Timeout: 30 seconds per request. If worker not started or not ready, returns null.
  - `embedBatch(texts: string[]): Promise<(Float32Array | null)[]>` -- same pattern for batch
  - `shutdown(): Promise<void>` -- sends 'shutdown', awaits worker exit, clears pending map
  - `isReady(): boolean` -- returns this.ready
  - `getEngineName(): string` -- returns this.engineName
- Message handler dispatches by `msg.type`:
  - 'ready': set ready=true, engineName=msg.engineName, resolve the start() promise
  - 'embed_result': resolve pending promise with msg.embedding
  - 'embed_batch_result': resolve pending promise with msg.embeddings
- Timeout handling: if a pending request times out, resolve with null (not reject) -- graceful degradation
- Error handling: if worker errors or exits unexpectedly, resolve all pending with null, set ready=false

**tsdown.config.ts** -- Add worker entry point:
- Add `src/analysis/worker.ts` as a third entry point:
```typescript
entry: ['src/index.ts', 'src/hooks/handler.ts', 'src/analysis/worker.ts'],
```
This ensures the worker is compiled to `dist/analysis/worker.js` as a standalone file.

Note: tsdown with `entryFileNames: '[name].js'` and multiple entries in different directories should produce files in corresponding output paths. Verify after build that `dist/analysis/worker.js` exists. If tsdown flattens all entries to dist root (producing `dist/worker.js`), adjust the worker path resolution in AnalysisWorker accordingly.
  </action>
  <verify>
`npx tsc --noEmit` passes. `npx tsdown` builds successfully and produces a worker JS file (check `dist/` for the worker output). The worker file should be a standalone module that can be loaded by `new Worker()`.
  </verify>
  <done>Worker thread receives embed messages and responds with Float32Array via zero-copy transfer. AnalysisWorker bridge provides Promise-based embed()/embedBatch() API with request-ID tracking, timeouts, and graceful error handling. tsdown compiles worker as separate entry point.</done>
</task>

<task type="auto">
  <name>Task 2: Create EmbeddingStore for sqlite-vec operations</name>
  <files>
    src/storage/embeddings.ts
  </files>
  <action>
Create the EmbeddingStore class for sqlite-vec vec0 table operations:

**src/storage/embeddings.ts**:
- Class `EmbeddingStore` with constructor taking `db: BetterSqlite3.Database` and `projectHash: string`
- Constructor prepares statements (better-sqlite3 best practice):
  - `stmtInsert`: `INSERT OR REPLACE INTO observation_embeddings(observation_id, embedding) VALUES (?, ?)`
  - `stmtSearch`: KNN query with project-scoped filter (see below)
  - `stmtDelete`: `DELETE FROM observation_embeddings WHERE observation_id = ?`
  - `stmtExists`: `SELECT 1 FROM observation_embeddings WHERE observation_id = ?`

Methods:
- `store(observationId: string, embedding: Float32Array): void`
  - Runs stmtInsert with observationId and embedding (Float32Array passes directly to better-sqlite3 for vec0)
  - Uses INSERT OR REPLACE so re-embedding an observation overwrites the old vector

- `search(queryEmbedding: Float32Array, limit?: number): Array<{ observationId: string; distance: number }>`
  - Project-scoped KNN query (verified working in research):
    ```sql
    SELECT observation_id, distance
    FROM observation_embeddings
    WHERE embedding MATCH ?
      AND observation_id IN (
        SELECT id FROM observations WHERE project_hash = ? AND deleted_at IS NULL
      )
    ORDER BY distance
    LIMIT ?
    ```
  - Pass queryEmbedding as Float32Array directly (no Buffer conversion needed per research Finding 7)
  - Default limit: 20

- `delete(observationId: string): void`
  - Removes embedding for a deleted observation

- `has(observationId: string): boolean`
  - Checks if an observation has an embedding stored

- `findUnembedded(limit?: number): string[]`
  - Query: `SELECT id FROM observations WHERE project_hash = ? AND deleted_at IS NULL AND id NOT IN (SELECT observation_id FROM observation_embeddings) LIMIT ?`
  - Default limit: 50
  - Returns observation IDs that need embeddings generated

Wrap all methods in try/catch -- return empty results or swallow errors for graceful degradation. Use debug() logging for all operations.

Import debug from `../shared/debug.js`. Add a new debug category 'embed' for embedding operations.
  </action>
  <verify>
`npx tsc --noEmit` passes. Verify EmbeddingStore exports correctly and all methods are defined.
  </verify>
  <done>EmbeddingStore provides store(), search(), delete(), has(), findUnembedded() methods against the cosine-distance vec0 table. All operations are project-scoped via subquery. Float32Array passes directly to better-sqlite3 for vec0 operations.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm test` passes with all existing tests green
- `npx tsdown` builds successfully with three entry points producing worker output
- `src/analysis/worker.ts` handles embed/embed_batch/shutdown messages
- `src/analysis/worker-bridge.ts` exports AnalysisWorker with Promise-based embed API
- `src/storage/embeddings.ts` exports EmbeddingStore with store/search/delete/has/findUnembedded
</verification>

<success_criteria>
1. Worker thread infrastructure enables non-blocking embedding (INT-04)
2. AnalysisWorker bridge resolves all pending promises with null on error/timeout (DQ-03)
3. EmbeddingStore uses cosine-distance vec0 table with project-scoped KNN search
4. Float32Array transfers use zero-copy transfer list between worker and main thread
5. tsdown produces standalone worker.js alongside index.js and handler.js
</success_criteria>

<output>
After completion, create `.planning/phases/04-embedding-engine-and-semantic-search/04-02-SUMMARY.md`
</output>
