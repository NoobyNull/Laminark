---
phase: 04-embedding-engine-and-semantic-search
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/embeddings.ts
autonomous: true

must_haves:
  truths:
    - "sqlite-vec extension loads successfully via better-sqlite3 loadExtension()"
    - "Vector table stores observation ID mapped to 384-dimensional float32 vectors"
    - "Nearest-neighbor query returns observation IDs ranked by cosine similarity to a query vector"
    - "Vector operations work alongside existing FTS5 tables without conflict"
  artifacts:
    - path: "src/storage/embeddings.ts"
      provides: "Vector storage and similarity search using sqlite-vec"
      exports: ["EmbeddingStore"]
  key_links:
    - from: "src/storage/embeddings.ts"
      to: "better-sqlite3"
      via: "loadExtension for sqlite-vec, prepared statements for vector ops"
      pattern: "loadExtension|vec_distance_cosine|vec0"
    - from: "src/storage/embeddings.ts"
      to: "sqlite-vec"
      via: "npm package provides compiled extension path"
      pattern: "sqlite-vec"
---

<objective>
Integrate sqlite-vec for vector similarity search, creating the storage layer that maps observation IDs to embedding vectors and supports nearest-neighbor queries.

Purpose: This is the storage foundation for semantic search (SRC-02). Without vector storage, embeddings generated by Plan 01 have nowhere to persist. sqlite-vec provides in-process vector similarity without external services.

Output: EmbeddingStore class that handles sqlite-vec extension loading, vector table creation, vector insertion, and KNN similarity search.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/research/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Load sqlite-vec extension and create vector virtual table</name>
  <files>src/storage/embeddings.ts</files>
  <action>
Create `src/storage/embeddings.ts` with an `EmbeddingStore` class:

**Constructor:** Takes a `better-sqlite3` Database instance. Does NOT load the extension in the constructor -- provides an `initialize()` method instead.

**initialize(dimensions: number = 384):**
1. Load the sqlite-vec extension. Get the extension path from the `sqlite-vec` npm package:
   ```typescript
   import * as sqliteVec from "sqlite-vec";
   sqliteVec.load(db);
   ```
   If `sqlite-vec` package provides a `load(db)` helper, use it. Otherwise, use `db.loadExtension()` with the path from `require.resolve("sqlite-vec")` (check sqlite-vec docs for the Node.js API -- it may export `vectorExtensionPath` or similar).
2. Create the vector virtual table if it doesn't exist:
   ```sql
   CREATE VIRTUAL TABLE IF NOT EXISTS vec_observations USING vec0(
     observation_id TEXT PRIMARY KEY,
     embedding float[384]
   );
   ```
   Use the `dimensions` parameter for the array size (default 384 for BGE Small).
3. Wrap in try/catch. If extension loading fails, set `this.available = false` and log a warning. Return boolean success.

**isAvailable():** Returns whether sqlite-vec loaded successfully.

**storeEmbedding(observationId: string, embedding: Float32Array):**
- INSERT OR REPLACE into vec_observations with the observation ID and embedding vector
- sqlite-vec accepts Float32Array as a buffer for float[] columns
- Use a prepared statement for performance

**searchSimilar(queryEmbedding: Float32Array, limit: number = 20, projectId?: string): Array<{ observationId: string; distance: number }>**
- Query vec_observations using KNN:
  ```sql
  SELECT observation_id, distance
  FROM vec_observations
  WHERE embedding MATCH ?
  ORDER BY distance
  LIMIT ?
  ```
  The `MATCH` operator in sqlite-vec triggers KNN search. The query embedding is passed as a parameter.
- If projectId is provided, JOIN with the observations table to filter by project scope (important for SRC-05 project scoping)
- Return results sorted by ascending distance (closest = most similar)

**deleteEmbedding(observationId: string):**
- DELETE FROM vec_observations WHERE observation_id = ?

**Important notes:**
- sqlite-vec uses cosine distance by default with vec0 virtual tables. Verify this in the sqlite-vec docs -- if it defaults to L2, explicitly configure cosine.
- The Float32Array must be passed as a Buffer to better-sqlite3. Convert via `Buffer.from(embedding.buffer)`.
- All methods are synchronous (better-sqlite3 is sync). The async wrapper happens at the caller level.
  </action>
  <verify>
Write a test script that:
1. Creates an in-memory better-sqlite3 database
2. Instantiates EmbeddingStore and calls initialize()
3. Stores a test embedding (random Float32Array of length 384)
4. Queries for similar vectors and confirms the stored vector is returned
5. Deletes the embedding and confirms search returns empty

Run with `node --loader ts-node/esm test-script.ts` or equivalent. Also run `npx tsc --noEmit`.
  </verify>
  <done>EmbeddingStore loads sqlite-vec, creates vec0 virtual table, supports store/search/delete operations. searchSimilar returns observation IDs ranked by cosine similarity. Extension loading failure is handled gracefully (isAvailable returns false).</done>
</task>

<task type="auto">
  <name>Task 2: Add time-window pre-filtering for vector search scalability</name>
  <files>src/storage/embeddings.ts</files>
  <action>
Add a `searchSimilarFiltered()` method to EmbeddingStore that supports pre-filtering by time window before vector search. This addresses the scaling consideration from research: "sqlite-vec does brute-force KNN. Pre-filter by time window for large datasets (100K+)."

**searchSimilarFiltered(queryEmbedding: Float32Array, options: { limit?: number; projectId?: string; since?: Date; sessionId?: string }): Array<{ observationId: string; distance: number }>**

Strategy: Use a two-step approach:
1. First, get candidate observation IDs from the observations table filtered by project, time window, and/or session
2. Then, query vec_observations with the candidate set using an IN clause or temp table

For small datasets (<10K), this adds unnecessary overhead. Add logic:
- If no filters provided, delegate to `searchSimilar()` (full KNN)
- If filters provided, use a subquery or temp table approach:
  ```sql
  SELECT v.observation_id, v.distance
  FROM vec_observations v
  WHERE v.observation_id IN (
    SELECT id FROM observations
    WHERE project_id = ? AND created_at > ?
  )
  AND v.embedding MATCH ?
  ORDER BY v.distance
  LIMIT ?
  ```

Note: Check if sqlite-vec supports WHERE clauses combined with MATCH. If not, fall back to: fetch candidate IDs first, compute distances manually with `vec_distance_cosine()` scalar function, and sort in JS.

Also add a `getEmbeddingCount(): number` method that returns the total number of stored embeddings (useful for deciding whether to use filtered vs full search).
  </action>
  <verify>
Extend the test script from Task 1:
1. Store 100 embeddings with varied timestamps
2. Call searchSimilarFiltered with a time window that includes only 50 of them
3. Verify results only contain IDs from the filtered time range
4. Verify getEmbeddingCount() returns 100

Run `npx tsc --noEmit`.
  </verify>
  <done>searchSimilarFiltered supports time-window and session pre-filtering. getEmbeddingCount returns total stored vectors. Full KNN and filtered KNN both work correctly.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. sqlite-vec extension loads successfully from the npm package
3. Float32Array embeddings can be stored and retrieved via KNN search
4. Cosine similarity ranking returns nearest vectors first
5. Time-window filtering restricts search to relevant observations
6. Extension load failure sets isAvailable() to false without crashing
</verification>

<success_criteria>
- sqlite-vec loads as a SQLite extension via better-sqlite3
- vec0 virtual table created with 384-dimensional float columns
- KNN search returns observation IDs ranked by cosine similarity
- Pre-filtering by time window works for scalability
- Extension unavailability handled gracefully (isAvailable flag)
</success_criteria>

<output>
After completion, create `.planning/phases/04-embedding-engine-and-semantic-search/04-02-SUMMARY.md`
</output>
