---
phase: 04-embedding-engine-and-semantic-search
plan: 04
type: tdd
wave: 4
depends_on: ["04-03"]
files_modified:
  - src/analysis/__tests__/embedder.test.ts
  - src/search/__tests__/hybrid.test.ts
  - src/storage/__tests__/embeddings.test.ts
autonomous: true

must_haves:
  truths:
    - "Semantic search finds observations by concept even without exact keyword overlap"
    - "Hybrid search combines keyword and semantic scores for better ranking than either alone"
    - "Embedding generation never blocks the main thread"
    - "System silently falls back to keyword-only search when ONNX model is unavailable"
    - "Plugin startup completes with zero perceptible latency"
  artifacts:
    - path: "src/analysis/__tests__/embedder.test.ts"
      provides: "Tests for embedding engine interface, LocalOnnxEngine, KeywordOnlyEngine, and createEmbeddingEngine factory"
    - path: "src/search/__tests__/hybrid.test.ts"
      provides: "Tests for reciprocalRankFusion algorithm and hybridSearch integration"
    - path: "src/storage/__tests__/embeddings.test.ts"
      provides: "Tests for EmbeddingStore CRUD and KNN search operations"
  key_links:
    - from: "tests"
      to: "all Phase 4 modules"
      via: "Unit tests proving each success criterion"
      pattern: "describe.*SC-"
---

<objective>
Test suite proving all 5 Phase 4 success criteria: semantic search by concept, hybrid search quality, non-blocking embedding, graceful degradation, and zero-startup latency.

Purpose: Validates the complete embedding pipeline from engine interface through worker bridge to hybrid search output. Tests follow the same SC-organized pattern used in Phase 1 and Phase 2 acceptance tests.

Output: Test files with comprehensive coverage of all Phase 4 success criteria.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-embedding-engine-and-semantic-search/04-RESEARCH.md
@.planning/phases/04-embedding-engine-and-semantic-search/04-01-SUMMARY.md
@.planning/phases/04-embedding-engine-and-semantic-search/04-02-SUMMARY.md
@.planning/phases/04-embedding-engine-and-semantic-search/04-03-SUMMARY.md
@src/storage/__tests__/observations.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit tests for embedding engines and EmbeddingStore</name>
  <files>
    src/analysis/__tests__/embedder.test.ts
    src/storage/__tests__/embeddings.test.ts
  </files>
  <action>
Create unit tests for the embedding engine layer and storage layer:

**src/analysis/__tests__/embedder.test.ts**:

Test groups organized by success criterion:

`describe('SC-4: Graceful degradation')`:
- KeywordOnlyEngine.embed() returns null
- KeywordOnlyEngine.embedBatch() returns array of nulls matching input length
- KeywordOnlyEngine.isReady() returns false
- KeywordOnlyEngine.initialize() returns false
- KeywordOnlyEngine.dimensions() returns 0
- KeywordOnlyEngine.name() returns 'keyword-only'

`describe('EmbeddingEngine interface contract')`:
- LocalOnnxEngine implements all 6 interface methods
- LocalOnnxEngine.dimensions() returns 384
- LocalOnnxEngine.name() returns 'bge-small-en-v1.5-q8'
- LocalOnnxEngine.isReady() returns false before initialize()
- LocalOnnxEngine.embed() returns null when not initialized

`describe('createEmbeddingEngine factory')`:
- createEmbeddingEngine() returns an engine (either type) without throwing
- Returned engine has all 6 interface methods

Note: Do NOT test actual ONNX model loading in unit tests (requires ~34MB download). Test the interface contract, the fallback behavior, and the factory. The actual model loading is validated by the acceptance test (integration-level) or manually.

For LocalOnnxEngine.embed() tests where model is unavailable, test that it returns null gracefully (not throws).

**src/storage/__tests__/embeddings.test.ts**:

Use `createTempDb()` pattern from existing test utilities for test isolation.

`describe('EmbeddingStore')`:
- `store()` inserts an embedding and `has()` returns true
- `store()` with same ID replaces existing embedding (INSERT OR REPLACE)
- `search()` returns results ordered by cosine distance
- `search()` respects project scoping (observations from other projects not returned)
- `search()` excludes soft-deleted observations
- `search()` respects limit parameter
- `delete()` removes embedding and `has()` returns false
- `findUnembedded()` returns observation IDs that lack embeddings
- `findUnembedded()` excludes soft-deleted observations
- `findUnembedded()` excludes observations that already have embeddings
- All methods return empty/false gracefully when table is empty

For vector tests, create synthetic Float32Array embeddings (random 384-dim vectors) -- no need for real model output. Insert observations into the observations table first (required for the project-scoped subquery in search/findUnembedded).

Important: Only run these tests if `db.hasVectorSupport` is true. Use `describe.skipIf(!hasVectorSupport)` or a conditional at the top.
  </action>
  <verify>
`npm test` passes including the new test files. All existing tests remain green.
  </verify>
  <done>Embedding engine tests prove KeywordOnlyEngine returns null/false for everything, LocalOnnxEngine has correct interface contract, and factory never throws. EmbeddingStore tests prove CRUD operations, project-scoped KNN search, and findUnembedded query against real sqlite-vec.</done>
</task>

<task type="auto">
  <name>Task 2: Hybrid search tests and acceptance criteria</name>
  <files>
    src/search/__tests__/hybrid.test.ts
  </files>
  <action>
Create tests for hybrid search and RRF algorithm:

**src/search/__tests__/hybrid.test.ts**:

`describe('reciprocalRankFusion')`:
- Single list returns items in same order with RRF scores
- Two identical lists produce same ranking (scores double)
- Document appearing in both lists ranks higher than document in only one
- Empty lists produce empty results
- k parameter affects score magnitude but not ranking order
- Handles lists of different lengths correctly

`describe('SC-2: Hybrid search combines keyword and semantic scores')`:
- When both keyword and vector results exist, hybridSearch returns hybrid matchType for overlapping results
- Results from keyword-only have matchType 'fts'
- Results from vector-only have matchType 'vector'
- When worker is null, hybridSearch falls back to keyword-only
- When worker.isReady() is false, hybridSearch falls back to keyword-only
- When worker.embed() returns null for query, hybridSearch falls back to keyword-only
- Limit parameter is respected in final output

For these tests, mock the SearchEngine, EmbeddingStore, and AnalysisWorker:
- Create mock SearchEngine with a `searchKeyword()` that returns predefined SearchResult[]
- Create mock EmbeddingStore with a `search()` that returns predefined vector results
- Create mock AnalysisWorker with controllable `isReady()`, `embed()`, and `getEngineName()` methods
- This avoids needing real database or ONNX model in unit tests

`describe('SC-3: Non-blocking embedding')`:
- Verify AnalysisWorker.embed() returns a Promise (not synchronous)
- Verify AnalysisWorker constructor does not block (measure time < 100ms)

`describe('SC-5: Zero startup latency')`:
- Verify AnalysisWorker.start() initiates worker creation without awaiting model load
- Verify embed() returns null when worker is not yet ready (before start completes)

Use vitest mocking for SearchEngine, EmbeddingStore, and AnalysisWorker where appropriate.
  </action>
  <verify>
`npm test` passes including all new tests. Total test count increases. No regressions in existing tests. Check test output for SC-organized describe blocks proving all 5 success criteria.
  </verify>
  <done>RRF algorithm tested with various ranked list scenarios. Hybrid search tested with mocked dependencies proving correct matchType assignment, graceful fallback, and limit enforcement. All 5 Phase 4 success criteria have at least one test proving them.</done>
</task>

</tasks>

<verification>
- `npm test` passes with all tests green (existing + new)
- New test files:
  - src/analysis/__tests__/embedder.test.ts
  - src/storage/__tests__/embeddings.test.ts
  - src/search/__tests__/hybrid.test.ts
- Each of the 5 success criteria has at least one passing test
- No regressions in existing test suite
</verification>

<success_criteria>
1. SC-1 (semantic search by concept): Covered by hybrid search integration test with vector results
2. SC-2 (hybrid combines scores): RRF algorithm tests + hybridSearch integration tests
3. SC-3 (non-blocking embedding): Worker bridge Promise-based API tests
4. SC-4 (graceful degradation): KeywordOnlyEngine tests + fallback path tests
5. SC-5 (zero startup latency): Worker start timing tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-embedding-engine-and-semantic-search/04-04-SUMMARY.md`
</output>
