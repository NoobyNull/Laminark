---
phase: 04-embedding-engine-and-semantic-search
plan: 04
type: tdd
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - src/search/hybrid.ts
  - src/search/hybrid.test.ts
  - src/mcp/tools/search.ts
autonomous: true

must_haves:
  truths:
    - "Hybrid search combines FTS5 keyword results and sqlite-vec vector results using reciprocal rank fusion"
    - "When both keyword and vector results exist, hybrid returns better-ranked results than either alone"
    - "When only keyword results exist (no embeddings), search returns keyword-only results with no errors"
    - "When only vector results exist (query has no keyword matches), search returns vector-only results"
    - "RRF score is calculated as sum(1/(k+rank)) across both result sets for each observation"
  artifacts:
    - path: "src/search/hybrid.ts"
      provides: "Reciprocal rank fusion algorithm and hybrid search orchestrator"
      exports: ["hybridSearch", "reciprocalRankFusion"]
    - path: "src/search/hybrid.test.ts"
      provides: "Tests for RRF algorithm and hybrid search edge cases"
    - path: "src/mcp/tools/search.ts"
      provides: "Updated MCP search tool using hybrid search"
      exports: ["searchTool"]
  key_links:
    - from: "src/search/hybrid.ts"
      to: "src/storage/embeddings.ts"
      via: "calls EmbeddingStore.searchSimilar for vector results"
      pattern: "searchSimilar|searchSimilarFiltered"
    - from: "src/search/hybrid.ts"
      to: "FTS5 keyword search"
      via: "calls existing FTS5 search from Phase 2 storage"
      pattern: "fts5|MATCH|bm25"
    - from: "src/mcp/tools/search.ts"
      to: "src/search/hybrid.ts"
      via: "delegates to hybridSearch()"
      pattern: "hybridSearch"
---

<objective>
Implement reciprocal rank fusion (RRF) that combines FTS5 keyword scores with sqlite-vec vector similarity scores, and wire it into the MCP search tool.

Purpose: This is the core of SRC-03 (hybrid search). Neither keyword search nor vector search alone is optimal -- keyword finds exact matches but misses synonyms; vector finds semantic matches but misses exact phrases. RRF combines their rankings without needing to normalize their different score scales.

Output: Tested RRF algorithm, hybrid search orchestrator, and updated MCP search tool.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/04-embedding-engine-and-semantic-search/04-02-SUMMARY.md
@.planning/phases/04-embedding-engine-and-semantic-search/04-03-SUMMARY.md
</context>

<feature>
  <name>Reciprocal Rank Fusion for Hybrid Search</name>
  <files>src/search/hybrid.ts, src/search/hybrid.test.ts</files>
  <behavior>
RRF formula: For each result appearing in any ranked list, its fused score = sum(1/(k+rank_i)) where k is a constant (typically 60) and rank_i is the rank in each list (1-based). Higher fused score = more relevant.

Test cases:
- Two ranked lists with same items in different order -> fused list re-ranks by combined score
- Item in both lists ranks higher than item in only one list
- Item in only keyword list still appears (with vector rank = infinity, so 0 contribution)
- Item in only vector list still appears (with keyword rank = infinity, so 0 contribution)
- Empty keyword list + populated vector list -> returns vector results
- Populated keyword list + empty vector list -> returns keyword results
- Both lists empty -> returns empty results
- k parameter affects score magnitude but not relative ranking (with default data)
- Limit parameter caps output size
- Results are sorted by descending fused score

Specific test:
  keyword_results = [obs-A (rank 1), obs-B (rank 2), obs-C (rank 3)]
  vector_results = [obs-B (rank 1), obs-D (rank 2), obs-A (rank 3)]
  k = 60

  obs-A: 1/(60+1) + 1/(60+3) = 0.01639 + 0.01587 = 0.03226
  obs-B: 1/(60+2) + 1/(60+1) = 0.01613 + 0.01639 = 0.03252
  obs-C: 1/(60+3) + 0 = 0.01587
  obs-D: 0 + 1/(60+2) = 0.01613

  Fused ranking: [obs-B, obs-A, obs-D, obs-C]
  </behavior>
  <implementation>
RED: Write tests for reciprocalRankFusion() with the above cases. Tests import from hybrid.ts. Run tests -- they fail (no implementation).

GREEN: Implement reciprocalRankFusion() and hybridSearch():

reciprocalRankFusion(rankedLists: Array<Array<{ id: string; score: number }>>, options?: { k?: number; limit?: number }): Array<{ id: string; fusedScore: number; sources: string[] }>
- Default k = 60
- For each ranked list, assign ranks 1..N based on position (ignore original scores)
- Compute fused score for each unique ID across all lists
- Track which sources contributed to each result
- Sort by descending fused score
- Apply limit

hybridSearch(query: string, options: { projectId: string; limit?: number; embeddingStore: EmbeddingStore; queryEmbedding: Float32Array | null; keywordSearch: (query: string, projectId: string, limit: number) => Array<{ id: string; score: number }> }): Array<{ id: string; fusedScore: number; sources: ("keyword" | "vector")[] }>
- If queryEmbedding is null (no embeddings available), return keyword results directly (graceful degradation)
- If keyword search returns empty and vector search returns empty, return empty
- Otherwise, run both searches and fuse with RRF
- The keywordSearch function is injected to decouple from Phase 2's specific implementation

Run tests -- they pass.

REFACTOR: Clean up if needed. Ensure edge cases are covered.

Then update src/mcp/tools/search.ts:
- Import hybridSearch
- When handling a search request:
  1. Generate query embedding via AnalysisWorker.embed(query) -- may return null
  2. Call hybridSearch() with keyword search function from Phase 2 and EmbeddingStore from Plan 02
  3. Return fused results formatted per existing progressive disclosure format
- If AnalysisWorker is not available, queryEmbedding will be null, and hybridSearch gracefully falls back to keyword-only (DQ-03)
  </implementation>
</feature>

<verification>
1. `npx vitest run src/search/hybrid.test.ts` passes all test cases
2. `npx tsc --noEmit` passes
3. RRF correctly ranks obs-B above obs-A in the example test case
4. Keyword-only fallback returns valid results when queryEmbedding is null
5. Vector-only works when keyword search returns empty
6. MCP search tool uses hybridSearch() and returns results
</verification>

<success_criteria>
- RRF algorithm is correct per the mathematical definition
- hybridSearch handles all degradation modes: both available, keyword-only, vector-only, neither
- MCP search tool transparently uses hybrid search
- All test cases pass including edge cases
- No regression to existing keyword-only search behavior
</success_criteria>

<output>
After completion, create `.planning/phases/04-embedding-engine-and-semantic-search/04-04-SUMMARY.md`
</output>
