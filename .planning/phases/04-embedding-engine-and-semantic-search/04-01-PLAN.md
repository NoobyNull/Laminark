---
phase: 04-embedding-engine-and-semantic-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/analysis/embedder.ts
  - src/analysis/engines/local-onnx.ts
  - src/analysis/engines/keyword-only.ts
autonomous: true

must_haves:
  truths:
    - "EmbeddingEngine interface defines embed(), embedBatch(), dimensions(), and name() methods"
    - "LocalOnnxEngine generates 384-dimensional Float32Array embeddings from text using @huggingface/transformers with BGE Small EN v1.5"
    - "KeywordOnlyEngine returns null for all embed calls, enabling FTS5-only search fallback"
    - "createEmbeddingEngine() factory selects engine based on availability, defaulting to LocalOnnx with KeywordOnly fallback"
  artifacts:
    - path: "src/analysis/embedder.ts"
      provides: "EmbeddingEngine interface and factory function"
      exports: ["EmbeddingEngine", "createEmbeddingEngine"]
    - path: "src/analysis/engines/local-onnx.ts"
      provides: "Local ONNX embedding engine using @huggingface/transformers"
      exports: ["LocalOnnxEngine"]
    - path: "src/analysis/engines/keyword-only.ts"
      provides: "Null embedding engine for keyword-only fallback"
      exports: ["KeywordOnlyEngine"]
  key_links:
    - from: "src/analysis/engines/local-onnx.ts"
      to: "@huggingface/transformers"
      via: "pipeline() for feature-extraction"
      pattern: "pipeline.*feature-extraction"
    - from: "src/analysis/embedder.ts"
      to: "src/analysis/engines/local-onnx.ts"
      via: "factory function imports and instantiates"
      pattern: "LocalOnnxEngine"
    - from: "src/analysis/embedder.ts"
      to: "src/analysis/engines/keyword-only.ts"
      via: "factory function fallback path"
      pattern: "KeywordOnlyEngine"
---

<objective>
Create the pluggable embedding strategy interface with two implementations: LocalOnnxEngine (default, using @huggingface/transformers with BGE Small EN v1.5) and KeywordOnlyEngine (graceful fallback).

Purpose: This is the foundation for all semantic intelligence in Memorite. The pluggable interface (INT-01) ensures the system can swap embedding strategies without touching consumers. The KeywordOnlyEngine ensures graceful degradation (DQ-03) when ONNX is unavailable.

Output: EmbeddingEngine interface, two engine implementations, and a factory function that selects the right engine.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/research/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EmbeddingEngine interface and KeywordOnlyEngine</name>
  <files>src/analysis/embedder.ts, src/analysis/engines/keyword-only.ts</files>
  <action>
Create `src/analysis/embedder.ts` with the `EmbeddingEngine` interface:

```typescript
export interface EmbeddingEngine {
  /** Generate embedding for a single text. Returns null if embedding unavailable. */
  embed(text: string): Promise<Float32Array | null>;
  /** Generate embeddings for multiple texts. Each element may be null on failure. */
  embedBatch(texts: string[]): Promise<(Float32Array | null)[]>;
  /** Number of dimensions in the embedding vector (e.g., 384 for BGE Small). */
  dimensions(): number;
  /** Human-readable engine name for logging and model_version metadata. */
  name(): string;
  /** Initialize the engine. Called lazily, not at construction time. Returns true if ready. */
  initialize(): Promise<boolean>;
  /** Whether the engine has been successfully initialized. */
  isReady(): boolean;
}
```

Also export a `createEmbeddingEngine()` async factory function (implementation in Task 2 after LocalOnnxEngine exists). For now, stub it to return KeywordOnlyEngine.

Create `src/analysis/engines/keyword-only.ts` implementing `EmbeddingEngine`:
- `embed()` always returns `null`
- `embedBatch()` always returns array of `null`s matching input length
- `dimensions()` returns `0`
- `name()` returns `"keyword-only"`
- `initialize()` returns `true` immediately
- `isReady()` returns `true` always

This engine has zero dependencies and zero overhead. It exists so the system can always fall back to FTS5-only search without conditionals scattered throughout the codebase.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm types compile. Write a quick inline test or use `node -e` to import KeywordOnlyEngine and verify embed() returns null and dimensions() returns 0.
  </verify>
  <done>EmbeddingEngine interface exported from embedder.ts. KeywordOnlyEngine implements it, returning null embeddings and 0 dimensions. Both files compile without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create LocalOnnxEngine with lazy initialization</name>
  <files>src/analysis/engines/local-onnx.ts, src/analysis/embedder.ts</files>
  <action>
Create `src/analysis/engines/local-onnx.ts` implementing `EmbeddingEngine`:

Use `@huggingface/transformers` (v3.8+) with the `pipeline` API:
- Model: `Xenova/bge-small-en-v1.5` (384 dimensions, ~23MB, ONNX format)
- Task: `"feature-extraction"`
- The pipeline instance is created lazily in `initialize()`, NOT in the constructor
- Constructor sets `this.pipeline = null` and `this.ready = false`
- `initialize()` calls `pipeline("feature-extraction", "Xenova/bge-small-en-v1.5", { dtype: "fp32" })` and stores the result. On success, sets `this.ready = true` and returns `true`. On failure (model download error, ONNX load error), logs the error, sets `this.ready = false`, and returns `false`. NEVER throws -- always returns boolean.
- `embed(text)`: If not ready, returns `null`. Otherwise, runs `this.pipeline(text, { pooling: "cls", normalize: true })` and returns the result as `Float32Array`. Wraps in try/catch -- any error returns `null` (not throw).
- `embedBatch(texts)`: Maps over texts calling embed() for each. (HuggingFace transformers v3 supports batch input natively via array -- use that if available, otherwise sequential.)
- `dimensions()`: returns `384`
- `name()`: returns `"local-onnx/bge-small-en-v1.5"`

Update `createEmbeddingEngine()` in `src/analysis/embedder.ts`:
1. Create a `LocalOnnxEngine` instance
2. Call `await engine.initialize()`
3. If initialize returns `true`, return the engine
4. If initialize returns `false`, log warning "ONNX engine unavailable, falling back to keyword-only search" and return a new `KeywordOnlyEngine()`

This factory function embodies DQ-03 (graceful degradation) -- callers get an engine that always works, they never need to check which one.

Important: Do NOT import `@huggingface/transformers` at the top level of the file. Use dynamic `import()` inside `initialize()` so the module is only loaded when actually needed. This supports DQ-04 (zero startup latency) -- if the engine is never initialized, the heavy ONNX dependency is never loaded.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm types compile. Test the factory function: `createEmbeddingEngine()` should return a LocalOnnxEngine if @huggingface/transformers is installed, or fall back to KeywordOnlyEngine if not. Verify by checking `engine.name()` return value. Test that `engine.embed("test sentence")` returns a Float32Array of length 384 (or null on fallback).
  </verify>
  <done>LocalOnnxEngine generates 384-dim embeddings via @huggingface/transformers with lazy initialization. createEmbeddingEngine() factory returns ONNX engine on success or KeywordOnly on failure. No exceptions leak from any engine method.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `createEmbeddingEngine()` returns an engine where `engine.name()` is either "local-onnx/bge-small-en-v1.5" or "keyword-only"
3. If ONNX available: `engine.embed("hello world")` returns Float32Array with length 384
4. If ONNX unavailable: `engine.embed("hello world")` returns null (no throw)
5. KeywordOnlyEngine always returns null embeddings and 0 dimensions
</verification>

<success_criteria>
- EmbeddingEngine interface is the single contract for all embedding strategies
- LocalOnnxEngine uses @huggingface/transformers with BGE Small EN v1.5 (384-dim)
- KeywordOnlyEngine provides zero-overhead null fallback
- Factory function handles graceful degradation transparently
- Lazy initialization ensures zero import cost at module load time
- No method on any engine implementation ever throws -- all return null or false on error
</success_criteria>

<output>
After completion, create `.planning/phases/04-embedding-engine-and-semantic-search/04-01-SUMMARY.md`
</output>
