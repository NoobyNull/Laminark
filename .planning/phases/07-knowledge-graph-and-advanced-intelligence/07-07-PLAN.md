---
phase: 07-knowledge-graph-and-advanced-intelligence
plan: 07
type: execute
wave: 4
depends_on: ["07-03", "07-04", "07-05"]
files_modified:
  - src/graph/curation-agent.ts
  - src/graph/observation-merger.ts
  - tests/graph/curation-agent.test.ts
autonomous: true

must_haves:
  truths:
    - "Curation agent runs during quiet periods (session end, long pauses) and processes pending work"
    - "Similar observations (cosine similarity > 0.95) about the same entity are merged into consolidated summaries"
    - "Merged observations reference their source observation IDs for auditability"
    - "Low-value observations (very short, low confidence entities, no relationships) are pruned"
    - "Curation agent is idempotent -- running it twice produces the same result"
  artifacts:
    - path: "src/graph/curation-agent.ts"
      provides: "Background curation agent: trigger, scheduling, orchestration"
      exports: ["CurationAgent", "runCuration", "CurationReport"]
    - path: "src/graph/observation-merger.ts"
      provides: "Observation merging logic: similarity detection, summary generation, merge execution"
      exports: ["findMergeableClusters", "mergeObservationCluster", "MergeCluster"]
    - path: "tests/graph/curation-agent.test.ts"
      provides: "Tests for curation agent and observation merging"
  key_links:
    - from: "src/graph/curation-agent.ts"
      to: "src/graph/observation-merger.ts"
      via: "curation agent calls merger during quiet periods"
      pattern: "findMergeableClusters|mergeObservationCluster"
    - from: "src/graph/curation-agent.ts"
      to: "src/graph/constraints.ts"
      via: "runs findDuplicateEntities and mergeEntities during curation"
      pattern: "findDuplicateEntities|mergeEntities"
    - from: "src/graph/curation-agent.ts"
      to: "src/graph/staleness.ts"
      via: "runs staleness detection as part of curation sweep"
      pattern: "detectStaleness|flagStaleObservation"
    - from: "src/graph/observation-merger.ts"
      to: "SQLite observations table"
      via: "reads observation content and embeddings for similarity comparison"
      pattern: "db\\.prepare.*observations"
---

<objective>
Implement the background curation agent that maintains knowledge graph quality during quiet periods: merging similar observations, generating consolidated summaries, pruning low-value data, deduplicating entities, and flagging stale content.

Purpose: DQ-01 requires a curation agent that runs during quiet periods to keep the knowledge base high-quality as it grows. Without active curation, the observation store and graph would accumulate redundant, contradictory, and low-value data over time.
Output: Curation agent with observation merging, entity dedup, staleness sweeps, and low-value pruning.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-knowledge-graph-and-advanced-intelligence/07-03-SUMMARY.md
@.planning/phases/07-knowledge-graph-and-advanced-intelligence/07-04-SUMMARY.md
@.planning/phases/07-knowledge-graph-and-advanced-intelligence/07-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement observation similarity detection and merging</name>
  <files>src/graph/observation-merger.ts</files>
  <action>
Create src/graph/observation-merger.ts:

1. Define `MergeCluster` interface:
   ```typescript
   interface MergeCluster {
     entityId: string;           // entity these observations relate to
     observations: Array<{ id: string, text: string, embedding: number[] | null, created_at: string }>;
     similarity: number;         // average pairwise similarity within cluster
     suggestedSummary: string;   // consolidated text
   }
   ```

2. `findMergeableClusters(db: Database, opts?: { threshold?: number, entityId?: string }): MergeCluster[]`:
   - Default similarity threshold: 0.95 (very conservative -- only near-duplicates)
   - Group observations by entity (via graph_nodes.observation_ids)
   - For each entity with 3+ observations:
     a. Compute pairwise cosine similarity between observation embeddings
     b. If embeddings are null (no vector yet), fall back to Jaccard similarity on tokenized words (threshold 0.85 for text-based)
     c. Cluster observations where ALL pairwise similarities exceed threshold
     d. Only include clusters with 2+ observations
   - For each cluster, generate a suggested summary:
     a. Take the longest observation as the base
     b. Append any unique information from shorter observations (simple: keywords in shorter that aren't in longest)
     c. Prepend "[Consolidated from N observations]"
   - Return sorted by cluster size DESC (largest clusters first)

3. `mergeObservationCluster(db: Database, cluster: MergeCluster): { mergedId: string, removedIds: string[] }`:
   - Create a new consolidated observation with the suggestedSummary text
   - Store metadata: { merged_from: cluster.observations.map(o => o.id), merged_at: now, original_count: N }
   - Update the entity's observation_ids: remove old IDs, add new merged ID
   - Soft-delete the original observations (set a deleted_at or merged_into field, do NOT hard delete)
   - If observations have embeddings, compute the mean embedding for the consolidated observation
   - Run in transaction

4. `pruneLowValue(db: Database, opts?: { minTextLength?: number, maxAge?: number }): { pruned: number }`:
   - Find observations that are:
     a. Very short (< 20 characters, likely noise)
     b. Have no linked entities (extracted nothing useful)
     c. Are older than maxAge days (default: 90)
     d. AND not manually saved by user (check if observation was from save_memory tool vs auto-capture)
   - Soft-delete these observations
   - Return count of pruned observations
   - Be VERY conservative -- only prune if ALL criteria match (short AND no entities AND old AND auto-captured)

All operations use soft-delete patterns. Hard deletion should never occur in curation -- users can always recover.
  </action>
  <verify>npx tsc --noEmit src/graph/observation-merger.ts. Test: create 3 nearly identical observations for same entity, call findMergeableClusters, verify they form a cluster. Call mergeObservationCluster, verify consolidated observation exists and originals are soft-deleted.</verify>
  <done>Observation similarity detection finds near-duplicate clusters (cosine > 0.95 or Jaccard > 0.85). Merging creates consolidated summaries preserving all unique information. Original observations are soft-deleted with full audit trail. Low-value pruning is conservative and reversible.</done>
</task>

<task type="auto">
  <name>Task 2: Implement curation agent with scheduling and orchestration</name>
  <files>src/graph/curation-agent.ts, tests/graph/curation-agent.test.ts</files>
  <action>
**Curation agent (src/graph/curation-agent.ts):**

1. Define `CurationReport` interface:
   ```typescript
   interface CurationReport {
     startedAt: string;
     completedAt: string;
     observationsMerged: number;
     entitiesDeduplicated: number;
     stalenessFlagsAdded: number;
     lowValuePruned: number;
     errors: string[];
   }
   ```

2. `CurationAgent` class:
   - Constructor: `new CurationAgent(db: Database, opts?: { intervalMs?: number, onComplete?: (report: CurationReport) => void })`
   - Default interval: 5 minutes (300,000ms)
   - State: running (boolean), lastRun (timestamp), timer (NodeJS.Timeout)

3. Methods:
   - `start()`: Begin periodic curation on setInterval. Log "[memorite:curation] Agent started, interval: Nms"
   - `stop()`: Clear interval, set running = false. Log "[memorite:curation] Agent stopped"
   - `runOnce(): Promise<CurationReport>`: Execute one curation cycle. This is the main entry point.

4. `runCuration(db: Database): Promise<CurationReport>` (standalone function, also usable without class):
   - Execute curation steps in order:

   **Step 1: Merge similar observations**
   - Call findMergeableClusters
   - For each cluster, call mergeObservationCluster
   - Record count

   **Step 2: Deduplicate entities**
   - Call findDuplicateEntities from constraints module
   - For each duplicate pair, call mergeEntities (keep the one with more observation_ids)
   - Record count

   **Step 3: Enforce graph constraints**
   - Get all nodes with degree > MAX_NODE_DEGREE * 0.9 (approaching limit)
   - Call enforceMaxDegree on each
   - Record any pruning

   **Step 4: Staleness sweep**
   - For each entity updated in the last 24 hours, call detectStaleness
   - Flag any newly detected stale observations via flagStaleObservation
   - Record count

   **Step 5: Low-value pruning**
   - Call pruneLowValue with defaults
   - Record count

   - Wrap each step in try/catch. If one step fails, log the error and continue with remaining steps. Curation should NEVER crash the main process.
   - Log summary: "[memorite:curation] Cycle complete: N merged, N deduped, N flagged stale, N pruned"

5. Integration points for triggers:
   - `onSessionEnd(db: Database)`: Run a targeted curation cycle focusing on the current session's observations only (faster than full sweep)
   - `onQuietPeriod(db: Database)`: Run full curation cycle (called when no activity for 5+ minutes)

6. Idempotency: running curation twice in a row produces the same result (merged observations don't get re-merged, already flagged stale observations don't get re-flagged, etc.)

**Tests (tests/graph/curation-agent.test.ts):**

1. "merges similar observations during curation"
   - Set up: 3 nearly identical observations for same entity
   - Run curation
   - Expect: observations merged, consolidated summary created

2. "deduplicates entities during curation"
   - Set up: two Tool nodes "React" and "react"
   - Run curation
   - Expect: merged into one node, edges rerouted

3. "flags stale observations during curation"
   - Set up: older observation "uses Redux", newer "switched to Zustand"
   - Run curation
   - Expect: older observation flagged as stale

4. "handles errors gracefully without crashing"
   - Mock one step to throw
   - Run curation
   - Expect: report shows error, other steps still completed

5. "is idempotent"
   - Run curation twice
   - Expect: second run has 0 merges, 0 dedup, 0 new flags
  </action>
  <verify>Run tests: `npx vitest run tests/graph/curation-agent.test.ts`. All 5 tests pass. npx tsc --noEmit passes. Verify the agent can start/stop without errors.</verify>
  <done>Curation agent runs periodically or on-demand, performing: observation merging, entity dedup, constraint enforcement, staleness detection, and low-value pruning. Each step is isolated (one failure doesn't stop others). Agent is idempotent and never crashes the main process.</done>
</task>

</tasks>

<verification>
- Curation cycle completes without errors on a graph with mixed data
- Similar observations are merged (cosine > 0.95 threshold respected)
- Original observations are soft-deleted (recoverable), not hard-deleted
- Entity deduplication merges case-insensitive matches and reroutes edges
- Staleness sweep catches contradiction patterns from Plan 04
- Low-value pruning only removes observations matching ALL conservative criteria
- Running curation twice is idempotent
- Agent stop/start lifecycle works cleanly
- All tests pass
</verification>

<success_criteria>
The knowledge graph is actively maintained: similar observations are consolidated, duplicate entities are merged, stale content is flagged, and low-value noise is pruned. Curation runs automatically during quiet periods and can be triggered at session end. All operations are non-destructive (soft-delete, audit trail) and the agent never crashes the main process.
</success_criteria>

<output>
After completion, create `.planning/phases/07-knowledge-graph-and-advanced-intelligence/07-07-SUMMARY.md`
</output>
