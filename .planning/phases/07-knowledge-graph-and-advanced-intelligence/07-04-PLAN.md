---
phase: 07-knowledge-graph-and-advanced-intelligence
plan: 04
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/graph/temporal.ts
  - src/graph/staleness.ts
  - tests/graph/temporal.test.ts
autonomous: true

must_haves:
  truths:
    - "Every observation has a created_at timestamp tracked in the system"
    - "When a newer observation contradicts an older observation about the same entity, the older observation is flagged as stale"
    - "Staleness is flagged but NOT auto-resolved -- the system surfaces both observations and lets the user decide"
    - "Temporal queries can filter observations by time range (last N hours, since date)"
  artifacts:
    - path: "src/graph/temporal.ts"
      provides: "Temporal query utilities: time range filtering, recency scoring, observation age calculation"
      exports: ["getObservationsByTimeRange", "calculateRecencyScore", "getObservationAge"]
    - path: "src/graph/staleness.ts"
      provides: "Staleness detection: finds contradictions between observations on same entity"
      exports: ["detectStaleness", "StalenessReport", "flagStaleObservation"]
    - path: "tests/graph/temporal.test.ts"
      provides: "Tests for temporal queries and staleness detection"
  key_links:
    - from: "src/graph/staleness.ts"
      to: "src/graph/schema.ts"
      via: "queries graph_nodes to find observations linked to same entity"
      pattern: "getEdgesForNode|getNodesByType"
    - from: "src/graph/staleness.ts"
      to: "SQLite observations table"
      via: "reads observation timestamps and content for contradiction detection"
      pattern: "db\\.prepare.*observations"
---

<objective>
Implement temporal awareness for observations: timestamp tracking, time range queries, recency scoring, and staleness detection when newer observations contradict older ones about the same entity.

Purpose: INT-13 requires tracking when observations were created and detecting staleness from contradictions. This prevents the knowledge graph from serving outdated information while preserving user agency (flag, don't auto-resolve).
Output: Temporal query utilities and staleness detection module with tests.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-knowledge-graph-and-advanced-intelligence/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement temporal query utilities</name>
  <files>src/graph/temporal.ts</files>
  <action>
Create src/graph/temporal.ts with time-aware query and scoring functions:

1. `getObservationsByTimeRange(db: Database, opts: { since?: string, until?: string, entityId?: string, limit?: number }): Observation[]`
   - Query observations table with WHERE created_at BETWEEN ? AND ?
   - If entityId provided, join through graph_nodes.observation_ids to filter to observations linked to that entity
   - Default limit: 100
   - Returns observations sorted by created_at DESC (newest first)

2. `calculateRecencyScore(createdAt: string, now?: Date): number`
   - Returns a 0.0-1.0 score based on how recent the observation is
   - Formula: exponential decay with half-life of 7 days
   - Score = Math.exp(-0.693 * ageDays / 7)
   - 0 days old = 1.0, 7 days = 0.5, 14 days = 0.25, etc.
   - Used by search ranking and curation to weight fresher observations higher

3. `getObservationAge(createdAt: string, now?: Date): { days: number, hours: number, label: string }`
   - Returns structured age info
   - label: "just now" (< 1 hour), "N hours ago" (< 24), "N days ago" (< 30), "N months ago"

4. `getEntityTimeline(db: Database, entityId: string): Array<{ observation: Observation, recencyScore: number, age: ReturnType<typeof getObservationAge> }>`
   - Returns all observations linked to an entity, annotated with recency scores
   - Sorted chronologically (oldest first) -- timeline view

5. `getRecentEntities(db: Database, opts?: { hours?: number, type?: EntityType }): GraphNode[]`
   - Returns entities that were created or had observations added within the time window
   - Default: last 24 hours
   - Useful for "what's been active recently?" queries

All functions accept a Database handle. Use ISO 8601 strings for all timestamp parameters. Handle timezone by always storing and comparing in UTC.
  </action>
  <verify>npx tsc --noEmit src/graph/temporal.ts. Test calculateRecencyScore: 0 days returns 1.0, 7 days returns ~0.5. Test getObservationAge: verify label formatting.</verify>
  <done>Temporal queries filter by time range. Recency scoring uses exponential decay with 7-day half-life. Entity timeline shows chronological observation history. Recent entities query surfaces active nodes.</done>
</task>

<task type="auto">
  <name>Task 2: Implement staleness detection with contradiction flagging</name>
  <files>src/graph/staleness.ts, tests/graph/temporal.test.ts</files>
  <action>
**Staleness detector (src/graph/staleness.ts):**

1. Define `StalenessReport` interface:
   ```typescript
   interface StalenessReport {
     entityId: string;
     entityName: string;
     entityType: EntityType;
     newerObservation: { id: string; text: string; created_at: string };
     olderObservation: { id: string; text: string; created_at: string };
     reason: string; // human-readable explanation of why this is a contradiction
     detectedAt: string;
   }
   ```

2. `detectStaleness(db: Database, entityId: string): StalenessReport[]`:
   - Get all observations linked to this entity (via graph_nodes.observation_ids)
   - Sort by created_at
   - Compare consecutive observations for contradiction signals:
     a. **Negation patterns**: newer says "don't use X" while older says "use X", or vice versa
     b. **Replacement patterns**: newer says "switched from X to Y" or "replaced X with Y" -- older observations about X are stale
     c. **Status change patterns**: newer says "removed", "deleted", "deprecated" about something older described as active
   - Use simple string matching for these patterns (not LLM-based):
     - Negation: presence of "not", "don't", "no longer", "stopped" in newer when absent in older for same subject
     - Replacement: "switched to", "migrated to", "replaced with", "changed from"
     - Status: "removed", "deleted", "deprecated", "archived", "dropped"
   - Return StalenessReport for each detected contradiction
   - This is DETECTION only -- do not modify any data

3. `flagStaleObservation(db: Database, observationId: string, reason: string): void`:
   - Add a staleness flag to the observation's metadata (or a separate staleness_flags table if the observation table doesn't have a metadata column)
   - Store: { flagged_at, reason, resolved: false }
   - This flag is advisory -- search can use it to deprioritize but never hide

4. `getStaleObservations(db: Database, opts?: { entityId?: string, resolved?: boolean }): Array<{ observation: Observation, report: StalenessReport }>`:
   - Query flagged observations, optionally filtered by entity or resolution status

**Tests (tests/graph/temporal.test.ts):**

1. "calculates recency score with exponential decay"
   - Verify score = 1.0 for now, ~0.5 for 7 days ago, ~0.25 for 14 days

2. "formats observation age labels correctly"
   - < 1 hour = "just now", 5 hours = "5 hours ago", 3 days = "3 days ago"

3. "detects staleness from negation pattern"
   - Older: "We use Redux for state management"
   - Newer: "We no longer use Redux, switched to Zustand"
   - Expect: StalenessReport flagging the older observation

4. "detects staleness from replacement pattern"
   - Older: "Authentication uses jsonwebtoken library"
   - Newer: "Replaced jsonwebtoken with jose for Edge compatibility"
   - Expect: StalenessReport

5. "does not flag non-contradictory observations as stale"
   - Older: "Added user model to schema"
   - Newer: "Added admin role to user model"
   - Expect: No staleness reports (additive, not contradictory)

6. "flagStaleObservation marks but does not delete"
   - Flag an observation, verify it still appears in queries but with stale metadata
  </action>
  <verify>Run tests: `npx vitest run tests/graph/temporal.test.ts`. All 6 tests pass. npx tsc --noEmit passes for both files.</verify>
  <done>Staleness detection finds contradictions between observations about the same entity using pattern matching. Stale observations are flagged (not deleted) with advisory metadata. Tests validate negation, replacement, and non-contradictory scenarios.</done>
</task>

</tasks>

<verification>
- Recency scoring produces monotonically decreasing values for older observations
- Staleness detection catches negation, replacement, and status change patterns
- Staleness detection does NOT produce false positives on additive/complementary observations
- Flagged observations remain queryable -- staleness is advisory, never destructive
- All tests pass
</verification>

<success_criteria>
Temporal awareness is fully operational: observations are queryable by time range, scored by recency, and checked for staleness. Contradictions between observations about the same entity are detected and flagged without auto-resolution. Users retain full control over which observations to trust.
</success_criteria>

<output>
After completion, create `.planning/phases/07-knowledge-graph-and-advanced-intelligence/07-04-SUMMARY.md`
</output>
