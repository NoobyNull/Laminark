---
phase: 07-knowledge-graph-and-advanced-intelligence
plan: 05
type: execute
wave: 3
depends_on: ["07-01", "07-03"]
files_modified:
  - src/graph/relationship-detector.ts
  - src/graph/constraints.ts
  - tests/graph/relationship-detector.test.ts
autonomous: true

must_haves:
  truths:
    - "When two entities are mentioned in the same observation, a typed relationship is detected between them"
    - "Relationship types are inferred from context: 'uses' for tool usage, 'depends_on' for dependency mentions, etc."
    - "Entity type taxonomy CHECK constraint prevents any non-standard entity type from being stored"
    - "When a node exceeds 50 edges, the lowest-weight edges are pruned to maintain the cap"
    - "Duplicate entities (same name+type) are merged on upsert, not duplicated"
  artifacts:
    - path: "src/graph/relationship-detector.ts"
      provides: "Detects and creates typed relationships between co-occurring entities"
      exports: ["detectRelationships", "RelationshipCandidate"]
    - path: "src/graph/constraints.ts"
      provides: "Graph constraint enforcement: taxonomy validation, degree cap, dedup"
      exports: ["enforceMaxDegree", "validateEntityType", "validateRelationshipType", "mergeEntities"]
    - path: "tests/graph/relationship-detector.test.ts"
      provides: "Tests for relationship detection and constraint enforcement"
  key_links:
    - from: "src/graph/relationship-detector.ts"
      to: "src/graph/schema.ts"
      via: "calls insertEdge to persist detected relationships"
      pattern: "insertEdge"
    - from: "src/graph/relationship-detector.ts"
      to: "src/graph/entity-extractor.ts"
      via: "receives extracted entities as input for relationship detection"
      pattern: "EntityExtractionResult|extractEntities"
    - from: "src/graph/constraints.ts"
      to: "src/graph/schema.ts"
      via: "queries and modifies edges for degree enforcement"
      pattern: "countEdgesForNode|getEdgesForNode"
---

<objective>
Implement relationship detection between co-occurring entities and graph constraint enforcement (type taxonomy, max degree, entity deduplication).

Purpose: INT-10 and INT-12 require typed relationship detection and graph health constraints. Without these, the knowledge graph becomes either disconnected (no relationships) or an unqueryable hairball (no constraints).
Output: Relationship detection pipeline, constraint enforcement module, and tests.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-knowledge-graph-and-advanced-intelligence/07-01-SUMMARY.md
@.planning/phases/07-knowledge-graph-and-advanced-intelligence/07-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement relationship detection between co-occurring entities</name>
  <files>src/graph/relationship-detector.ts, tests/graph/relationship-detector.test.ts</files>
  <action>
**Relationship detector (src/graph/relationship-detector.ts):**

1. Define `RelationshipCandidate` interface:
   ```typescript
   interface RelationshipCandidate {
     sourceEntity: { name: string, type: EntityType };
     targetEntity: { name: string, type: EntityType };
     relationshipType: RelationshipType;
     confidence: number; // 0.0-1.0
     evidence: string;   // the text snippet that led to this inference
   }
   ```

2. `detectRelationships(text: string, entities: Array<{ name: string, type: EntityType }>): RelationshipCandidate[]`:
   - Takes observation text and already-extracted entities
   - For each pair of entities co-occurring in the text, infer relationship type from context:

   **Inference rules (ordered by specificity):**

   a. File + Tool: "uses" (e.g., "src/app.ts uses react" -> File -uses-> Tool)
   b. File + File: "depends_on" if import/require language present, else "related_to"
   c. Decision + Tool: "decided_by" if tool was chosen, else "related_to"
   d. Decision + Person: "decided_by" (person made the decision)
   e. Problem + File: "part_of" (problem is in the file)
   f. Problem + Solution: "solved_by"
   g. Solution + Tool: "uses" (solution uses tool)
   h. Project + File: "part_of" (file is part of project)
   i. Any + Any (default): "related_to" with lower confidence (0.3)

   **Context signals for relationship type inference:**
   - "uses", "using", "with" -> uses
   - "depends on", "requires", "imports", "from" -> depends_on
   - "decided", "chose", "selected" -> decided_by
   - "part of", "in", "belongs to", "inside" -> part_of
   - "caused by", "because of", "due to" -> caused_by
   - "solved by", "fixed by", "resolved by" -> solved_by
   - No clear signal -> related_to

   - Check proximity: entities within 50 characters of each other get confidence boost (+0.1)
   - Check sentence co-occurrence: entities in same sentence get confidence boost (+0.15)
   - Filter out self-relationships (source == target)

3. `detectAndPersist(db: Database, text: string, entities: Array<{ name: string, type: EntityType }>): GraphEdge[]`:
   - Call detectRelationships
   - Resolve entity names to node IDs via getNodeByNameAndType
   - Call insertEdge for each candidate with confidence > 0.3
   - After inserting, call enforceMaxDegree (from constraints module) for affected nodes
   - Return persisted edges

**Tests (tests/graph/relationship-detector.test.ts):**

1. "detects 'uses' relationship between File and Tool"
   - Input: "src/app.ts uses the react framework"
   - Entities: [File: src/app.ts, Tool: react]
   - Expect: uses relationship

2. "detects 'solved_by' between Problem and Solution"
   - Input: "The authentication bug was fixed by adding token refresh"
   - Entities: [Problem: authentication bug, Solution: adding token refresh]
   - Expect: solved_by relationship

3. "detects 'decided_by' between Decision and Person"
   - Input: "Decided by @matt to use Tailwind CSS"
   - Entities: [Decision: use Tailwind CSS, Person: @matt]
   - Expect: decided_by relationship

4. "defaults to 'related_to' for ambiguous co-occurrences"
   - Input: "Updated the readme and cleaned up tests"
   - Entities: [File: readme, File: tests]
   - Expect: related_to relationship with lower confidence

5. "does not create self-relationships"
   - Input: "eslint checks eslint config"
   - Entities: [Tool: eslint]
   - Expect: no relationships (only one unique entity)

6. "boosts confidence for proximate entities"
   - Two entities within 30 chars vs 200 chars
   - Expect: closer entities have higher confidence
  </action>
  <verify>Run tests: `npx vitest run tests/graph/relationship-detector.test.ts`. All 6 tests pass. npx tsc --noEmit passes.</verify>
  <done>Relationship detection infers typed relationships from entity co-occurrence with context-based type inference. Proximity and sentence co-occurrence boost confidence. Tests validate all 7 relationship types and edge cases.</done>
</task>

<task type="auto">
  <name>Task 2: Implement graph constraint enforcement</name>
  <files>src/graph/constraints.ts</files>
  <action>
Create src/graph/constraints.ts with graph health enforcement functions:

1. `validateEntityType(type: string): type is EntityType`:
   - Returns true if type is in ENTITY_TYPES array
   - This is the runtime equivalent of the SQL CHECK constraint
   - Used before any upsertNode call as defense-in-depth

2. `validateRelationshipType(type: string): type is RelationshipType`:
   - Returns true if type is in RELATIONSHIP_TYPES array
   - Used before any insertEdge call

3. `enforceMaxDegree(db: Database, nodeId: string, maxDegree?: number): { pruned: number, remaining: number }`:
   - Default maxDegree = MAX_NODE_DEGREE (50, imported from types.ts)
   - Count edges for node using countEdgesForNode
   - If count > maxDegree:
     a. Get all edges for node
     b. Sort by weight ASC (lowest weight first)
     c. Delete edges until count <= maxDegree (remove lowest-weight edges)
     d. Log pruned edge count with [laminark:graph] prefix
   - Return { pruned: number of edges removed, remaining: number of edges left }
   - Run in a transaction to prevent race conditions

4. `mergeEntities(db: Database, keepId: string, mergeId: string): void`:
   - Merge entity mergeId INTO keepId (keepId survives, mergeId is deleted)
   - Steps:
     a. Move all observation_ids from mergeId to keepId (union, no duplicates)
     b. Reroute all edges pointing to/from mergeId to point to/from keepId
     c. Handle edge conflicts: if rerouting would create a duplicate edge (same source+target+type), keep the higher-weight one
     d. Delete the mergeId node
     e. Run in transaction
   - Use case: entity deduplication (e.g., "React" and "react" are the same Tool)

5. `findDuplicateEntities(db: Database, opts?: { type?: EntityType }): Array<{ entities: GraphNode[], reason: string }>`:
   - Find potential duplicates by:
     a. Case-insensitive name match (normalize to lowercase)
     b. Common abbreviations (e.g., "TS" and "TypeScript", "JS" and "JavaScript")
     c. Path normalization for Files (strip leading ./, normalize separators)
   - Return grouped potential duplicates with reason
   - This is a SUGGESTION function -- mergeEntities is the action function
   - Keep the abbreviation list small and conservative (~20 common mappings)

6. `getGraphHealth(db: Database): { totalNodes: number, totalEdges: number, avgDegree: number, maxDegree: number, hotspots: Array<{ node: GraphNode, degree: number }>, duplicateCandidates: number }`:
   - Dashboard-style health check for the graph
   - Hotspots = nodes with degree > 0.8 * MAX_NODE_DEGREE (approaching limit)
   - Used by curation agent and diagnostics

All functions log significant actions (pruning, merging) with [laminark:graph] prefix.
  </action>
  <verify>npx tsc --noEmit src/graph/constraints.ts. Test: create a node with 55 edges, call enforceMaxDegree, verify 5 lowest-weight edges are pruned. Test findDuplicateEntities with "React" and "react" -- should flag as duplicate. Test mergeEntities -- verify edges are rerouted and merged node is deleted.</verify>
  <done>Graph constraints are enforced: type taxonomy validated at runtime, max degree of 50 edges enforced by pruning lowest-weight edges, duplicate entities detectable and mergeable. Graph health dashboard provides at-a-glance metrics.</done>
</task>

</tasks>

<verification>
- Relationship type inference produces correct types for all 7 relationship categories
- Max degree enforcement removes exactly the right number of lowest-weight edges
- Entity merge correctly reroutes all edges and avoids duplicate edge conflicts
- Duplicate detection catches case-insensitive matches and common abbreviations
- Type validation prevents non-taxonomy types at runtime (defense-in-depth with SQL CHECK)
- All tests pass
</verification>

<success_criteria>
Typed relationships are automatically detected between co-occurring entities with context-appropriate relationship types. Graph constraints prevent hairball growth: type taxonomy is enforced, node degree is capped at 50, and duplicate entities can be detected and merged. The graph stays healthy and queryable as it grows.
</success_criteria>

<output>
After completion, create `.planning/phases/07-knowledge-graph-and-advanced-intelligence/07-05-SUMMARY.md`
</output>
