---
phase: 07-knowledge-graph-and-advanced-intelligence
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/embeddings/piggyback-strategy.ts
  - src/embeddings/hybrid-selector.ts
  - src/hooks/piggyback-extractor.ts
autonomous: true

must_haves:
  truths:
    - "During PostToolUse hook processing, semantic signals are extracted from Claude's response content at zero added latency"
    - "Piggyback embeddings capture Claude's reasoning quality, producing higher-quality semantic vectors than local ONNX alone"
    - "Hybrid selector chooses between local ONNX (speed) and Claude piggyback (quality) based on startup configuration"
    - "If piggyback extraction fails or is unavailable, system silently falls back to local ONNX with no errors"
  artifacts:
    - path: "src/embeddings/piggyback-strategy.ts"
      provides: "PiggybackEmbeddingStrategy implementing the pluggable embedding interface"
      exports: ["PiggybackEmbeddingStrategy"]
    - path: "src/embeddings/hybrid-selector.ts"
      provides: "Strategy selector that picks ONNX or piggyback based on config"
      exports: ["createEmbeddingStrategy", "EmbeddingMode"]
    - path: "src/hooks/piggyback-extractor.ts"
      provides: "Extracts semantic features from Claude's response text during hook processing"
      exports: ["extractSemanticSignals", "SemanticSignal"]
  key_links:
    - from: "src/hooks/piggyback-extractor.ts"
      to: "src/embeddings/piggyback-strategy.ts"
      via: "extracted signals fed to piggyback strategy for embedding generation"
      pattern: "extractSemanticSignals.*PiggybackEmbeddingStrategy"
    - from: "src/embeddings/hybrid-selector.ts"
      to: "src/embeddings/piggyback-strategy.ts"
      via: "selector instantiates piggyback strategy when mode is 'piggyback' or 'hybrid'"
      pattern: "PiggybackEmbeddingStrategy|mode.*piggyback|mode.*hybrid"
---

<objective>
Implement the Claude piggyback embedding strategy that extracts semantic features from Claude's own response content during PostToolUse hook processing, and the hybrid selector that chooses between local ONNX and piggyback strategies at startup.

Purpose: INT-02 and INT-03 require zero-added-latency semantic extraction from Claude's response window. This gives higher-quality embeddings "for free" since the user is already waiting for Claude. The hybrid selector makes the strategy configurable.
Output: Piggyback embedding strategy, semantic signal extractor, hybrid strategy selector.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement semantic signal extractor and piggyback embedding strategy</name>
  <files>src/hooks/piggyback-extractor.ts, src/embeddings/piggyback-strategy.ts</files>
  <action>
**Semantic signal extractor (src/hooks/piggyback-extractor.ts):**

Create a module that processes Claude's response text (available during PostToolUse hook) and extracts semantic signals:

1. Define `SemanticSignal` interface:
   - keywords: string[] (top N significant terms extracted from response)
   - topics: string[] (detected topic labels)
   - sentiment: 'positive' | 'negative' | 'neutral' | 'technical'
   - entities_mentioned: Array<{ name: string, probable_type: string }> (lightweight entity hints for graph)
   - summary_vector: number[] | null (if piggyback embedding is computed)

2. `extractSemanticSignals(responseText: string): SemanticSignal`:
   - Extract keywords using TF-IDF-like scoring (term frequency in response vs common English stop words)
   - Detect topic labels from keyword clusters (simple: group related keywords)
   - Identify entities mentioned: file paths (regex for paths with extensions), decision language ("decided to", "chose", "went with"), tool names (from a known tools list), person names (capitalized words after "by" or "@")
   - This is rule-based extraction, NOT LLM-based. Must be fast (< 10ms) since it runs in the hook path.
   - Do NOT call any external API or model. Pure string/regex processing.

**Piggyback embedding strategy (src/embeddings/piggyback-strategy.ts):**

1. Implement the embedding strategy interface (from Phase 4 -- check src/embeddings/ for the interface pattern. If it doesn't exist yet, define the interface here):
   ```typescript
   interface EmbeddingStrategy {
     embed(text: string): Promise<number[]>;
     embedBatch(texts: string[]): Promise<number[][]>;
     dimensions(): number;
   }
   ```

2. `PiggybackEmbeddingStrategy` class:
   - Constructor accepts config: { fallbackStrategy?: EmbeddingStrategy }
   - `embed(text: string)`: If recent semantic signals exist for this text (cached from last hook call), use them to augment the embedding. Otherwise, fall back to the fallback strategy (local ONNX).
   - The "augmentation" approach: Take the fallback ONNX embedding vector and blend it with keyword-derived features from semantic signals. Use a weighted average: 70% ONNX + 30% keyword features. The keyword features are a sparse vector based on keyword presence/absence in a fixed vocabulary.
   - If no fallback strategy is configured, return a simple keyword-based sparse vector (lower quality but still functional).
   - Cache semantic signals with a TTL of 30 seconds (signals from hook processing are only relevant briefly).
   - `dimensions()`: Returns same dimensions as fallback strategy, or a fixed 384 if no fallback.

3. Export a signal cache that the hook extractor writes to and the strategy reads from:
   ```typescript
   export const signalCache = new Map<string, { signal: SemanticSignal, timestamp: number }>();
   ```
   TTL cleanup on read (lazy eviction).

Error handling: If extraction fails for any reason, return null signal and let the strategy fall back gracefully. Never throw from extractSemanticSignals -- wrap in try/catch and return a minimal empty signal.
  </action>
  <verify>npx tsc --noEmit on both files. Unit test: call extractSemanticSignals with sample Claude response text containing file paths, decision language, and tool names. Verify keywords, entities_mentioned are populated. Verify PiggybackEmbeddingStrategy.embed() returns a vector of correct dimensions.</verify>
  <done>Semantic signals are extracted from Claude response text in < 10ms using rule-based processing. PiggybackEmbeddingStrategy implements the embedding interface with fallback support. Signal cache connects hook extraction to embedding strategy with 30s TTL.</done>
</task>

<task type="auto">
  <name>Task 2: Implement hybrid embedding strategy selector</name>
  <files>src/embeddings/hybrid-selector.ts</files>
  <action>
Create src/embeddings/hybrid-selector.ts that provides startup-time strategy selection:

1. Define `EmbeddingMode` type:
   ```typescript
   export type EmbeddingMode = 'local' | 'piggyback' | 'hybrid';
   ```

2. `createEmbeddingStrategy(mode: EmbeddingMode, config?: { onnxModelPath?: string }): EmbeddingStrategy`:
   - `'local'`: Return the local ONNX strategy (from Phase 4 -- import from src/embeddings/). If Phase 4 module doesn't exist yet, create a placeholder that throws "ONNX strategy not yet implemented" so the type contract is satisfied.
   - `'piggyback'`: Return PiggybackEmbeddingStrategy with no fallback (pure keyword-based).
   - `'hybrid'`: Return PiggybackEmbeddingStrategy with the local ONNX strategy as its fallback. This is the recommended mode -- uses ONNX for baseline quality, augmented with Claude's semantic signals when available.
   - Default mode if not specified: 'hybrid'.

3. Configuration integration:
   - Read mode from environment variable MEMORITE_EMBEDDING_MODE if not passed explicitly.
   - Validate mode string against allowed values. If invalid, warn and default to 'local'.
   - Log which mode was selected (using project's logging pattern if one exists, otherwise console.log with [memorite:embeddings] prefix).

4. Export `getActiveMode(): EmbeddingMode` that returns the currently configured mode (useful for diagnostics).

Do NOT make this a singleton -- the selector is a factory function. The caller manages the instance lifecycle.
  </action>
  <verify>npx tsc --noEmit src/embeddings/hybrid-selector.ts. Test: call createEmbeddingStrategy('hybrid') and verify it returns a PiggybackEmbeddingStrategy instance. Call createEmbeddingStrategy('local') and verify it returns the ONNX strategy (or placeholder). Verify MEMORITE_EMBEDDING_MODE env var is read.</verify>
  <done>Hybrid selector creates the correct embedding strategy based on mode ('local', 'piggyback', 'hybrid'). Environment variable override works. Invalid modes default to 'local' with a warning. Factory function pattern -- no singletons.</done>
</task>

</tasks>

<verification>
- extractSemanticSignals processes a 500-word Claude response in under 10ms
- PiggybackEmbeddingStrategy returns vectors of consistent dimensions regardless of input
- Hybrid selector correctly instantiates all three modes
- Fallback chain works: piggyback -> ONNX -> keyword-only, with no errors at any stage
- Signal cache evicts stale entries after 30 seconds
</verification>

<success_criteria>
Claude's response content is leveraged for higher-quality semantic embeddings at zero added latency. The embedding strategy is selectable at startup via config or environment variable. Graceful degradation ensures the system always produces embeddings even if piggyback data is unavailable.
</success_criteria>

<output>
After completion, create `.planning/phases/07-knowledge-graph-and-advanced-intelligence/07-02-SUMMARY.md`
</output>
