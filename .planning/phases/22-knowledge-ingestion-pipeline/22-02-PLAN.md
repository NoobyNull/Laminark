---
phase: 22-knowledge-ingestion-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - src/mcp/tools/ingest-knowledge.ts
  - src/index.ts
  - commands/map-codebase.md
autonomous: true
requirements:
  - FR-2.1
  - FR-2.2
  - FR-2.3
  - FR-2.4
  - FR-2.5

must_haves:
  truths:
    - "Claude can call ingest_knowledge MCP tool to trigger ingestion of a directory"
    - "ingest_knowledge auto-detects .planning/codebase/ or .laminark/codebase/ when no directory specified"
    - "ingest_knowledge returns stats showing files processed and sections created"
    - "/laminark:map-codebase command instructs Claude to detect GSD, suggest mapping, then ingest"
  artifacts:
    - path: "src/mcp/tools/ingest-knowledge.ts"
      provides: "registerIngestKnowledge function"
      exports: ["registerIngestKnowledge"]
    - path: "commands/map-codebase.md"
      provides: "/laminark:map-codebase slash command"
      contains: "ingest_knowledge"
  key_links:
    - from: "src/mcp/tools/ingest-knowledge.ts"
      to: "src/ingestion/knowledge-ingester.ts"
      via: "KnowledgeIngester import and ingestDirectory call"
      pattern: "KnowledgeIngester.*ingestDirectory"
    - from: "src/index.ts"
      to: "src/mcp/tools/ingest-knowledge.ts"
      via: "registerIngestKnowledge call in tool registration block"
      pattern: "registerIngestKnowledge"
    - from: "src/mcp/tools/ingest-knowledge.ts"
      to: "project_metadata table"
      via: "SQL query to resolve project_path for auto-detection"
      pattern: "SELECT project_path FROM project_metadata"
---

<objective>
Wire the knowledge ingestion pipeline into Laminark's MCP tool interface and create the /laminark:map-codebase slash command.

Purpose: Makes the ingestion pipeline usable -- Claude can call ingest_knowledge to import structured docs, and users can invoke /laminark:map-codebase to trigger the full mapping+ingestion workflow.

Output: MCP tool registration, index.ts wiring, slash command file.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-knowledge-ingestion-pipeline/22-RESEARCH.md
@.planning/phases/22-knowledge-ingestion-pipeline/22-01-SUMMARY.md
@src/mcp/tools/save-memory.ts
@src/index.ts
@commands/remember.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: ingest_knowledge MCP tool</name>
  <files>src/mcp/tools/ingest-knowledge.ts, src/index.ts</files>
  <action>
Create `src/mcp/tools/ingest-knowledge.ts` following the exact pattern from `src/mcp/tools/save-memory.ts`:

1. Export `registerIngestKnowledge` function with same parameter pattern as other tool registrations:
   ```typescript
   export function registerIngestKnowledge(
     server: McpServer,
     db: BetterSqlite3.Database,
     projectHashRef: ProjectHashRef,
     notificationStore: NotificationStore | null = null,
     statusCache: StatusCache | null = null,
   ): void
   ```

2. Register tool `'ingest_knowledge'` with:
   - title: "Ingest Knowledge"
   - description: "Ingest structured markdown documents from a directory into queryable per-project memories. Reads .md files, splits by ## headings, and stores each section as a reference observation. Supports .planning/codebase/ (GSD output) and .laminark/codebase/."
   - inputSchema:
     - `directory`: z.string().optional().describe("Directory containing .md files to ingest. If omitted, auto-detects .planning/codebase/ or .laminark/codebase/ using the project path from project_metadata.")

3. Tool handler implementation:
   - Get projectHash from projectHashRef.current
   - If directory not provided, resolve the project root from the `project_metadata` table:
     ```typescript
     const row = db.prepare(
       'SELECT project_path FROM project_metadata WHERE project_hash = ? ORDER BY last_seen_at DESC LIMIT 1'
     ).get(projectHash) as { project_path: string } | undefined;
     ```
     Then call `KnowledgeIngester.detectKnowledgeDir(row.project_path)` to find the knowledge directory.
     If no project_path found in project_metadata, return an error: "Could not determine project path. Please provide the directory parameter explicitly."
     If detectKnowledgeDir returns null, return an error: "No knowledge directory found. Expected .planning/codebase/ or .laminark/codebase/ in the project root. Run /gsd:map-codebase first or provide a directory path."
   - Create `KnowledgeIngester` instance with db and projectHash
   - Call `ingester.ingestDirectory(resolvedDir)`
   - Return stats as text content: "Ingested {filesProcessed} files: {sectionsCreated} sections created, {sectionsRemoved} stale sections removed."
   - On error, return isError: true with clear message
   - Call `statusCache?.markDirty()` after successful ingestion

4. Wire into `src/index.ts`:
   - Add import: `import { registerIngestKnowledge } from './mcp/tools/ingest-knowledge.js';`
   - Add registration call near other tool registrations (after registerSaveMemory line): `registerIngestKnowledge(server, db.db, projectHashRef, notificationStore, statusCache);`

Important: Follow the same error handling pattern as save-memory.ts (try/catch, return isError on failure). Include notification store prepend pattern if present. Use verboseResponse from tool-verbosity-config.js for response formatting.
  </action>
  <verify>
1. `npx tsc --noEmit` -- no type errors
2. `grep -n "registerIngestKnowledge" src/index.ts` -- shows registration call
3. `grep -n "ingest_knowledge" src/mcp/tools/ingest-knowledge.ts` -- tool name registered
  </verify>
  <done>ingest_knowledge MCP tool registered and wired into server; accepts optional directory path, resolves project root from project_metadata when directory omitted, runs KnowledgeIngester, returns stats</done>
</task>

<task type="auto">
  <name>Task 2: /laminark:map-codebase slash command</name>
  <files>commands/map-codebase.md</files>
  <action>
Create `commands/map-codebase.md` following the exact format from `commands/remember.md`:

The command file should contain:

Title: /laminark:map-codebase
Description: Map and ingest codebase knowledge into Laminark for instant recall.

Usage section: /laminark:map-codebase [directory]

Instructions section that tells Claude to:

1. Check if `.planning/codebase/` exists with .md files in the current project:
   - If YES: Offer to ingest these existing GSD docs directly. If user agrees, call `ingest_knowledge` MCP tool with directory set to the absolute path of `.planning/codebase/`.

2. If no existing docs, check if GSD plugin is available:
   - Look for ~/.claude/commands/ containing gsd-prefixed files, or check if /gsd:map-codebase is a known command
   - If GSD available: Tell user to run `/gsd:map-codebase` first, then come back to ingest. Explain: "GSD will analyze your codebase and produce structured docs. Then I'll ingest them into Laminark for instant recall."
   - If GSD not available: Suggest installing the GSD plugin for codebase mapping, or placing markdown docs in .laminark/codebase/ manually.

3. If a directory argument is provided, call `ingest_knowledge` with that directory path directly.

4. After successful ingestion, confirm with stats: "Ingested X files (Y sections) into Laminark. You can now query this knowledge with /laminark:recall."

Include 3 examples showing: docs found and ingested, directory provided explicitly, no docs found.

Notes section explaining: delegates to GSD (Laminark is knowledge layer not analysis layer), idempotent re-runs, immediately queryable after ingestion, per-project scoping.

Ensure the file uses the same markdown structure and tone as existing commands (remember.md, recall.md, stash.md).
  </action>
  <verify>
1. File exists at commands/map-codebase.md
2. Contains "ingest_knowledge" reference
3. Follows command format: starts with # heading, has Usage, Instructions, Examples, Notes sections
  </verify>
  <done>/laminark:map-codebase slash command created with GSD detection flow, direct ingestion support, and clear user guidance</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- no type errors across the project
2. `npx vitest run src/ingestion/` -- all ingestion tests still pass
3. MCP tool registered: grep for ingest_knowledge in index.ts and tool file
4. Slash command file exists and follows project conventions
</verification>

<success_criteria>
- ingest_knowledge MCP tool callable by Claude with optional directory parameter
- Tool auto-detects knowledge directories via project_metadata project_path lookup
- Tool returns clear stats on ingestion results
- /laminark:map-codebase command guides users through GSD delegation flow
- All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/22-knowledge-ingestion-pipeline/22-02-SUMMARY.md`
</output>
