---
phase: 11-scope-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/tool-registry.ts
  - src/context/injection.ts
  - src/hooks/session-lifecycle.ts
autonomous: true

must_haves:
  truths:
    - "Session start context includes an Available Tools section listing MCP servers, commands, skills, and plugins from the resolved scope"
    - "A tool registered from project A's .mcp.json never appears in session context when working in project B"
    - "Global tools (from ~/.claude.json) appear in every project's session context"
    - "Plugin tools installed globally appear in every project's session context"
    - "Built-in tools (Read, Write, Edit, Bash, etc.) are NOT listed in the tool section -- Claude already knows about them"
    - "If the tool section would exceed the 6000-char context budget, it is dropped entirely before trimming observations"
  artifacts:
    - path: "src/storage/tool-registry.ts"
      provides: "getAvailableForSession() method with scope-correct SQL"
      contains: "getAvailableForSession"
    - path: "src/context/injection.ts"
      provides: "formatToolSection() function and assembleSessionContext with toolRegistry parameter"
      contains: "formatToolSection"
    - path: "src/hooks/session-lifecycle.ts"
      provides: "toolRegistry passed through to assembleSessionContext"
      contains: "assembleSessionContext(db, projectHash, toolRegistry)"
  key_links:
    - from: "src/hooks/session-lifecycle.ts"
      to: "src/context/injection.ts"
      via: "assembleSessionContext(db, projectHash, toolRegistry)"
      pattern: "assembleSessionContext\\(.*toolRegistry"
    - from: "src/context/injection.ts"
      to: "src/storage/tool-registry.ts"
      via: "toolRegistry.getAvailableForSession(projectHash)"
      pattern: "getAvailableForSession"
    - from: "src/storage/tool-registry.ts"
      to: "tool_registry SQL table"
      via: "WHERE scope = 'global' OR (scope = 'project' AND project_hash = ?) OR (scope = 'plugin' AND ...)"
      pattern: "scope = 'global'"
---

<objective>
Add scope-filtered tool querying and session context tool surfacing so that Claude sees only the tools available in the current project's resolved scope at session start.

Purpose: Completes SCOP-01 (scope classification), SCOP-02 (session context filtering), SCOP-03 (cross-project isolation), and SCOP-04 (prefix parsing -- already done, verified here). This is the core deliverable of Phase 11.

Output: Modified tool-registry.ts with getAvailableForSession(), modified injection.ts with formatToolSection() and updated assembleSessionContext(), modified session-lifecycle.ts to thread toolRegistry into context assembly.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-scope-resolution/11-RESEARCH.md
@.planning/phases/10-tool-discovery-registry/10-02-SUMMARY.md

@src/storage/tool-registry.ts
@src/context/injection.ts
@src/hooks/session-lifecycle.ts
@src/shared/tool-types.ts
@src/hooks/tool-name-parser.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getAvailableForSession() to ToolRegistryRepository</name>
  <files>src/storage/tool-registry.ts</files>
  <action>
Add a new prepared statement `stmtGetAvailableForSession` and corresponding `getAvailableForSession(projectHash: string)` method to `ToolRegistryRepository`.

**Prepared statement SQL:**
```sql
SELECT * FROM tool_registry
WHERE
  scope = 'global'
  OR (scope = 'project' AND project_hash = ?)
  OR (scope = 'plugin' AND (project_hash IS NULL OR project_hash = ?))
ORDER BY
  CASE tool_type
    WHEN 'mcp_server' THEN 0
    WHEN 'slash_command' THEN 1
    WHEN 'skill' THEN 2
    WHEN 'plugin' THEN 3
    ELSE 4
  END,
  usage_count DESC,
  discovered_at DESC
```

This query implements correct scope resolution:
- `scope = 'global'`: Always included (built-in tools, global MCP servers, global commands/skills)
- `scope = 'project' AND project_hash = ?`: Only included when project_hash matches current project (SCOP-03: prevents cross-project leakage)
- `scope = 'plugin' AND (project_hash IS NULL OR project_hash = ?)`: Globally installed plugins (NULL project_hash) always included; project-scoped plugins only when project matches

The query takes TWO bind parameters -- both are the same `projectHash` value (one for the project scope condition, one for the plugin scope condition).

**Implementation steps:**
1. Add `private readonly stmtGetAvailableForSession: BetterSqlite3.Statement;` to the class field declarations (after `stmtCount`)
2. In the constructor's try block, add `this.stmtGetAvailableForSession = db.prepare(...)` with the SQL above
3. Add the method:
```typescript
/**
 * Returns tools available in the resolved scope for a given project.
 * Implements SCOP-01/SCOP-02/SCOP-03 scope resolution rules.
 */
getAvailableForSession(projectHash: string): ToolRegistryRow[] {
  return this.stmtGetAvailableForSession.all(projectHash, projectHash) as ToolRegistryRow[];
}
```

**Do NOT modify the existing `getForProject()` method** -- it may be used elsewhere and changing it could break existing callers. The new method coexists with it.

**Do NOT add `scope = excluded.scope` to the upsert's ON CONFLICT clause.** The current behavior (scope preserved from first insert) is intentional -- config scanning's authoritative scope must not be overwritten by organic discovery's conservative inference.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify the new method exists:
```bash
grep -n "getAvailableForSession" src/storage/tool-registry.ts
```
Expect at least 3 matches: field declaration, prepare call, method definition.
  </verify>
  <done>
ToolRegistryRepository has a getAvailableForSession(projectHash) method that returns scope-filtered rows using explicit per-scope SQL conditions. The method accepts one projectHash argument and binds it twice in the query.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add formatToolSection() and wire tools into session context assembly</name>
  <files>src/context/injection.ts, src/hooks/session-lifecycle.ts</files>
  <action>
Two files to modify. Read both before editing.

**Part A: src/context/injection.ts**

1. Add imports at the top of the file:
```typescript
import type { ToolRegistryRepository } from '../storage/tool-registry.js';
import type { ToolRegistryRow } from '../shared/tool-types.js';
```

2. Add a constant after `OBSERVATION_CONTENT_LIMIT`:
```typescript
/**
 * Maximum number of tools to show in the context section.
 * Keeps the tool section compact to preserve budget for observations.
 */
const MAX_TOOLS_IN_CONTEXT = 10;
```

3. Add the `formatToolSection` function (NOT exported -- internal to this module):
```typescript
/**
 * Formats available tools as a compact section for session context.
 *
 * Deduplicates MCP servers vs individual MCP tools (prefers server entries).
 * Excludes built-in tools (Claude already knows Read, Write, Edit, Bash, etc.).
 * Limits to MAX_TOOLS_IN_CONTEXT entries to preserve context budget.
 */
function formatToolSection(tools: ToolRegistryRow[]): string {
  if (tools.length === 0) return '';

  // Deduplicate: prefer mcp_server entries over individual mcp_tool entries
  const seenServers = new Set<string>();
  const deduped: ToolRegistryRow[] = [];

  // First pass: collect server-level entries
  for (const tool of tools) {
    if (tool.tool_type === 'mcp_server') {
      seenServers.add(tool.server_name ?? tool.name);
      deduped.push(tool);
    }
  }
  // Second pass: add non-server entries, skipping individual tools from listed servers
  for (const tool of tools) {
    if (tool.tool_type !== 'mcp_server') {
      if (tool.tool_type === 'mcp_tool' && tool.server_name && seenServers.has(tool.server_name)) {
        continue;
      }
      deduped.push(tool);
    }
  }

  // Exclude built-in tools -- Claude already knows about them
  const displayable = deduped.filter(t => t.tool_type !== 'builtin');

  if (displayable.length === 0) return '';

  const limited = displayable.slice(0, MAX_TOOLS_IN_CONTEXT);
  const lines: string[] = ['## Available Tools'];

  for (const tool of limited) {
    const scopeTag = tool.scope === 'project' ? 'project' : 'global';
    const usageStr = tool.usage_count > 0 ? `, ${tool.usage_count}x` : '';

    if (tool.tool_type === 'mcp_server') {
      lines.push(`- MCP: ${tool.server_name ?? tool.name} (${scopeTag}${usageStr})`);
    } else if (tool.tool_type === 'slash_command') {
      lines.push(`- ${tool.name} (${scopeTag}${usageStr})`);
    } else if (tool.tool_type === 'skill') {
      const desc = tool.description ? ` - ${tool.description}` : '';
      lines.push(`- skill: ${tool.name} (${scopeTag})${desc}`);
    } else if (tool.tool_type === 'plugin') {
      lines.push(`- plugin: ${tool.name} (${scopeTag})`);
    } else {
      lines.push(`- ${tool.name} (${scopeTag}${usageStr})`);
    }
  }

  if (displayable.length > MAX_TOOLS_IN_CONTEXT) {
    lines.push(`(${displayable.length - MAX_TOOLS_IN_CONTEXT} more available)`);
  }

  return lines.join('\n');
}
```

4. Modify `assembleSessionContext` to accept an optional `toolRegistry` parameter and include the tool section:

Change the function signature from:
```typescript
export function assembleSessionContext(
  db: BetterSqlite3.Database,
  projectHash: string,
): string {
```
To:
```typescript
export function assembleSessionContext(
  db: BetterSqlite3.Database,
  projectHash: string,
  toolRegistry?: ToolRegistryRepository,
): string {
```

After the line `const references = getRecentByKind(...)`, add:
```typescript
  // SCOP-02: Query scope-filtered tools for this session
  let toolSection = '';
  if (toolRegistry) {
    try {
      const availableTools = toolRegistry.getAvailableForSession(projectHash);
      toolSection = formatToolSection(availableTools);
    } catch {
      // Tool registry is supplementary -- never block context assembly
    }
  }
```

After assembling the initial context with `formatContextIndex`, before the existing budget trimming logic, modify the context to append the tool section:
```typescript
  // Append tool section after observations (lower priority for budget)
  if (toolSection) {
    context = context + '\n\n' + toolSection;
  }
```

Then modify the budget trimming to drop the tool section FIRST before trimming observations. Insert this block at the start of the existing `if (context.length > MAX_CONTEXT_CHARS)` block, before the reference/findings/changes trimming loops:
```typescript
  if (context.length > MAX_CONTEXT_CHARS) {
    // Drop tool section first (lowest priority)
    if (toolSection) {
      context = formatContextIndex(lastSession, { changes, decisions, findings, references });
      toolSection = ''; // Mark as dropped so we don't re-add
    }
  }
```

Keep the existing progressive trimming loops after this new block, but make them each a separate `if (context.length > MAX_CONTEXT_CHARS)` check so they only trigger if still over budget after tool section removal.

**Part B: src/hooks/session-lifecycle.ts**

The `handleSessionStart` function already accepts `toolRegistry?: ToolRegistryRepository` as a parameter. Currently it calls `assembleSessionContext(db, projectHash)` without passing toolRegistry.

Change the line:
```typescript
const context = assembleSessionContext(db, projectHash);
```
To:
```typescript
const context = assembleSessionContext(db, projectHash, toolRegistry);
```

This is a one-line change. The `toolRegistry` is already available as a function parameter (added in Phase 10-02). The `assembleSessionContext` import is already present.

**Do NOT modify `formatContextIndex`'s signature.** The tool section is appended AFTER `formatContextIndex` returns, keeping it as a separate concern.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors.

Verify formatToolSection exists:
```bash
grep -n "formatToolSection" src/context/injection.ts
```

Verify assembleSessionContext has toolRegistry parameter:
```bash
grep -n "toolRegistry" src/context/injection.ts
```

Verify session-lifecycle passes toolRegistry:
```bash
grep -n "assembleSessionContext" src/hooks/session-lifecycle.ts
```
Should show `assembleSessionContext(db, projectHash, toolRegistry)`.

Run the existing test suite to ensure no regressions:
```bash
npx vitest run src/hooks/__tests__/session-lifecycle.test.ts
npx vitest run src/context/
```
  </verify>
  <done>
Session start context includes a "## Available Tools" section showing scope-filtered MCP servers, commands, skills, and plugins. Built-in tools are excluded. The tool section is dropped before observations when the context budget is tight. The toolRegistry flows from handleSessionStart through to assembleSessionContext.
  </done>
</task>

</tasks>

<verification>
1. **Scope isolation (SCOP-03):** Register a tool with `scope='project', project_hash='hash-a'`. Call `getAvailableForSession('hash-b')`. The tool MUST NOT appear. Call `getAvailableForSession('hash-a')`. The tool MUST appear.

2. **Global inclusion (SCOP-01):** Register a tool with `scope='global'`. Call `getAvailableForSession` with any projectHash. The tool MUST appear.

3. **Plugin resolution:** Register a plugin tool with `scope='plugin', project_hash=NULL`. Call `getAvailableForSession` with any projectHash. The tool MUST appear (globally installed plugin).

4. **Built-in exclusion:** Verify the formatted tool section does NOT contain "Read", "Write", "Edit", "Bash" even when they exist in the registry with `tool_type='builtin'`.

5. **Budget trimming:** With a large tool section + observations exceeding 6000 chars, verify the tool section is dropped before observations are trimmed.

6. **TypeScript compilation:** `npx tsc --noEmit` passes with zero errors.

7. **Existing tests pass:** `npx vitest run` shows no regressions.
</verification>

<success_criteria>
- `getAvailableForSession(projectHash)` returns correct scope-filtered results
- Session context output includes "## Available Tools" section when tools exist in registry
- Project-scoped tools from project A never appear in project B's context
- Global and globally-installed plugin tools appear for all projects
- Built-in tools are excluded from the tool section display
- Tool section is trimmed first when context budget is exceeded
- All existing tests pass without modification
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-scope-resolution/11-01-SUMMARY.md`
</output>
