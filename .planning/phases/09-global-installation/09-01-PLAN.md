---
phase: 09-global-installation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/hooks/self-referential.ts
  - src/hooks/handler.ts
  - src/hooks/capture.ts
  - src/hooks/admission-filter.ts
  - tests/hooks/self-referential.test.ts
autonomous: true

must_haves:
  truths:
    - "Laminark self-referential filter rejects tool calls with the project-scoped prefix mcp__laminark__"
    - "Laminark self-referential filter rejects tool calls with the plugin-scoped prefix mcp__plugin_laminark_laminark__"
    - "Non-Laminark tool calls pass through both filters unchanged"
  artifacts:
    - path: "src/hooks/self-referential.ts"
      provides: "Centralized dual-prefix detection utility"
      exports: ["isLaminarksOwnTool", "LAMINARK_PREFIXES"]
    - path: "tests/hooks/self-referential.test.ts"
      provides: "Unit tests for both prefix patterns"
      contains: "isLaminarksOwnTool"
  key_links:
    - from: "src/hooks/handler.ts"
      to: "src/hooks/self-referential.ts"
      via: "import isLaminarksOwnTool"
      pattern: "isLaminarksOwnTool\\(toolName\\)"
    - from: "src/hooks/admission-filter.ts"
      to: "src/hooks/self-referential.ts"
      via: "import isLaminarksOwnTool"
      pattern: "isLaminarksOwnTool\\(toolName\\)"
    - from: "src/hooks/capture.ts"
      to: "src/hooks/self-referential.ts"
      via: "import isLaminarksOwnTool"
      pattern: "isLaminarksOwnTool\\(toolName\\)"
---

<objective>
Create a centralized dual-prefix self-referential filter that detects Laminark's own MCP tool calls under both the project-scoped prefix (`mcp__laminark__`) and the plugin-scoped prefix (`mcp__plugin_laminark_laminark__`), preventing feedback loops when Laminark is installed as a global plugin.

Purpose: When installed as a Claude Code plugin, Laminark's MCP tools appear with a different prefix (`mcp__plugin_laminark_laminark__` instead of `mcp__laminark__`). Without dual-prefix detection, Laminark would capture its own tool calls as observations, creating an infinite feedback loop. This is the most critical correctness requirement for the global installation migration (GLOB-04).

Output: `src/hooks/self-referential.ts` with `isLaminarksOwnTool()` function, updated handler.ts/capture.ts/admission-filter.ts to use it, and passing unit tests covering both prefix patterns.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/hooks/handler.ts
@src/hooks/capture.ts
@src/hooks/admission-filter.ts
</context>

<feature>
  <name>Dual-prefix self-referential tool detection</name>
  <files>src/hooks/self-referential.ts, tests/hooks/self-referential.test.ts, src/hooks/handler.ts, src/hooks/capture.ts, src/hooks/admission-filter.ts</files>
  <behavior>
    `isLaminarksOwnTool(toolName)` returns true/false based on whether the tool name belongs to Laminark.

    Cases:
    - isLaminarksOwnTool("mcp__laminark__recall") -> true
    - isLaminarksOwnTool("mcp__laminark__save_memory") -> true
    - isLaminarksOwnTool("mcp__laminark__query_graph") -> true
    - isLaminarksOwnTool("mcp__plugin_laminark_laminark__recall") -> true
    - isLaminarksOwnTool("mcp__plugin_laminark_laminark__save_memory") -> true
    - isLaminarksOwnTool("mcp__plugin_laminark_laminark__query_graph") -> true
    - isLaminarksOwnTool("Write") -> false
    - isLaminarksOwnTool("Bash") -> false
    - isLaminarksOwnTool("mcp__other_server__tool") -> false
    - isLaminarksOwnTool("") -> false

    After refactoring, handler.ts, capture.ts, and admission-filter.ts all use the shared function instead of inline prefix checks. Build succeeds with no type errors.
  </behavior>
  <implementation>
    1. Create `src/hooks/self-referential.ts`:
       - Export `LAMINARK_PREFIXES` as a readonly array containing `'mcp__laminark__'` and `'mcp__plugin_laminark_laminark__'`
       - Export `isLaminarksOwnTool(toolName: string): boolean` that checks if toolName starts with any prefix in the array

    2. Update `src/hooks/handler.ts` (line 70):
       - Replace `if (toolName.startsWith('mcp__laminark__'))` with `if (isLaminarksOwnTool(toolName))`
       - Add import: `import { isLaminarksOwnTool } from './self-referential.js'`
       - Update the JSDoc comment at the top (line 28) to reflect dual-prefix support instead of just `mcp__laminark__`

    3. Update `src/hooks/capture.ts` (line 96):
       - Replace `if (toolName.startsWith('mcp__laminark__'))` with `if (isLaminarksOwnTool(toolName))`
       - Add import: `import { isLaminarksOwnTool } from './self-referential.js'`

    4. Update `src/hooks/admission-filter.ts` (line 98):
       - Remove the `LAMINARK_MCP_PREFIX` constant
       - Replace `if (toolName.startsWith(LAMINARK_MCP_PREFIX))` (line 139) with `if (isLaminarksOwnTool(toolName))`
       - Add import: `import { isLaminarksOwnTool } from './self-referential.js'`
  </implementation>
</feature>

<verification>
1. `npx vitest run tests/hooks/self-referential.test.ts` -- all tests pass
2. `npx tsc --noEmit` -- no type errors
3. `npm run build` -- build succeeds (dist/ updated)
</verification>

<success_criteria>
- `isLaminarksOwnTool()` correctly identifies both `mcp__laminark__*` and `mcp__plugin_laminark_laminark__*` tool names
- `isLaminarksOwnTool()` correctly rejects non-Laminark tool names (Write, Bash, other MCP servers)
- handler.ts, capture.ts, and admission-filter.ts all import and use the shared function (no more inline prefix checks)
- No hardcoded `'mcp__laminark__'` string literals remain in handler.ts, capture.ts, or admission-filter.ts (the constant lives only in self-referential.ts)
- Build and type check pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-global-installation/09-01-SUMMARY.md`
</output>
