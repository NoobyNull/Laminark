---
phase: 14-conversation-routing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/routing/types.ts
  - src/routing/heuristic-fallback.ts
autonomous: true

must_haves:
  truths:
    - "Routing types define the shape of suggestions, config, and state used by both tiers"
    - "Heuristic fallback produces a suggestion from tool descriptions/names when given recent observations and available tools"
    - "Heuristic returns null when no tool matches above confidence threshold"
    - "Heuristic works with zero usage history (cold start)"
  artifacts:
    - path: "src/routing/types.ts"
      provides: "RoutingSuggestion, RoutingConfig, RoutingState, ToolPattern interfaces and config defaults"
      exports: ["RoutingSuggestion", "RoutingConfig", "RoutingState", "ToolPattern", "DEFAULT_ROUTING_CONFIG"]
    - path: "src/routing/heuristic-fallback.ts"
      provides: "Keyword-based cold-start routing from observations to tools"
      exports: ["evaluateHeuristic", "extractKeywords", "extractToolKeywords"]
  key_links:
    - from: "src/routing/heuristic-fallback.ts"
      to: "src/routing/types.ts"
      via: "imports RoutingSuggestion, RoutingConfig"
      pattern: "import.*RoutingSuggestion.*from.*types"
    - from: "src/routing/heuristic-fallback.ts"
      to: "src/shared/tool-types.ts"
      via: "imports ToolRegistryRow for tool descriptions"
      pattern: "import.*ToolRegistryRow.*from.*tool-types"
---

<objective>
Create routing foundation types and heuristic fallback algorithm for cold-start tool suggestions.

Purpose: Establishes the type contracts for the entire routing system and implements the keyword-based heuristic tier (ROUT-04) that provides tool suggestions without any accumulated usage history. This is the cold-start path that works from day one.

Output: Two new files in `src/routing/` providing types and the heuristic matching algorithm.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-conversation-routing/14-RESEARCH.md

@src/shared/tool-types.ts
@src/hooks/tool-name-parser.ts
@src/hooks/self-referential.ts
@src/storage/notifications.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create routing types and configuration defaults</name>
  <files>src/routing/types.ts</files>
  <action>
Create `src/routing/types.ts` with the following interfaces and constants:

**RoutingSuggestion** interface:
- `toolName: string` -- the suggested tool name
- `toolDescription: string | null` -- optional description for display
- `confidence: number` -- 0.0 to 1.0 score
- `tier: 'heuristic' | 'learned'` -- which routing tier produced this
- `reason: string` -- human-readable explanation for the suggestion

**RoutingConfig** interface:
- `confidenceThreshold: number` -- minimum confidence to emit (default 0.6)
- `maxSuggestionsPerSession: number` -- rate limit per session (default 2)
- `minEventsForLearned: number` -- minimum tool_usage_events before learned patterns activate (default 20)
- `suggestionCooldown: number` -- minimum tool calls between suggestions (default 5)
- `minCallsBeforeFirstSuggestion: number` -- minimum calls before any suggestion (default 3)
- `patternWindowSize: number` -- sliding window for learned patterns (default 5)

**RoutingState** interface (mirrors routing_state table shape):
- `sessionId: string`
- `projectHash: string`
- `suggestionsMade: number`
- `lastSuggestionAt: string | null`
- `toolCallsSinceSuggestion: number`

**ToolPattern** interface (for learned pattern data):
- `targetTool: string` -- the tool that was eventually used
- `precedingTools: string[]` -- tools used in the N calls before
- `frequency: number` -- how many times this pattern occurred

Export a `DEFAULT_ROUTING_CONFIG` constant with the default values listed above.

Follow existing codebase conventions: JSDoc comments on each interface and export, no Zod validation (types only -- validated at usage site if needed).
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors in the new file.
Run `ls src/routing/types.ts` -- file exists.
  </verify>
  <done>
All 4 interfaces and the DEFAULT_ROUTING_CONFIG constant are exported. Types compile cleanly. No runtime dependencies (pure type definitions + one const).
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement heuristic fallback keyword matching (ROUT-04)</name>
  <files>src/routing/heuristic-fallback.ts</files>
  <action>
Create `src/routing/heuristic-fallback.ts` implementing the cold-start heuristic tier.

**extractKeywords(text: string): string[]** -- Tokenizes text into lowercase keywords:
- Replace non-alphanumeric chars (except hyphens/underscores) with spaces
- Split on whitespace
- Filter words shorter than 3 chars
- Filter stop words (use the STOP_WORDS set from the research: the, a, an, is, are, was, were, be, been, being, have, has, had, do, does, did, will, would, could, should, may, might, can, shall, to, of, in, for, on, with, at, by, from, as, into, through, and, but, or, nor, not, so, yet, this, that, these, those, it, its)
- Return unique keywords

**extractToolKeywords(tool: ToolRegistryRow): string[]** -- Extracts keywords from a tool's description, server name, and parsed name:
- If tool has `description`: extract keywords from it
- If tool has `server_name`: add it as a keyword (lowercase)
- If `tool_type === 'slash_command'`: parse the command path into keywords by splitting on `:`, `-`, `_` (e.g., "/gsd:plan-phase" -> ["gsd", "plan", "phase"])
- If `tool_type === 'skill'`: split name on `-` and `_` into keywords
- Return deduplicated array

**evaluateHeuristic(recentObservations: string[], suggestableTools: ToolRegistryRow[], confidenceThreshold: number): RoutingSuggestion | null** -- The main entry point:
- If `recentObservations.length < 2`: return null (too early to judge)
- Build a Set of context keywords from all recent observations via `extractKeywords`
- For each suggestable tool, compute `extractToolKeywords(tool)`, calculate match score = matchCount / toolKeywords.length
- Track the best match (highest score)
- If best match score >= confidenceThreshold: return RoutingSuggestion with tier 'heuristic'
- Otherwise return null

Import ToolRegistryRow from `../shared/tool-types.js`. Import RoutingSuggestion from `./types.js`.

Do NOT use the observations table directly here -- the function accepts `recentObservations: string[]` as pre-fetched data. The caller (ConversationRouter in plan 02) handles the database query.

This keeps the heuristic pure and testable without a database dependency.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors.
Run `npx vitest run src/routing/ --reporter=verbose 2>/dev/null || echo "No tests yet (tests will be added if needed in plan 02)"` -- confirms file is importable.
  </verify>
  <done>
Three exported functions (extractKeywords, extractToolKeywords, evaluateHeuristic) implement the cold-start heuristic. Functions are pure (no DB dependency), accept pre-fetched data, and return RoutingSuggestion | null. Confidence gating is applied at the threshold parameter.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `src/routing/types.ts` exports RoutingSuggestion, RoutingConfig, RoutingState, ToolPattern, DEFAULT_ROUTING_CONFIG
3. `src/routing/heuristic-fallback.ts` exports evaluateHeuristic, extractKeywords, extractToolKeywords
4. Heuristic function is pure (no database imports, no side effects)
</verification>

<success_criteria>
- Routing type contracts are established for both tiers
- Cold-start heuristic algorithm is implemented and compilable
- No new dependencies added
- Files follow existing codebase conventions (JSDoc, .js import extensions, barrel-free)
</success_criteria>

<output>
After completion, create `.planning/phases/14-conversation-routing/14-01-SUMMARY.md`
</output>
