---
phase: 14-conversation-routing
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/routing/intent-patterns.ts
  - src/routing/conversation-router.ts
  - src/hooks/handler.ts
  - src/hooks/session-lifecycle.ts
autonomous: true

must_haves:
  truths:
    - "When the current session's tool sequence matches a historical pattern, a suggestion is surfaced via NotificationStore"
    - "Suggestions are never emitted when confidence is below threshold (ROUT-03)"
    - "Rate limiting prevents more than 2 suggestions per session and enforces cooldown between suggestions"
    - "Routing runs AFTER the self-referential filter in PostToolUse -- never evaluates Laminark's own tools"
    - "At SessionStart, tool sequence patterns are pre-computed from historical data and stored for cheap PostToolUse lookup"
    - "Built-in tools and Laminark's own tools are excluded from suggestion candidates"
    - "Routing state persists across handler invocations via SQLite routing_state table"
  artifacts:
    - path: "src/routing/intent-patterns.ts"
      provides: "Learned pattern extraction from tool_usage_events and sequence overlap scoring"
      exports: ["extractPatterns", "evaluateLearnedPatterns", "computeSequenceOverlap"]
    - path: "src/routing/conversation-router.ts"
      provides: "ConversationRouter orchestrating both tiers with state management and notification delivery"
      exports: ["ConversationRouter"]
    - path: "src/hooks/handler.ts"
      provides: "PostToolUse routing evaluation step after observation storage"
      contains: "evaluateRouting"
    - path: "src/hooks/session-lifecycle.ts"
      provides: "SessionStart pattern pre-computation step"
      contains: "precomputeRoutingPatterns"
  key_links:
    - from: "src/routing/conversation-router.ts"
      to: "src/storage/notifications.ts"
      via: "NotificationStore.add() for suggestion delivery"
      pattern: "notificationStore\\.add"
    - from: "src/routing/conversation-router.ts"
      to: "src/routing/heuristic-fallback.ts"
      via: "evaluateHeuristic() for cold-start tier"
      pattern: "evaluateHeuristic"
    - from: "src/routing/conversation-router.ts"
      to: "src/routing/intent-patterns.ts"
      via: "evaluateLearnedPatterns() for historical pattern tier"
      pattern: "evaluateLearnedPatterns"
    - from: "src/hooks/handler.ts"
      to: "src/routing/conversation-router.ts"
      via: "ConversationRouter instantiation and evaluate() call in PostToolUse"
      pattern: "ConversationRouter"
    - from: "src/hooks/session-lifecycle.ts"
      to: "src/routing/intent-patterns.ts"
      via: "extractPatterns() call at SessionStart for pre-computation"
      pattern: "extractPatterns"
---

<objective>
Implement learned pattern matching, the ConversationRouter orchestrator, and wire routing into the handler and session lifecycle.

Purpose: Completes the routing system by adding learned patterns (ROUT-01), the central router with confidence gating (ROUT-03), notification delivery (ROUT-02), and integrating into the existing hook pipeline. After this plan, Laminark proactively suggests tools based on conversation context.

Output: Two new routing files and modifications to handler.ts and session-lifecycle.ts.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-conversation-routing/14-RESEARCH.md
@.planning/phases/14-conversation-routing/14-01-SUMMARY.md

@src/routing/types.ts
@src/routing/heuristic-fallback.ts
@src/hooks/handler.ts
@src/hooks/session-lifecycle.ts
@src/storage/notifications.ts
@src/storage/tool-registry.ts
@src/hooks/self-referential.ts
@src/hooks/tool-name-parser.ts
@src/shared/tool-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement learned pattern extraction and sequence matching</name>
  <files>src/routing/intent-patterns.ts</files>
  <action>
Create `src/routing/intent-patterns.ts` with three exported functions:

**extractPatterns(db: BetterSqlite3.Database, projectHash: string, windowSize: number = 5): ToolPattern[]**

Extracts tool sequence patterns from `tool_usage_events`. This runs at SessionStart and stores results in `routing_patterns` table.

Implementation:
1. Query `tool_usage_events` for the project, ordered by session_id then created_at (success=1 only)
2. Group events by session_id into arrays of tool_name strings
3. For each session's tool sequence, slide a window of `windowSize` preceding tools before each target tool
4. Skip targets where `inferToolType(target) === 'builtin'` or `isLaminarksOwnTool(target)` -- we never suggest those
5. Aggregate identical patterns (same target + same preceding tools sequence) and count frequency
6. Filter to patterns with frequency >= 2 (appeared at least twice)
7. Sort by frequency descending
8. Return as ToolPattern[]

Import `inferToolType` from `../hooks/tool-name-parser.js`. Import `isLaminarksOwnTool` from `../hooks/self-referential.js`. Import `ToolPattern` from `./types.js`.

**storePrecomputedPatterns(db: BetterSqlite3.Database, projectHash: string, patterns: ToolPattern[]): void**

Creates the `routing_patterns` table inline (CREATE TABLE IF NOT EXISTS), deletes old patterns for this project, and inserts the new ones. The table schema:

```sql
CREATE TABLE IF NOT EXISTS routing_patterns (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  project_hash TEXT NOT NULL,
  target_tool TEXT NOT NULL,
  preceding_tools TEXT NOT NULL,  -- JSON array of tool names
  frequency INTEGER NOT NULL,
  computed_at TEXT NOT NULL DEFAULT (datetime('now'))
);
CREATE INDEX IF NOT EXISTS idx_routing_patterns_project ON routing_patterns(project_hash);
```

Uses a transaction: DELETE all rows for projectHash, then INSERT each pattern with `JSON.stringify(pattern.precedingTools)` for the preceding_tools column.

**evaluateLearnedPatterns(db: BetterSqlite3.Database, sessionId: string, projectHash: string, suggestableToolNames: Set<string>, confidenceThreshold: number): RoutingSuggestion | null**

Evaluates the current session's recent tool sequence against pre-computed patterns:
1. Query current session's recent tool names from `tool_usage_events` (last 10 events, ordered by created_at DESC)
2. Query `routing_patterns` for this project
3. For each pattern, compute overlap using `computeSequenceOverlap(currentTools, pattern.precedingTools)`
4. Only consider patterns whose `targetTool` is in the `suggestableToolNames` set (availability gate)
5. Track best match
6. If best match confidence >= confidenceThreshold: return RoutingSuggestion with tier 'learned' and reason including frequency count
7. Otherwise return null

**computeSequenceOverlap(currentTools: string[], patternTools: string[]): number** (exported for testability)

Computes Jaccard-like overlap between the current session's recent tool set and the pattern's preceding tools set:
- `current = new Set(currentTools.slice(-patternTools.length))`
- `pattern = new Set(patternTools)`
- `matches = count of items in pattern that exist in current`
- Return `matches / pattern.size`

All database queries use `db.prepare(...).all(...)` pattern consistent with the codebase.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors.
Verify file exports: `node -e "import('./dist/routing/intent-patterns.js').then(m => console.log(Object.keys(m)))"` (after build) OR just `npx tsc --noEmit`.
  </verify>
  <done>
Pattern extraction scans tool_usage_events for recurring tool sequences. Pre-computed patterns are stored in a transient SQLite table. Evaluation compares current session tools against stored patterns with availability filtering and confidence gating.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ConversationRouter and wire into handler/session lifecycle</name>
  <files>src/routing/conversation-router.ts, src/hooks/handler.ts, src/hooks/session-lifecycle.ts</files>
  <action>
**Part A: Create `src/routing/conversation-router.ts`**

The ConversationRouter is the main orchestrator. It is instantiated per-evaluation (no long-lived state -- handler is short-lived CLI process).

Constructor: `constructor(db: BetterSqlite3.Database, projectHash: string, config?: Partial<RoutingConfig>)`
- Merges provided config with DEFAULT_ROUTING_CONFIG
- Creates `routing_state` table inline (CREATE TABLE IF NOT EXISTS) with this schema:
```sql
CREATE TABLE IF NOT EXISTS routing_state (
  session_id TEXT NOT NULL,
  project_hash TEXT NOT NULL,
  suggestions_made INTEGER NOT NULL DEFAULT 0,
  last_suggestion_at TEXT,
  tool_calls_since_suggestion INTEGER NOT NULL DEFAULT 0,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  PRIMARY KEY (session_id, project_hash)
);
```

**evaluate(sessionId: string, toolName: string, toolRegistry: ToolRegistryRepository): void**

The main evaluation method, called from PostToolUse handler after observation storage:

1. Skip built-in tools: `if (inferToolType(toolName) === 'builtin') return`
2. Skip Laminark's own tools: `if (isLaminarksOwnTool(toolName)) return`
3. Load or create routing state for this session (upsert into routing_state table)
4. Increment `tool_calls_since_suggestion` and update state
5. Check rate limits -- return early if:
   - `suggestions_made >= config.maxSuggestionsPerSession`
   - `tool_calls_since_suggestion < config.suggestionCooldown`
   - Total tool calls this session < `config.minCallsBeforeFirstSuggestion` (query count from routing_state or tool_usage_events)
6. Get available tools: `toolRegistry.getAvailableForSession(projectHash)`
7. Filter to suggestable: exclude `tool_type === 'builtin'` and `isLaminarksOwnTool(name)`
8. If no suggestable tools: return
9. Check if enough historical data for learned patterns:
   - Count recent events: `SELECT COUNT(*) FROM tool_usage_events WHERE project_hash = ?`
   - If count >= `config.minEventsForLearned`: call `evaluateLearnedPatterns(db, sessionId, projectHash, suggestableNames, config.confidenceThreshold)`
10. If no learned suggestion: call `evaluateHeuristic(recentObservations, suggestableTools, config.confidenceThreshold)`
    - For recentObservations: query `SELECT content FROM observations WHERE project_hash = ? AND session_id = ? AND deleted_at IS NULL ORDER BY created_at DESC LIMIT 5`
11. If no suggestion from either tier: return
12. Confidence gate: if `suggestion.confidence < config.confidenceThreshold`: return
13. Deliver via NotificationStore:
    - `const notifStore = new NotificationStore(db)`
    - Format message: `"Tool suggestion: {toolName}{description}{usageHint}"` where description is ` -- {desc}` if available, usageHint is ` (used Nx in similar contexts)` if from learned tier
    - `notifStore.add(projectHash, message)`
14. Update routing state: increment suggestions_made, set last_suggestion_at, reset tool_calls_since_suggestion to 0

Wrap the entire evaluate method body in try/catch. Routing is supplementary -- NEVER block or fail the handler. Log via `debug('routing', ...)`.

**Part B: Modify `src/hooks/handler.ts`**

Add routing evaluation as Step 4 in the PostToolUse pipeline (AFTER observation storage, step 8 currently).

In `processPostToolUseFiltered`, after the final `obsRepo.create(...)` call (current step 8), add:

```typescript
// 9. ROUT-01/02/03/04: Routing evaluation (suggest tools based on conversation context)
// Runs AFTER observation storage and self-referential filter
if (toolRegistry && projectHash) {
  try {
    const sessionId = input.session_id as string | undefined;
    if (sessionId) {
      const router = new ConversationRouter(obsRepo['db'] ?? /* get db ref */, projectHash);
      router.evaluate(sessionId, toolName, toolRegistry);
    }
  } catch {
    // Routing is supplementary -- never block core pipeline
  }
}
```

IMPORTANT: The `processPostToolUseFiltered` function does not currently receive the raw `db` reference. It gets `obsRepo`, `researchBuffer`, `toolRegistry`, `projectHash`. The ConversationRouter needs the raw db. Two options:
- Option A (preferred): Add `db?: BetterSqlite3.Database` as a parameter to `processPostToolUseFiltered`. Pass `laminarkDb.db` from `main()`. This is clean and explicit.
- Option B: Extract db from toolRegistry. But that couples to internal implementation.

Go with Option A: add `db?: BetterSqlite3.Database` as the last parameter of `processPostToolUseFiltered`. Update the call site in `main()` to pass `laminarkDb.db`.

Import `ConversationRouter` from `../routing/conversation-router.js`.

**Part C: Modify `src/hooks/session-lifecycle.ts`**

Add pattern pre-computation at SessionStart, after config scanning and before context assembly.

In `handleSessionStart`, after the config scanning block and before `assembleSessionContext`, add:

```typescript
// ROUT-01: Pre-compute routing patterns for this session
if (toolRegistry) {
  try {
    const precomputeStart = Date.now();
    const patterns = extractPatterns(db, projectHash, 5);
    storePrecomputedPatterns(db, projectHash, patterns);
    const precomputeElapsed = Date.now() - precomputeStart;
    debug('session', 'Routing patterns pre-computed', { patternCount: patterns.length, elapsed: precomputeElapsed });
    if (precomputeElapsed > 50) {
      debug('session', 'Pattern pre-computation slow (>50ms)', { elapsed: precomputeElapsed });
    }
  } catch {
    // Routing is supplementary -- never block session start
    debug('session', 'Pattern pre-computation failed (non-fatal)');
  }
}
```

Import `extractPatterns` and `storePrecomputedPatterns` from `../routing/intent-patterns.js`.

The precomputation runs in the SessionStart sync hook. Budget: should complete in <50ms even with thousands of events. If slow, log a warning but do not block.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors across all modified files.
Run `npm run build` -- clean build with no errors.
Run existing tests: `npx vitest run --reporter=verbose 2>&1 | tail -20` -- all existing tests still pass (handler tests, injection tests, etc.).
  </verify>
  <done>
Complete routing pipeline wired end-to-end:
- SessionStart pre-computes learned patterns from historical tool_usage_events
- PostToolUse evaluates routing after observation storage (learned tier first, heuristic fallback)
- Suggestions gated by confidence threshold (ROUT-03) and rate limits (max 2/session, cooldown)
- Suggestions delivered via NotificationStore (ROUT-02)
- Built-in and Laminark tools excluded from candidates
- All routing code wrapped in try/catch (never blocks core pipeline)
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds
3. All existing tests pass (`npx vitest run`)
4. `src/routing/` contains 4 files: types.ts, heuristic-fallback.ts, intent-patterns.ts, conversation-router.ts
5. handler.ts PostToolUse pipeline includes routing evaluation AFTER observation storage
6. session-lifecycle.ts SessionStart includes pattern pre-computation AFTER config scanning
7. NotificationStore is the delivery mechanism (no stdout writes from routing)
8. All routing code is wrapped in try/catch (non-fatal)

**Phase-level acceptance test (manual, for future verification):**
- With usage history: After several tool calls, a suggestion notification appears when the next Laminark MCP tool is called
- Without usage history (cold start): Heuristic matching surfaces a suggestion when observation keywords match tool descriptions
- Below threshold: No suggestion appears when match quality is poor
- Rate limited: After 2 suggestions, no more appear in the same session
</verification>

<success_criteria>
- ROUT-01: Learned pattern matching detects historical tool usage context matches
- ROUT-02: Suggestions delivered via NotificationStore (not auto-invocation)
- ROUT-03: Confidence threshold gates all suggestions (default 0.6)
- ROUT-04: Heuristic fallback works without accumulated usage data
- No new dependencies added
- Existing handler performance budget maintained (<30ms for PostToolUse)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-conversation-routing/14-02-SUMMARY.md`
</output>
