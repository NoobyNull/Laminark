---
phase: 03-hook-integration-and-capture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/handler.ts
  - src/hooks/capture.ts
  - src/hooks/session-lifecycle.ts
  - src/hooks/index.ts
  - tsdown.config.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Hook handler reads stdin JSON, parses hook_event_name, and dispatches to correct handler"
    - "PostToolUse events produce a semantic observation summary string from tool_name + tool_input"
    - "SessionStart creates a session record in the database with the session_id from the payload"
    - "SessionEnd closes the session record by setting ended_at"
    - "Hook handler always exits 0 even when errors occur"
    - "Hook handler never writes to stdout"
    - "tsdown produces dist/hooks/handler.js as a separate entry point"
  artifacts:
    - path: "src/hooks/handler.ts"
      provides: "Hook entry point: stdin parsing, database open, event dispatch, exit 0"
      min_lines: 40
    - path: "src/hooks/capture.ts"
      provides: "PostToolUse observation extraction with semantic summaries per tool type"
      exports: ["processPostToolUse"]
      min_lines: 60
    - path: "src/hooks/session-lifecycle.ts"
      provides: "SessionStart/SessionEnd handlers using SessionRepository"
      exports: ["handleSessionStart", "handleSessionEnd"]
      min_lines: 30
    - path: "src/hooks/index.ts"
      provides: "Barrel export for hooks module"
    - path: "tsdown.config.ts"
      provides: "Dual entry points: src/index.ts and src/hooks/handler.ts"
    - path: "package.json"
      provides: "laminark-hook bin entry pointing to dist/hooks/handler.js"
  key_links:
    - from: "src/hooks/handler.ts"
      to: "src/storage/database.ts"
      via: "openDatabase(getDatabaseConfig())"
      pattern: "openDatabase"
    - from: "src/hooks/handler.ts"
      to: "src/hooks/capture.ts"
      via: "processPostToolUse(input, obsRepo)"
      pattern: "processPostToolUse"
    - from: "src/hooks/handler.ts"
      to: "src/hooks/session-lifecycle.ts"
      via: "handleSessionStart/handleSessionEnd"
      pattern: "handleSession"
    - from: "src/hooks/capture.ts"
      to: "src/storage/observations.ts"
      via: "ObservationRepository.create()"
      pattern: "obsRepo\\.create"
    - from: "src/hooks/session-lifecycle.ts"
      to: "src/storage/sessions.ts"
      via: "SessionRepository.create/end()"
      pattern: "sessionRepo\\.(create|end)"
---

<objective>
Create the hook handler entry point, observation capture module, and session lifecycle handlers that form the core pipeline for automatic observation capture from Claude Code hooks.

Purpose: This is the skeleton of the entire Phase 3 capture system. The hook handler reads stdin JSON from Claude Code hook invocations, opens a direct database connection (no HTTP intermediary), dispatches to the appropriate handler based on event type, and writes observations/sessions directly to SQLite via the Phase 1 storage layer. The capture module extracts semantic summaries from tool usage (not raw output). Session lifecycle tracks start/end events. Build tooling is updated to produce the hook handler as a separate entry point.

Output: Working hook handler CLI that can be invoked with `node dist/hooks/handler.js`, reads stdin JSON, and writes observations/sessions to the database. Build produces two entry points (MCP server + hook handler).
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-hook-integration-and-capture/03-RESEARCH.md

# Phase 1 storage layer (used directly by hook handler)
@src/storage/index.ts
@src/storage/database.ts
@src/storage/observations.ts
@src/storage/sessions.ts
@src/shared/config.ts
@src/shared/types.ts
@src/shared/debug.ts

# Build config (needs second entry point)
@tsdown.config.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hook handler entry point with build configuration</name>
  <files>
    src/hooks/handler.ts
    src/hooks/index.ts
    tsdown.config.ts
    package.json
  </files>
  <action>
Create `src/hooks/handler.ts` as the hook entry point. This file:

1. Reads all stdin using async iteration (`for await (const chunk of process.stdin)`), concatenates into a string, and parses as JSON.
2. Extracts `hook_event_name` and `cwd` from the parsed JSON.
3. Derives `projectHash` using `getProjectHash(cwd)` from `src/shared/config.ts`.
4. Opens a database connection using `openDatabase(getDatabaseConfig())` from Phase 1. This is a direct SQLite connection -- no HTTP intermediary. WAL mode (already configured in Phase 1) handles concurrent access with the MCP server process.
5. Creates `ObservationRepository` and `SessionRepository` instances scoped to the projectHash.
6. Dispatches based on `hook_event_name`:
   - `'PostToolUse'` and `'PostToolUseFailure'`: call `processPostToolUse(input, obsRepo)` from `./capture.js`
   - `'SessionStart'`: call `handleSessionStart(input, sessionRepo)` from `./session-lifecycle.js`
   - `'SessionEnd'`: call `handleSessionEnd(input, sessionRepo)` from `./session-lifecycle.js`
   - `'Stop'`: Do NOT create observations (Stop has no tool data -- per research open question #2). Log via debug() for future Phase 5 session summary triggers.
7. Closes the database in a `finally` block.
8. Wraps entire `main()` in `.catch()` that logs errors via `debug('hook', ...)` and does NOT rethrow. The process must ALWAYS exit 0.
9. NEVER writes to stdout -- only stderr via debug(). stdout output from hooks is interpreted by Claude Code.

CRITICAL CONSTRAINTS:
- Import ONLY what's needed from the storage layer. Do NOT import @modelcontextprotocol/sdk or MCP-related code (cold start overhead per research pitfall #1).
- The handler must import from `../storage/database.js`, `../storage/observations.js`, `../storage/sessions.js`, `../shared/config.js`, `../shared/debug.js` -- using the same modules Phase 1 created.
- For now, the handler calls capture/session-lifecycle WITHOUT filters. Filters are wired in Plan 03 after Plan 02 creates them.

Create `src/hooks/index.ts` as a barrel export re-exporting from handler, capture, and session-lifecycle.

Update `tsdown.config.ts` to add `src/hooks/handler.ts` as a second entry point:
```typescript
entry: ['src/index.ts', 'src/hooks/handler.ts'],
```
This produces both `dist/index.js` and `dist/hooks/handler.js`.

Update `package.json` bin to add the hook handler:
```json
"bin": {
  "laminark-server": "./dist/index.js",
  "laminark-hook": "./dist/hooks/handler.js"
}
```
  </action>
  <verify>
Run `npx tsdown` and verify:
1. `dist/hooks/handler.js` exists
2. `dist/index.js` still exists
3. `npm run check` (tsc --noEmit) passes with no type errors
  </verify>
  <done>
Handler entry point builds successfully as a separate bundle. Both `dist/index.js` and `dist/hooks/handler.js` are produced by tsdown. TypeScript type checks pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create capture module and session lifecycle handlers with tests</name>
  <files>
    src/hooks/capture.ts
    src/hooks/session-lifecycle.ts
    src/hooks/__tests__/capture.test.ts
    src/hooks/__tests__/session-lifecycle.test.ts
  </files>
  <action>
Create `src/hooks/capture.ts` with:

1. A `PostToolUsePayload` interface matching the official hook JSON format:
   ```typescript
   interface PostToolUsePayload {
     session_id: string;
     cwd: string;
     hook_event_name: string;
     tool_name: string;
     tool_input: Record<string, unknown>;
     tool_response?: Record<string, unknown>;
     tool_use_id?: string;
   }
   ```

2. A `extractObservation(payload: PostToolUsePayload): string | null` function that builds semantic summaries based on tool_name:
   - `'Write'`: `[Write] Created {file_path}` + first 200 chars of content
   - `'Edit'`: `[Edit] Modified {file_path}: replaced "{old_string first 80 chars}" with "{new_string first 80 chars}"`
   - `'Bash'`: `[Bash] $ {command first 100 chars}` + first 200 chars of response
   - `'Read'`: `[Read] {file_path}` (low signal -- admission filter will often reject)
   - `'Glob'`/`'Grep'`: `[{tool_name}] pattern={pattern} in {path}`
   - Default (including MCP tools): `[{tool_name}] {JSON.stringify(tool_input) first 200 chars}`

3. A `truncate(text: string, maxLength: number): string` helper that appends `'...'` when truncated.

4. A `processPostToolUse(input: Record<string, unknown>, obsRepo: ObservationRepository): void` function that:
   - Validates the input has required fields (tool_name at minimum)
   - Skips tools matching `mcp__laminark__` prefix (prevent self-referential capture per research finding #10)
   - Calls `extractObservation()` to get the summary
   - If summary is null, return without storing
   - Calls `obsRepo.create({ content: summary, source: 'hook:' + tool_name, sessionId: input.session_id })` to persist
   - Logs via `debug('hook', 'Captured observation', { tool: tool_name, length: summary.length })`

Create `src/hooks/session-lifecycle.ts` with:

1. `handleSessionStart(input: Record<string, unknown>, sessionRepo: SessionRepository): void`
   - Extracts `session_id` from input
   - Calls `sessionRepo.create(session_id)` to create a new session record
   - Logs via debug('session', 'Session started', { sessionId: session_id })
   - Keep it FAST -- under 100ms. No context injection (that's Phase 5).

2. `handleSessionEnd(input: Record<string, unknown>, sessionRepo: SessionRepository): void`
   - Extracts `session_id` from input
   - Calls `sessionRepo.end(session_id)` to set ended_at timestamp
   - Logs via debug('session', 'Session ended', { sessionId: session_id })

Create tests in `src/hooks/__tests__/capture.test.ts`:
- Test extractObservation for each tool type (Write, Edit, Bash, Read, Glob, Grep, default)
- Test truncation behavior at boundary
- Test processPostToolUse skips mcp__laminark__ prefixed tools
- Test processPostToolUse creates observation with correct source and sessionId
- Use a real temp database (createTempDb from Phase 1 test utils) to verify the observation appears in the DB

Create tests in `src/hooks/__tests__/session-lifecycle.test.ts`:
- Test handleSessionStart creates a session
- Test handleSessionEnd closes a session
- Use a real temp database to verify session lifecycle

Import test utilities from `src/storage/__tests__/test-utils.ts` (createTempDb pattern from Phase 1).
  </action>
  <verify>
Run `npm test` and verify all new tests pass. Run `npm run check` for type safety.
  </verify>
  <done>
Capture module extracts semantic summaries for all tool types. Session lifecycle creates and closes sessions. Self-referential mcp__laminark__ tools are filtered out. All tests pass with real database writes verified.
  </done>
</task>

</tasks>

<verification>
1. `npx tsdown` produces both `dist/index.js` and `dist/hooks/handler.js`
2. `npm run check` passes with no type errors
3. `npm test` passes -- all existing Phase 1 tests still pass plus new capture and session lifecycle tests
4. Manual smoke test: `echo '{"hook_event_name":"PostToolUse","session_id":"test-123","cwd":"/tmp","tool_name":"Write","tool_input":{"file_path":"/tmp/test.ts","content":"hello"}}' | node dist/hooks/handler.js` exits 0 and creates an observation in ~/.laminark/data.db
</verification>

<success_criteria>
- Hook handler reads stdin JSON and dispatches to correct handler based on hook_event_name
- PostToolUse events produce semantic observation summaries (not raw tool output)
- SessionStart creates a session record; SessionEnd closes it
- mcp__laminark__ prefixed tools are skipped (no self-referential capture)
- Handler always exits 0, never writes to stdout
- tsdown produces two separate entry points
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-hook-integration-and-capture/03-01-SUMMARY.md`
</output>
