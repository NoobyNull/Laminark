---
phase: 03-hook-integration-and-capture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/hook-dispatcher.sh
  - scripts/session-start.sh
  - scripts/session-end.sh
  - src/ingest/receiver.ts
  - src/ingest/normalizer.ts
  - src/shared/types.ts
autonomous: true

must_haves:
  truths:
    - "PostToolUse hook script reads JSON from stdin and POSTs to ingest endpoint within 50ms"
    - "SessionStart hook script creates a session record with a unique session ID"
    - "SessionEnd and Stop hook scripts mark session as ended with timestamp"
    - "Hook scripts exit with code 0 even if the core process is unreachable (fire-and-forget)"
  artifacts:
    - path: "scripts/hook-dispatcher.sh"
      provides: "Fire-and-forget hook for PostToolUse, Stop events"
      contains: "curl.*POST.*ingest"
    - path: "scripts/session-start.sh"
      provides: "Session lifecycle start tracking"
      contains: "curl.*POST.*session/start"
    - path: "scripts/session-end.sh"
      provides: "Session lifecycle end tracking"
      contains: "curl.*POST.*session/end"
    - path: "src/ingest/receiver.ts"
      provides: "HTTP endpoint receiving hook JSON payloads"
      exports: ["createIngestReceiver", "IngestReceiver"]
    - path: "src/ingest/normalizer.ts"
      provides: "Normalizes raw hook JSON into Observation structs"
      exports: ["normalizeHookPayload"]
  key_links:
    - from: "scripts/hook-dispatcher.sh"
      to: "src/ingest/receiver.ts"
      via: "HTTP POST to localhost:37819/ingest"
      pattern: "curl.*localhost:37819/ingest"
    - from: "scripts/session-start.sh"
      to: "src/ingest/receiver.ts"
      via: "HTTP POST to localhost:37819/session/start"
      pattern: "curl.*localhost:37819/session/start"
    - from: "src/ingest/normalizer.ts"
      to: "src/shared/types.ts"
      via: "imports Observation type"
      pattern: "import.*Observation.*from.*types"
---

<objective>
Create the hook dispatcher shell scripts and ingest receiver that form the bridge between Claude Code hook events and the Laminark core process. This establishes the data capture pipeline: Claude fires a hook event, the shell script reads stdin JSON and POSTs it to the ingest HTTP endpoint, the receiver normalizes it into an Observation struct.

Purpose: This is the foundational wiring for automatic observation capture (MEM-02) and session lifecycle tracking (MEM-03). Without these scripts, no data flows from Claude Code into Laminark.

Output: Three shell scripts (hook-dispatcher.sh, session-start.sh, session-end.sh), an HTTP ingest receiver, and a normalizer that converts raw hook JSON into typed Observation structs.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md

Phase 2 provides: MCP server running on the core process, ingest endpoint concept. This plan creates the actual ingest HTTP receiver and the hook scripts that feed it.

Phase 1 provides: SQLite database with observations table, sessions table, CRUD operations via src/storage/database.ts, src/storage/observations.ts, src/storage/sessions.ts.

Claude Code hooks reference: Hook scripts receive JSON on stdin. Fields include: session_id, event (tool_name, tool_input, tool_output for PostToolUse), hook_type. async: true means non-blocking.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ingest receiver HTTP endpoint and normalizer</name>
  <files>src/ingest/receiver.ts, src/ingest/normalizer.ts, src/shared/types.ts</files>
  <action>
Create the HTTP ingest receiver that hook scripts POST to. This is a lightweight HTTP server on localhost:37819 (separate from MCP stdio transport).

In src/shared/types.ts, add/extend these types (do NOT duplicate if Phase 1/2 already defined them -- import and extend):
- HookPayload: { session_id: string, event: { tool_name?: string, tool_input?: string, tool_output?: string }, hook_type: string, timestamp?: string }
- SessionPayload: { session_id: string, project_dir: string, timestamp?: string }
- RawObservation: { content: string, source: string, session_id: string, project_dir: string, tool_name?: string, file_paths?: string[], timestamp: string }

In src/ingest/receiver.ts:
- Export createIngestReceiver(opts: { port: number, onObservation: (obs: RawObservation) => void, onSessionStart: (payload: SessionPayload) => void, onSessionEnd: (payload: SessionPayload) => void }) => IngestReceiver
- Use Node.js built-in http module (NOT hono -- hono is for the web UI server). Keep this minimal and fast.
- Routes: POST /ingest (observation from PostToolUse/Stop), POST /session/start, POST /session/end
- Each route reads the JSON body, calls the normalizer, invokes the callback, responds 202 Accepted immediately
- Handle malformed JSON gracefully (respond 400, log error, do not crash)
- Export IngestReceiver with start() and stop() methods

In src/ingest/normalizer.ts:
- Export normalizeHookPayload(payload: HookPayload): RawObservation | null
- Extract semantic summary from tool output: tool_name + first 200 chars of output + any file paths mentioned. Do NOT store raw tool output (anti-pattern from research: "Embedding Every Token of Tool Output")
- Extract file paths from tool_input using regex (paths matching common patterns like src/, ./, /)
- For Write/Edit tools, include the first 200 chars of the actual content change (higher signal per research)
- Return null for payloads that have no meaningful content (empty tool output, missing event data)
- Set source field to hook_type value (e.g., "PostToolUse", "Stop")
  </action>
  <verify>
Run: npx vitest run src/ingest/ --reporter=verbose
Tests should cover: valid PostToolUse payload normalization, session start/end endpoint responses, malformed JSON handling, empty payload returning null, file path extraction from tool input.
If no tests exist yet, write tests in src/ingest/__tests__/receiver.test.ts and src/ingest/__tests__/normalizer.test.ts.
  </verify>
  <done>
HTTP server starts on port 37819 and accepts POST requests to /ingest, /session/start, /session/end. Normalizer extracts semantic summaries (not raw output) from hook payloads. Malformed requests return 400 without crashing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create hook dispatcher shell scripts</name>
  <files>scripts/hook-dispatcher.sh, scripts/session-start.sh, scripts/session-end.sh</files>
  <action>
Create three shell scripts that Claude Code will invoke for hook events.

scripts/hook-dispatcher.sh (used for PostToolUse, Stop, PostToolUseFailure):
- Read all stdin into a variable: INPUT=$(cat)
- POST to http://localhost:37819/ingest with Content-Type: application/json
- Use curl with: -s (silent), -o /dev/null (discard response), --max-time 2 (timeout after 2s), --connect-timeout 1 (connect timeout 1s)
- Background the curl call with & so the script exits immediately (fire-and-forget pattern)
- ALWAYS exit 0 regardless of curl success/failure -- hook must never fail Claude Code
- Add a shebang line: #!/bin/bash
- Make executable: chmod +x

scripts/session-start.sh (used for SessionStart -- this is SYNC, blocking):
- Read all stdin into a variable: INPUT=$(cat)
- POST to http://localhost:37819/session/start with the full JSON payload
- Use curl with: -s, --max-time 2, --connect-timeout 1
- This is sync so we DO wait for the response (but with tight timeouts)
- Print nothing to stdout for now (context injection is Phase 5). Just track the session start.
- Exit 0 always

scripts/session-end.sh (used for SessionEnd):
- Read all stdin into a variable: INPUT=$(cat)
- POST to http://localhost:37819/session/end
- Background curl with & (async, fire-and-forget like hook-dispatcher.sh)
- Exit 0 always

All scripts must:
- Use bash (not sh) for consistency
- Have the executable bit set
- Handle the case where curl is not installed (exit 0 silently)
- Include a comment header explaining which hook events they handle
  </action>
  <verify>
Run: bash -n scripts/hook-dispatcher.sh && bash -n scripts/session-start.sh && bash -n scripts/session-end.sh (syntax check)
Run: ls -la scripts/*.sh (verify executable bit)
Run: echo '{"session_id":"test-123","event":{"tool_name":"Write","tool_input":"src/foo.ts","tool_output":"wrote 50 lines"},"hook_type":"PostToolUse"}' | bash scripts/hook-dispatcher.sh; echo "exit code: $?" (should print "exit code: 0")
  </verify>
  <done>
Three shell scripts exist in scripts/ directory, all with executable bit set. hook-dispatcher.sh POSTs stdin JSON to /ingest and exits 0 immediately. session-start.sh POSTs to /session/start synchronously with 2s timeout. session-end.sh POSTs to /session/end async. All exit 0 even when the core process is unreachable.
  </done>
</task>

</tasks>

<verification>
1. Start the ingest receiver: npx tsx src/ingest/receiver.ts (or via a test harness)
2. In another terminal, pipe test JSON through hook-dispatcher.sh and verify the receiver logs receipt
3. Pipe session start JSON through session-start.sh and verify session endpoint is called
4. Kill the receiver, re-run hook-dispatcher.sh, confirm it still exits 0 (fire-and-forget resilience)
5. All unit tests pass: npx vitest run src/ingest/
</verification>

<success_criteria>
- Hook scripts read stdin JSON and POST to ingest endpoint
- Ingest receiver accepts POST requests on 3 routes and invokes callbacks
- Normalizer extracts semantic summaries (not raw output) from hook payloads
- All scripts exit 0 even when core process is unreachable
- Unit tests pass for receiver and normalizer
</success_criteria>

<output>
After completion, create `.planning/phases/03-hook-integration-and-capture/03-01-SUMMARY.md`
</output>
