---
phase: 03-hook-integration-and-capture
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ingest/admission-filter.ts
  - src/ingest/noise-detector.ts
  - src/ingest/__tests__/admission-filter.test.ts
  - src/ingest/__tests__/noise-detector.test.ts
autonomous: true

must_haves:
  truths:
    - "Build output (npm install, tsc, webpack logs) is rejected by the admission filter"
    - "Large file reads (>500 chars of raw file content) are rejected or truncated to summary"
    - "Repetitive linter warnings (eslint, prettier output) are rejected"
    - "Meaningful observations (file edits, bash commands with output, decisions) pass through"
    - "Each observation gets a relevance score between 0.0 and 1.0"
  artifacts:
    - path: "src/ingest/admission-filter.ts"
      provides: "Admission gate that decides whether an observation is stored"
      exports: ["AdmissionFilter", "AdmissionResult"]
    - path: "src/ingest/noise-detector.ts"
      provides: "Pattern-based noise detection for common low-signal outputs"
      exports: ["NoiseDetector", "NoiseCategory"]
  key_links:
    - from: "src/ingest/admission-filter.ts"
      to: "src/ingest/noise-detector.ts"
      via: "imports NoiseDetector for pattern matching"
      pattern: "import.*NoiseDetector.*from.*noise-detector"
    - from: "src/ingest/admission-filter.ts"
      to: "src/shared/types.ts"
      via: "imports RawObservation type"
      pattern: "import.*RawObservation.*from.*types"
---

<objective>
Create the observation admission filter that prevents storing low-signal noise (MEM-10). This is the quality gate between hook capture and database storage. Build output, large file dumps, and repetitive linter warnings are filtered out. Only meaningful content -- file edits, decisions, commands with useful output -- passes through.

Purpose: Without admission filtering, the database bloats with noise and search quality degrades (Pitfall 1 from research: "Indiscriminate Memory Storage"). This filter is the first line of defense for data quality.

Output: An AdmissionFilter module with a NoiseDetector for pattern-based rejection, relevance scoring, and configurable thresholds.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md

Research guidance: "Extract semantic summary from tool output (first ~200 chars + tool name + file paths). Don't embed raw output. Filter out noise (build logs, large file reads, repetitive warnings)."

Pitfall 1 (Indiscriminate Memory Storage): "Implement selective memory admission from day one. Every observation passes through a quality gate before storage."
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create noise detector with pattern-based rejection</name>
  <files>src/ingest/noise-detector.ts, src/ingest/__tests__/noise-detector.test.ts</files>
  <action>
Create src/ingest/noise-detector.ts:

Export enum NoiseCategory: BUILD_OUTPUT, LARGE_FILE_READ, LINTER_WARNING, TEST_OUTPUT, PACKAGE_INSTALL, EMPTY_OUTPUT, REPETITIVE

Export class NoiseDetector with method detect(content: string, toolName: string): { isNoise: boolean, category: NoiseCategory | null, confidence: number }

Pattern matching rules (order matters -- check most specific first):

1. BUILD_OUTPUT: Match patterns like "npm WARN", "npm ERR", "Successfully compiled", "webpack compiled", "tsc.*error TS", "Build completed", "Compiling", "Module not found" (confidence 0.9)
2. PACKAGE_INSTALL: Match "added.*packages", "npm install", "up to date", "removed.*packages", "audited.*packages" (confidence 0.95)
3. LINTER_WARNING: Match "eslint", "prettier", "warning.*rule", "/[0-9]+ problems?/", repeated "warning:" lines (3+ warnings = noise) (confidence 0.85)
4. TEST_OUTPUT: Match "PASS", "FAIL", "Tests:.*passed", "Test Suites:", "✓", "✗" -- but ONLY reject if it is pure test runner output without meaningful failure details. If tool_name is "Bash" and output contains "FAIL" with stack traces, let it THROUGH (test failures are high signal) (confidence 0.7 for pure pass output, 0.3 for failures)
5. LARGE_FILE_READ: If content length > 500 chars AND tool_name is "Read" or "cat" or "View", it is a large file read (confidence 0.8). Exception: if content contains "TODO", "FIXME", "HACK", "BUG" -- these are high signal even in large reads.
6. EMPTY_OUTPUT: Content is empty, whitespace-only, or just "OK"/"Success"/"Done" (confidence 1.0)
7. REPETITIVE: If content matches a previously seen pattern (use a small LRU cache of last 20 content hashes). Exact duplicates within a session are noise (confidence 0.9)

Each rule returns a confidence score. The detector returns the highest-confidence match.

Create tests in src/ingest/__tests__/noise-detector.test.ts:
- Test each NoiseCategory with representative examples
- Test edge cases: test failure output should NOT be filtered, TODO in large file reads should NOT be filtered
- Test that Write/Edit tool outputs are never classified as noise regardless of content
  </action>
  <verify>
Run: npx vitest run src/ingest/__tests__/noise-detector.test.ts --reporter=verbose
All tests pass. Coverage of each NoiseCategory with at least 2 positive and 1 negative example each.
  </verify>
  <done>
NoiseDetector correctly identifies build output, package installs, linter warnings, test runner output, large file reads, empty output, and repetitive content. Test failures and TODOs in large files pass through. Write/Edit tool outputs are never classified as noise.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create admission filter with relevance scoring</name>
  <files>src/ingest/admission-filter.ts, src/ingest/__tests__/admission-filter.test.ts</files>
  <action>
Create src/ingest/admission-filter.ts:

Export type AdmissionResult = { admitted: boolean, relevanceScore: number, reason?: string, filtered?: NoiseCategory }

Export class AdmissionFilter:
- Constructor takes config: { minRelevanceScore: number (default 0.3), noiseThreshold: number (default 0.7) }
- Method admit(observation: RawObservation): AdmissionResult

Admission logic (in order):
1. Run NoiseDetector on observation.content + observation.tool_name
2. If noise confidence >= noiseThreshold, REJECT with filtered=category
3. Calculate relevance score (0.0 - 1.0) based on:
   - Tool type bonus: Write/Edit +0.4, Bash +0.2, Read +0.1, other +0.15
   - Content length signal: 10-200 chars +0.2, 200-500 chars +0.3, 500+ chars +0.1 (diminishing returns)
   - File path presence: has file_paths +0.15
   - Decision indicators: content contains "decided", "chose", "changed to", "switched", "because", "instead of" +0.2
   - Error indicators: content contains "error", "failed", "exception", "bug" +0.15 (errors are high signal)
4. If relevanceScore < minRelevanceScore, REJECT with reason="below_threshold"
5. ADMIT with the relevance score

Export a convenience function: createAdmissionFilter(config?: Partial<AdmissionFilterConfig>): AdmissionFilter

Create tests in src/ingest/__tests__/admission-filter.test.ts:
- Test that npm install output is rejected (noise)
- Test that a Write tool creating a new file is admitted with high relevance
- Test that a Bash command with error output is admitted
- Test that an empty observation is rejected
- Test relevance score ranges for different tool types
- Test the decision indicator bonus (observation containing "decided to use X because Y" gets higher score)
  </action>
  <verify>
Run: npx vitest run src/ingest/__tests__/admission-filter.test.ts --reporter=verbose
All tests pass with clear relevance score differentiation between high-signal and low-signal observations.
  </verify>
  <done>
AdmissionFilter rejects noise with configurable threshold, scores observations on relevance (0.0-1.0), and admits only meaningful content. High-signal patterns (file edits, decisions, errors) score higher than low-signal patterns (reads, empty outputs). Tests prove each admission/rejection path.
  </done>
</task>

</tasks>

<verification>
1. npx vitest run src/ingest/ passes all tests
2. NoiseDetector correctly categorizes: build logs -> BUILD_OUTPUT, npm install -> PACKAGE_INSTALL, eslint warnings -> LINTER_WARNING
3. AdmissionFilter admits Write tool observations with score > 0.5
4. AdmissionFilter rejects "added 50 packages in 3s" (npm install noise)
5. AdmissionFilter admits "Error: Cannot find module './auth'" (error = high signal)
</verification>

<success_criteria>
- Build output, package installs, linter warnings, large file reads, and empty outputs are filtered
- Write/Edit tool outputs are always admitted (never classified as noise)
- Test failures pass through (high signal despite being test output)
- Relevance scores correctly differentiate high-signal from low-signal observations
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-hook-integration-and-capture/03-02-SUMMARY.md`
</output>
