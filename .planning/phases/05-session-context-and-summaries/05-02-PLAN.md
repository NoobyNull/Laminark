---
phase: 05-session-context-and-summaries
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - scripts/session-start.sh
  - src/context/injection.ts
  - src/context/index.ts
  - src/context/injection.test.ts
  - hooks/hooks.json
autonomous: true

must_haves:
  truths:
    - "When a new Claude Code session starts, Claude receives a concise summary of the last session plus high-value recent observations"
    - "Context injection completes within 2 seconds (performance budget for sync SessionStart hook)"
    - "Injected context uses progressive disclosure format (compact index, not full observation dumps)"
    - "Total injected context stays under 2000 tokens (~1500 words)"
    - "If no prior sessions exist (first-ever run), injection outputs a brief welcome message instead of erroring"
  artifacts:
    - path: "src/context/injection.ts"
      provides: "Context assembly for SessionStart hook"
      exports: ["assembleSessionContext", "formatContextIndex"]
    - path: "src/context/index.ts"
      provides: "Context module barrel export"
      exports: ["assembleSessionContext"]
    - path: "scripts/session-start.sh"
      provides: "Sync SessionStart hook script that queries core and prints context to stdout"
      contains: "curl.*context/session-start"
    - path: "hooks/hooks.json"
      provides: "Hook configuration with SessionStart event registered"
      contains: "SessionStart"
  key_links:
    - from: "scripts/session-start.sh"
      to: "src/ingest/receiver.ts"
      via: "HTTP GET to core process /context/session-start endpoint"
      pattern: "curl.*localhost.*context/session-start"
    - from: "src/context/injection.ts"
      to: "src/storage/sessions.ts"
      via: "reads last session summary"
      pattern: "getLastSession|getRecentSessions"
    - from: "src/context/injection.ts"
      to: "src/storage/observations.ts"
      via: "reads recent high-value observations for index"
      pattern: "getRecentObservations|getHighValueObservations"
    - from: "scripts/session-start.sh"
      to: "stdout"
      via: "prints assembled context string to stdout for Claude Code to inject"
      pattern: "echo.*\\$CONTEXT"
---

<objective>
SessionStart context injection with progressive disclosure index -- Claude starts every session already knowing what happened last time.

Purpose: The SessionStart hook is synchronous (blocking). When Claude Code starts a new session, this hook queries the core process for recent context and prints it to stdout. Claude Code injects that text into Claude's context window. This gives Claude immediate awareness of the last session's work, recent important observations, and any stashed context threads -- without the user needing to re-explain anything.

Output: A context assembly module that builds a compact context string from the last session summary and recent high-value observations, a sync SessionStart hook script that queries the core process and prints context to stdout, and updated hooks.json.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/05-session-context-and-summaries/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create context injection module with progressive disclosure formatting</name>
  <files>
    src/context/injection.ts
    src/context/index.ts
    src/context/injection.test.ts
  </files>
  <action>
    1. Create `src/context/injection.ts` with these functions:

       **`assembleSessionContext(db: DatabaseConnection, projectHash: string): string`**
       - This is the main entry point. Assembles a complete context string for injection.
       - Steps:
         a. Get the most recent completed session (with a non-null summary) for this project
         b. Get the 5 most recent high-value observations (source = "mcp:save_memory" or observations with high relevance, ordered by createdAt DESC)
         c. Format into a progressive disclosure context string
       - Total output must be under 2000 tokens (~1500 words / ~6000 chars). If content exceeds budget, truncate observations (keep session summary intact, it is already compressed).
       - If no prior sessions exist, return a welcome message:
         ```
         [Memorite] First session detected. Memory system is active and capturing observations.
         Use /memorite:remember to save important context. Use /memorite:recall to search memories.
         ```

       **`formatContextIndex(lastSession: Session | null, recentObservations: Observation[]): string`**
       - Formats the context using progressive disclosure (compact index, not full dumps):
         ```
         [Memorite Context - Session Recovery]

         ## Last Session ({lastSession.startedAt} to {lastSession.endedAt})
         {lastSession.summary}

         ## Recent Memories (use search tool for full details)
         {for each observation:}
         - [{observation.id.slice(0,8)}] {observation.content.slice(0, 120)}... (source: {observation.source}, {relative time ago})
         ```
       - Each observation entry is a single line with truncated content -- this is the "index" layer. Claude can use the search/get_observations MCP tools to drill down into any specific memory.
       - Use relative time formatting: "2 hours ago", "yesterday", "3 days ago" etc.
       - If lastSession is null but observations exist, show only the observations section
       - If both are null/empty, return the welcome message

       **`getHighValueObservations(db: DatabaseConnection, projectHash: string, limit: number): Observation[]`**
       - Queries observations ordered by value signal:
         1. First priority: source = "mcp:save_memory" (user explicitly saved these)
         2. Second priority: most recent observations regardless of source
       - Excludes deleted observations (deletedAt IS NOT NULL)
       - Limits to `limit` results (default 5)
       - Scoped to projectHash

       Helper: **`formatRelativeTime(isoDate: string): string`**
       - Converts ISO 8601 timestamp to human-readable relative time
       - "just now" (< 1 min), "X minutes ago", "X hours ago", "yesterday", "X days ago", "X weeks ago"

    2. Create `src/context/index.ts` as barrel export:
       ```typescript
       export { assembleSessionContext, formatContextIndex } from './injection.js';
       ```

    3. Create `src/context/injection.test.ts` with tests:
       - Test formatContextIndex with a session summary and 3 observations produces expected format
       - Test formatContextIndex with null session and observations shows only observations
       - Test formatContextIndex with null session and empty observations returns welcome message
       - Test formatRelativeTime for various time deltas (1 min, 2 hours, 1 day, 3 weeks)
       - Test assembleSessionContext total output is under 6000 characters (2000 token proxy)
       - Test observation truncation at 120 characters in index format
       - Test high-value observations prioritize mcp:save_memory source

    Performance note: assembleSessionContext runs in the sync SessionStart hook path. All database queries are synchronous (better-sqlite3). The 2-second budget is generous -- the expected execution time is under 100ms (2-3 simple SELECT queries on indexed columns).
  </action>
  <verify>
    1. `npx vitest run src/context/injection.test.ts` passes all tests
    2. `npx tsc --noEmit` passes with zero type errors
    3. Grep confirms injection.ts exports assembleSessionContext and formatContextIndex
    4. Grep confirms index.ts re-exports assembleSessionContext
    5. Test confirms output format includes "[Memorite Context - Session Recovery]" header
    6. Test confirms output stays under 6000 characters with 5 observations + session summary
  </verify>
  <done>
    Context injection module assembles a compact progressive disclosure index from the last session summary and recent high-value observations. Output is under 2000 tokens, formatted for Claude's context window. First-run case handled with welcome message. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SessionStart hook script and register endpoint</name>
  <files>
    scripts/session-start.sh
    hooks/hooks.json
    src/ingest/receiver.ts
  </files>
  <action>
    1. Create `scripts/session-start.sh`:
       ```bash
       #!/bin/bash
       # SessionStart hook: injects prior session context into Claude's context window
       # This hook is SYNCHRONOUS (blocking) -- stdout is added to Claude's context
       # Must complete within 2 seconds. Typical execution: <200ms.

       # Read session info from stdin
       INPUT=$(cat)

       # Query core process for assembled context
       # Timeout after 1.5s to stay within 2s budget (leave margin for script overhead)
       CONTEXT=$(curl -s --max-time 1.5 \
         "http://localhost:37819/context/session-start" \
         -H "Content-Type: application/json" \
         -d "$INPUT" 2>/dev/null)

       # If core process is unavailable, print a fallback message
       if [ -z "$CONTEXT" ]; then
         echo "[Memorite] Memory system starting up. Context will be available shortly."
       else
         echo "$CONTEXT"
       fi
       ```
       Make the script executable: `chmod +x scripts/session-start.sh`

       Note: This hook is NOT async -- it blocks session start. stdout is what Claude sees. The curl timeout of 1.5s ensures we stay within the 2-second budget even if the core process is slow. The fallback message handles the cold-start case where the core process hasn't started yet.

    2. Update `hooks/hooks.json` to register the SessionStart hook. Read the existing file first (Phase 3 + Plan 05-01 may have entries). Add:
       ```json
       {
         "event": "SessionStart",
         "script": "scripts/session-start.sh",
         "async": false,
         "timeout": 2000
       }
       ```
       The `async: false` is critical -- this hook must be synchronous so its stdout is injected into Claude's context window. The 2000ms timeout matches the CTX-01 requirement.

    3. Add a `/context/session-start` POST endpoint to the ingest receiver (`src/ingest/receiver.ts`). Read the existing file first (Plan 05-01 added /session-summary). Add this endpoint:
       - Accepts the session stdin JSON (contains project directory, session ID, etc.)
       - Extracts projectHash from the request (compute from project directory using getProjectHash from src/shared/config.ts)
       - Calls `assembleSessionContext(db, projectHash)` from the context module
       - Returns the assembled context string as plain text (Content-Type: text/plain)
       - Returns 200 with the context text (the hook script echoes this to stdout)
       - Returns 200 with welcome message on error (never return an error status -- the hook script needs printable text regardless)
       - Must complete fast: log a warning if execution exceeds 500ms

    The endpoint returns plain text, not JSON, because the hook script directly echoes the response to stdout for Claude to read.
  </action>
  <verify>
    1. `bash -n scripts/session-start.sh` passes syntax check
    2. `test -x scripts/session-start.sh` confirms executable permission
    3. `cat hooks/hooks.json | node -e "JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'))"` validates JSON
    4. Grep confirms hooks.json contains "SessionStart" event with async: false
    5. Grep confirms receiver.ts has a /context/session-start route
    6. `npx tsc --noEmit` passes with zero type errors
  </verify>
  <done>
    SessionStart hook script exists, is executable, runs synchronously, and queries the core process for assembled context. The core process returns a compact progressive disclosure context string. Claude receives the last session summary and recent high-value observations at the start of every new session. Fallback message handles cold-start gracefully. hooks.json registers SessionStart with async: false and 2000ms timeout.
  </done>
</task>

</tasks>

<verification>
- `npx vitest run` passes all tests including context injection tests
- `npx tsc --noEmit` passes with zero type errors
- scripts/session-start.sh is executable and syntactically valid
- hooks/hooks.json has SessionStart (async: false) and Stop (async: true) hooks
- Context injection output is under 2000 tokens with progressive disclosure format
- First-run (no prior sessions) produces a welcome message, not an error
- Hook timeout is set to 2000ms matching the CTX-01 requirement
</verification>

<success_criteria>
- CTX-01 is satisfied: SessionStart hook injects last session summary + recent high-value observations within 2 seconds
- Progressive disclosure format: compact index with observation IDs and truncated content, not full dumps
- Total injection under 2000 tokens respects context window budget
- Graceful degradation: core process unavailable produces a fallback message, first-run produces welcome
</success_criteria>

<output>
After completion, create `.planning/phases/05-session-context-and-summaries/05-02-SUMMARY.md`
</output>
