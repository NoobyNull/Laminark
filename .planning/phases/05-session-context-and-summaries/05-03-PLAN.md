---
phase: 05-session-context-and-summaries
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - commands/remember.md
  - commands/recall.md
autonomous: true

must_haves:
  truths:
    - "User can type /memorite:remember followed by text and it triggers the save_memory MCP tool to persist a memory"
    - "User can type /memorite:recall followed by a description and it triggers the search MCP tool to find relevant memories"
    - "/memorite:remember includes the user's text as the memory content with appropriate context"
    - "/memorite:recall displays search results in a readable format with relevance indicators"
  artifacts:
    - path: "commands/remember.md"
      provides: "Slash command definition for /memorite:remember"
      contains: "save_memory"
    - path: "commands/recall.md"
      provides: "Slash command definition for /memorite:recall"
      contains: "search"
  key_links:
    - from: "commands/remember.md"
      to: "src/mcp/tools/save-memory.ts"
      via: "Claude Code slash command instructs Claude to call save_memory MCP tool"
      pattern: "save_memory"
    - from: "commands/recall.md"
      to: "src/mcp/tools/search.ts"
      via: "Claude Code slash command instructs Claude to call search MCP tool"
      pattern: "search"
---

<objective>
/memorite:remember and /memorite:recall slash command implementations.

Purpose: Slash commands give users explicit, discoverable control over their memory system. /memorite:remember lets users save important context with a simple command. /memorite:recall lets users search their memories by description. These commands bridge the gap between automatic observation capture (Phase 3) and intentional memory management -- users can explicitly tell the system "this is important, remember it" or "find what I know about X."

Output: Two markdown files in the commands/ directory that define Claude Code slash commands. These are instruction files that tell Claude how to handle the command -- they invoke existing MCP tools (save_memory from Phase 2, search from Phase 2).
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /memorite:remember slash command</name>
  <files>
    commands/remember.md
  </files>
  <action>
    1. Create the `commands/` directory if it does not exist: `mkdir -p commands`

    2. Create `commands/remember.md` with the following content. This file IS the slash command -- Claude Code reads it as instructions when the user types `/memorite:remember`.

       The file should contain:
       ```markdown
       # /memorite:remember

       Save a memory to Memorite for future retrieval.

       ## Usage

       /memorite:remember {text to remember}

       ## Instructions

       When the user invokes this command:

       1. Take the text provided after the command as the memory content
       2. Call the `save_memory` MCP tool with:
          - `content`: The user's text exactly as provided
          - `source`: "slash:remember" (identifies this as an explicit user save)
       3. Confirm to the user that the memory has been saved
       4. Show a brief snippet of what was saved (first 100 characters)

       ## Examples

       User: /memorite:remember The auth system uses JWT with 15-minute expiry and refresh tokens stored in httpOnly cookies
       Action: Call save_memory with content="The auth system uses JWT with 15-minute expiry and refresh tokens stored in httpOnly cookies" and source="slash:remember"
       Response: "Saved to memory: 'The auth system uses JWT with 15-minute expiry and refresh tokens stored in httpOnly cookies'"

       User: /memorite:remember We decided to use Postgres instead of MySQL for the new service because of JSONB support
       Action: Call save_memory with the full text
       Response: "Saved to memory: 'We decided to use Postgres instead of MySQL for the new serv...'"

       ## Notes

       - Memories saved via /memorite:remember are high-priority in search results (source: "slash:remember")
       - These memories persist across sessions and are included in session context injection
       - If no text is provided after the command, ask the user what they'd like to remember
       ```

    The key design decisions:
    - Source is "slash:remember" (not "mcp:save_memory") so the system can distinguish explicit user saves from programmatic saves. This matters because explicit saves get higher priority in context injection (Plan 05-02).
    - The command instructs Claude to confirm the save with a snippet, giving the user confidence it worked.
    - If the user forgets to include text, Claude should prompt them rather than silently failing.
  </action>
  <verify>
    1. File exists at commands/remember.md
    2. File contains "save_memory" (references the MCP tool)
    3. File contains "slash:remember" (the source identifier)
    4. File contains usage examples
    5. File is valid markdown (no syntax errors)
  </verify>
  <done>
    /memorite:remember slash command is defined in commands/remember.md. When a user types the command followed by text, Claude calls the save_memory MCP tool with the user's text and source "slash:remember". The command includes usage instructions, examples, and handles the edge case of no text provided.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /memorite:recall slash command</name>
  <files>
    commands/recall.md
  </files>
  <action>
    1. Create `commands/recall.md` with the following content:

       ```markdown
       # /memorite:recall

       Search Memorite memories by description or topic.

       ## Usage

       /memorite:recall {description of what you're looking for}

       ## Instructions

       When the user invokes this command:

       1. Take the text provided after the command as the search query
       2. Call the `search` MCP tool with:
          - `query`: The user's search description
          - `limit`: 10 (show top 10 results)
       3. Present the results to the user in a readable format:
          - Show each result with its relevance score, a content snippet, the source, and when it was created
          - Group results by relevance tier if helpful (highly relevant, somewhat relevant)
          - If results include memories from different sessions, note which session they came from

       ## Response Format

       Present results like this:

       **Memory Search: "{query}"**

       Found {N} relevant memories:

       1. **[{score}% match]** {content snippet, first 200 chars}
          _{source} | {relative time}_

       2. **[{score}% match]** {content snippet}
          _{source} | {relative time}_

       ...

       _Use the search tool for more specific queries, or get_observations for full details on any memory._

       ## Examples

       User: /memorite:recall authentication decisions
       Action: Call search with query="authentication decisions"
       Response: Show top results about auth-related memories with scores and snippets

       User: /memorite:recall what database did we choose
       Action: Call search with query="what database did we choose"
       Response: Show results mentioning database selection decisions

       ## Notes

       - Results use hybrid search (keyword + semantic) for best matching
       - If no results are found, suggest the user try different search terms or check if they have saved any memories yet
       - If no query is provided after the command, ask the user what they'd like to search for
       - For detailed view of any result, Claude can use the get_observations MCP tool with the observation ID
       ```

    The key design decisions:
    - Uses the hybrid search MCP tool from Phase 2/4, which combines FTS5 keyword and vector semantic search
    - Results presented with relevance scores so the user understands match quality
    - Includes guidance on follow-up actions (get_observations for full details)
    - Handles the no-results case and the no-query case gracefully
  </action>
  <verify>
    1. File exists at commands/recall.md
    2. File contains "search" (references the search MCP tool)
    3. File contains "get_observations" (references drill-down tool)
    4. File contains usage examples
    5. File is valid markdown (no syntax errors)
    6. Both commands/remember.md and commands/recall.md exist
  </verify>
  <done>
    /memorite:recall slash command is defined in commands/recall.md. When a user types the command followed by a description, Claude calls the search MCP tool and presents results with relevance scores, content snippets, sources, and timestamps. The command includes response format guidance, examples, and handles edge cases (no results, no query).
  </done>
</task>

</tasks>

<verification>
- commands/remember.md exists and references save_memory MCP tool
- commands/recall.md exists and references search MCP tool
- Both files contain usage instructions, examples, and edge case handling
- Both files are valid markdown
- Source identifiers are correctly set ("slash:remember" for explicit saves)
</verification>

<success_criteria>
- UI-02 is satisfied: /memorite:remember allows users to explicitly save a memory with context
- UI-03 is satisfied: /memorite:recall allows users to search memories by description and see relevant results
- Commands are discoverable via Claude Code's slash command interface
- Commands delegate to existing MCP tools (save_memory, search) -- no new backend logic needed
</success_criteria>

<output>
After completion, create `.planning/phases/05-session-context-and-summaries/05-03-SUMMARY.md`
</output>
