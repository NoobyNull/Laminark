---
phase: 16-staleness-management
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - src/hooks/session-lifecycle.ts
  - src/hooks/handler.ts
  - src/context/injection.ts
  - src/routing/conversation-router.ts
  - src/mcp/tools/discover-tools.ts
autonomous: true

must_haves:
  truths:
    - "On session start, tools removed from config are marked stale"
    - "Tools not seen in 30+ days are ranked lower in suggestions"
    - "Tools with 3+ failures in last 5 events are demoted"
    - "A single successful use restores a demoted tool to active"
    - "Stale/demoted tools are excluded from routing suggestions"
    - "Search results show status marker for stale/demoted tools"
  artifacts:
    - path: "src/hooks/session-lifecycle.ts"
      provides: "detectRemovedTools function and SessionStart wiring"
      contains: "detectRemovedTools"
    - path: "src/hooks/handler.ts"
      provides: "Failure demotion check and success restoration in PostToolUse"
      contains: "markDemoted"
    - path: "src/context/injection.ts"
      provides: "Age-based and status-based score penalty in rankToolsByRelevance"
      contains: "status.*stale.*demoted"
    - path: "src/routing/conversation-router.ts"
      provides: "Stale/demoted tools filtered from suggestable set"
      contains: "status.*active"
    - path: "src/mcp/tools/discover-tools.ts"
      provides: "Status indicator in search result formatting"
      contains: "status"
  key_links:
    - from: "src/hooks/session-lifecycle.ts"
      to: "src/storage/tool-registry.ts"
      via: "detectRemovedTools calls getConfigSourcedTools, markStale, markActive"
      pattern: "getConfigSourcedTools|markStale"
    - from: "src/hooks/handler.ts"
      to: "src/storage/tool-registry.ts"
      via: "PostToolUse calls getRecentEventsForTool, markDemoted, markActive"
      pattern: "getRecentEventsForTool|markDemoted"
    - from: "src/context/injection.ts"
      to: "src/shared/tool-types.ts"
      via: "rankToolsByRelevance reads row.status for score penalty"
      pattern: "row\\.status"
    - from: "src/routing/conversation-router.ts"
      to: "src/shared/tool-types.ts"
      via: "Filter suggestable tools by status === 'active'"
      pattern: "status.*active"
---

<objective>
Wire staleness detection, failure demotion, and deprioritization into the live hook and ranking pipeline.

Purpose: The storage methods from Plan 01 need to be called at the right points in the session lifecycle and PostToolUse pipeline. This plan implements the three STAL requirements: (1) config rescan comparison at SessionStart, (2) age-based score penalty in ranking, and (3) failure-driven demotion in PostToolUse with instant restoration on success.

Output: Complete staleness management system -- config removal detection, age-based deprioritization, failure demotion, routing exclusion, and search status display.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-staleness-management/16-01-SUMMARY.md
@src/hooks/session-lifecycle.ts
@src/hooks/handler.ts
@src/hooks/config-scanner.ts
@src/context/injection.ts
@src/routing/conversation-router.ts
@src/mcp/tools/discover-tools.ts
@src/shared/tool-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config rescan staleness detection at SessionStart (STAL-01)</name>
  <files>src/hooks/session-lifecycle.ts</files>
  <action>
    Add a `detectRemovedTools` function to `session-lifecycle.ts` and wire it into `handleSessionStart` after the config scan completes.

    **The detectRemovedTools function:**

    ```typescript
    function detectRemovedTools(
      toolRegistry: ToolRegistryRepository,
      scannedTools: DiscoveredTool[],
      projectHash: string,
    ): void {
      // 1. Get all config-sourced tools currently marked active for this project (+ globals)
      const registeredConfigTools = toolRegistry.getConfigSourcedTools(projectHash);

      // 2. Build a Set of scanned tool names for O(1) lookup
      const scannedNames = new Set(scannedTools.map(t => t.name));

      // 3. Mark tools missing from scan as stale
      //    IMPORTANT: For wildcard MCP server entries (mcp__X__*), also mark
      //    individual tools from that server (mcp__X__specific_tool).
      //    Extract server name from wildcard entries that disappeared.
      const removedServers = new Set<string>();

      for (const registered of registeredConfigTools) {
        if (!scannedNames.has(registered.name)) {
          toolRegistry.markStale(registered.name, registered.project_hash);

          // Track removed MCP server names for individual tool cleanup
          if (registered.tool_type === 'mcp_server' && registered.server_name) {
            removedServers.add(registered.server_name);
          }
        }
      }

      // 4. Mark individual tools from removed MCP servers as stale
      //    These are organically-discovered tools (source = 'hook:PostToolUse')
      //    whose parent server was removed from config
      if (removedServers.size > 0) {
        for (const registered of toolRegistry.getAvailableForSession(projectHash)) {
          if (
            registered.server_name &&
            removedServers.has(registered.server_name) &&
            registered.tool_type === 'mcp_tool'
          ) {
            toolRegistry.markStale(registered.name, registered.project_hash);
          }
        }
      }

      // 5. Restore tools that reappeared in the scan
      //    The upsert in the scan loop already sets status='active' (per Plan 01),
      //    so we only need to handle tools that were previously stale
      //    and are now scanned again. The upsert handles this automatically.
    }
    ```

    Import `DiscoveredTool` type from `../shared/tool-types.js`.

    **Wire into handleSessionStart:**

    After the existing config scan block (after the `for (const tool of tools)` loop and before `scanElapsed` logging), add:

    ```typescript
    // STAL-01: Detect tools removed from config
    try {
      detectRemovedTools(toolRegistry, tools, projectHash);
      debug('session', 'Staleness detection completed');
    } catch {
      debug('session', 'Staleness detection failed (non-fatal)');
    }
    ```

    Place this INSIDE the existing `if (toolRegistry)` block, after the upsert loop but before the elapsed time logging. The staleness detection is part of the config scan phase and contributes to scanElapsed timing.
  </action>
  <verify>Run `npx tsc --noEmit` -- zero type errors. Run `npx vitest run` -- all existing tests pass.</verify>
  <done>detectRemovedTools function exists in session-lifecycle.ts. handleSessionStart calls it after config scan. Config-sourced tools not in scan results are marked stale. Individual MCP tools from removed servers are also marked stale.</done>
</task>

<task type="auto">
  <name>Task 2: Failure demotion and success restoration in PostToolUse (STAL-03)</name>
  <files>src/hooks/handler.ts</files>
  <action>
    In `processPostToolUseFiltered`, after the existing organic tool discovery block (step 0, lines ~79-94), add failure demotion and success restoration logic.

    **After** the `toolRegistry.recordOrCreate(...)` call (which already records the event with success/failure), add:

    ```typescript
    // STAL-03: Failure-driven demotion / success restoration
    const isFailure = hookEventName === 'PostToolUseFailure';
    if (isFailure) {
      // Check sliding window: 3+ failures in last 5 events triggers demotion
      const recentEvents = toolRegistry.getRecentEventsForTool(
        toolName, projectHash ?? '', 5
      );
      const failures = recentEvents.filter(e => e.success === 0).length;
      if (failures >= 3) {
        toolRegistry.markDemoted(toolName, projectHash ?? null);
        debug('hook', 'Tool demoted due to failures', { tool: toolName, failures });
      }
    } else {
      // Successful use restores demoted tools immediately
      toolRegistry.markActive(toolName, projectHash ?? null);
    }
    ```

    Note: The `isFailure` variable already exists locally on line 82. Move the `isFailure` declaration ABOVE the recordOrCreate call so it can be reused, OR use a separate const. The cleanest approach: extract `isFailure` once at the top of the organic discovery block (it is already declared there as `const isFailure = hookEventName === 'PostToolUseFailure'`). The new code goes right after the `recordOrCreate` call, inside the same `try` block, so failures are non-fatal.

    The entire organic discovery + staleness block should look like:

    ```typescript
    if (toolRegistry) {
      try {
        const sessionId = input.session_id as string | undefined;
        const isFailure = hookEventName === 'PostToolUseFailure';
        toolRegistry.recordOrCreate(toolName, {
          toolType: inferToolType(toolName),
          scope: inferScope(toolName),
          source: 'hook:PostToolUse',
          projectHash: projectHash ?? null,
          description: null,
          serverName: extractServerName(toolName),
        }, sessionId ?? null, !isFailure);

        // STAL-03: Failure-driven demotion / success restoration
        if (isFailure) {
          const recentEvents = toolRegistry.getRecentEventsForTool(
            toolName, projectHash ?? '', 5,
          );
          const failures = recentEvents.filter(e => e.success === 0).length;
          if (failures >= 3) {
            toolRegistry.markDemoted(toolName, projectHash ?? null);
            debug('hook', 'Tool demoted due to failures', { tool: toolName, failures });
          }
        } else {
          toolRegistry.markActive(toolName, projectHash ?? null);
        }
      } catch {
        // Non-fatal: registry is supplementary to core memory function
      }
    }
    ```
  </action>
  <verify>Run `npx tsc --noEmit` -- zero type errors. Run `npx vitest run` -- all existing tests pass (handler tests should still pass since registry is optional in tests).</verify>
  <done>PostToolUseFailure events check the last 5 events; 3+ failures triggers demotion. Successful tool use calls markActive to restore demoted tools. All logic is inside try/catch (non-fatal).</done>
</task>

<task type="auto">
  <name>Task 3: Ranking deprioritization, routing exclusion, and search status display (STAL-02)</name>
  <files>src/context/injection.ts, src/routing/conversation-router.ts, src/mcp/tools/discover-tools.ts</files>
  <action>
    **1. injection.ts -- Age-based and status-based score penalty in rankToolsByRelevance:**

    In the `rankToolsByRelevance` function, after computing the frequency share score for each tool (`return { row, score: count / totalEvents }`), add status-based and age-based penalties.

    Modify the `scored` mapping to apply penalties:

    ```typescript
    const scored = tools.map(row => {
      let count: number | undefined = statsMap.get(row.name)?.usage_count;

      if (count === undefined && row.tool_type === 'mcp_server' && row.server_name) {
        count = serverStats.get(row.server_name)?.usage_count;
      }

      if (count === undefined) {
        return { row, score: 0 };
      }

      let score = count / totalEvents;

      // STAL-02/03: Deprioritize stale and demoted tools
      if (row.status === 'stale' || row.status === 'demoted') {
        score *= 0.25;  // Reduce to 25% of normal score
      }

      // STAL-02: Age-based deprioritization for tools not seen in 30+ days
      // "Last seen" = MAX(COALESCE(last_used_at, discovered_at), updated_at)
      // Computed in JS since we already have the row data
      const lastUsed = row.last_used_at || row.discovered_at;
      const lastSeen = new Date(Math.max(
        new Date(lastUsed).getTime(),
        new Date(row.updated_at).getTime(),
      ));
      const daysSinceLastSeen = (Date.now() - lastSeen.getTime()) / (1000 * 60 * 60 * 24);
      if (daysSinceLastSeen > 30) {
        score *= 0.5;  // Additional 50% penalty for age (stacks with status penalty)
      }

      return { row, score };
    });
    ```

    **2. conversation-router.ts -- Filter stale/demoted from suggestable tools:**

    In the `_evaluate` method, modify the `suggestableTools` filter (currently at line ~117) to also exclude stale and demoted tools:

    ```typescript
    const suggestableTools = availableTools.filter(
      (t: ToolRegistryRow) =>
        t.tool_type !== 'builtin' &&
        !isLaminarksOwnTool(t.name) &&
        t.status === 'active',  // STAL: Only suggest tools in good standing
    );
    ```

    Note: Import `ToolRegistryRow` is already imported. The `status` field is available because ToolRegistryRow was updated in Plan 01.

    **3. discover-tools.ts -- Show status in search results:**

    In the `formatToolResult` function, add a status indicator for non-active tools. After the description line, add:

    ```typescript
    function formatToolResult(result: ToolSearchResult, index: number): string {
      const { tool, score } = result;
      const description = tool.description ? ` -- ${tool.description}` : '';
      const statusTag = tool.status !== 'active' ? ` [${tool.status}]` : '';
      const usageStr = tool.usage_count > 0 ? `${tool.usage_count} uses` : 'never used';
      const lastUsedStr = tool.last_used_at ? `last: ${tool.last_used_at.slice(0, 10)}` : 'never';
      return `${index}. ${tool.name}${statusTag}${description}\n   [${tool.scope}] | ${usageStr} | ${lastUsedStr} | score: ${score.toFixed(2)}`;
    }
    ```

    This shows `[stale]` or `[demoted]` next to the tool name in search results, while active tools show no tag.
  </action>
  <verify>Run `npx tsc --noEmit` -- zero type errors. Run `npx vitest run` -- all existing tests pass. Visually inspect the three files to confirm the changes are in the right locations.</verify>
  <done>rankToolsByRelevance applies 0.25x penalty for stale/demoted status and 0.5x penalty for 30+ days age. ConversationRouter only suggests active tools. discover_tools shows [stale]/[demoted] status markers in search results.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx vitest run` passes with zero regressions
3. `npx tsdown` builds successfully
4. session-lifecycle.ts has detectRemovedTools function called after config scan
5. handler.ts has failure demotion (3-of-5 window) and success restoration
6. injection.ts rankToolsByRelevance applies status and age penalties
7. conversation-router.ts filters suggestable tools to status === 'active'
8. discover-tools.ts shows status markers for stale/demoted tools
</verification>

<success_criteria>
- STAL-01: Config rescan at SessionStart compares scanned tools against registry and marks missing config-sourced tools as stale (including individual tools from removed MCP servers)
- STAL-02: Tools not seen in 30+ days receive a 0.5x score penalty in ranking; stale/demoted tools receive 0.25x penalty
- STAL-03: PostToolUseFailure checks last 5 events; 3+ failures triggers demotion; single success restores to active
- Routing only suggests active tools (stale/demoted excluded from ConversationRouter)
- discover_tools search shows [stale] or [demoted] markers on non-active tools
- All existing tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/16-staleness-management/16-02-SUMMARY.md`
</output>
