---
phase: 16-staleness-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/migrations.ts
  - src/shared/tool-types.ts
  - src/storage/tool-registry.ts
autonomous: true

must_haves:
  truths:
    - "Tools have a three-state status: active, stale, or demoted"
    - "Storage layer can mark tools stale, demoted, or active"
    - "Storage layer can query config-sourced tools for staleness comparison"
    - "Storage layer can query recent events for failure rate checking"
  artifacts:
    - path: "src/storage/migrations.ts"
      provides: "Migration 19: status column on tool_registry with index"
      contains: "ALTER TABLE tool_registry ADD COLUMN status"
    - path: "src/shared/tool-types.ts"
      provides: "status field on ToolRegistryRow interface"
      contains: "status: string"
    - path: "src/storage/tool-registry.ts"
      provides: "markStale, markDemoted, markActive, getConfigSourcedTools, getRecentEventsForTool methods"
      contains: "markStale"
  key_links:
    - from: "src/storage/tool-registry.ts"
      to: "src/storage/migrations.ts"
      via: "Migration 19 adds status column that new prepared statements query"
      pattern: "status"
    - from: "src/storage/tool-registry.ts"
      to: "src/shared/tool-types.ts"
      via: "ToolRegistryRow type includes status field"
      pattern: "ToolRegistryRow"
---

<objective>
Add the staleness data model and storage methods to the tool registry.

Purpose: All three staleness mechanisms (config removal detection, age-based deprioritization, failure-driven demotion) require a `status` column on `tool_registry` and new query methods on `ToolRegistryRepository`. This plan creates the foundation that Plan 02 wires into the hook handlers and ranking system.

Output: Migration 19, updated ToolRegistryRow type, and 5 new methods on ToolRegistryRepository.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/storage/migrations.ts
@src/shared/tool-types.ts
@src/storage/tool-registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migration 19 and ToolRegistryRow type update</name>
  <files>src/storage/migrations.ts, src/shared/tool-types.ts</files>
  <action>
    1. In `src/storage/migrations.ts`, add migration 19 after the existing migration 18:

    ```typescript
    {
      version: 19,
      name: 'add_tool_registry_status',
      up: `
        ALTER TABLE tool_registry ADD COLUMN status TEXT NOT NULL DEFAULT 'active';
        CREATE INDEX idx_tool_registry_status ON tool_registry(status);
      `,
    },
    ```

    Update the JSDoc comment at the top of the MIGRATIONS array to include:
    `Migration 019: Add status column (active/stale/demoted) to tool_registry for staleness management.`

    2. In `src/shared/tool-types.ts`, add `status: string;` to the `ToolRegistryRow` interface after the `updated_at` field:

    ```typescript
    status: string;  // 'active' | 'stale' | 'demoted'
    ```
  </action>
  <verify>Run `npx tsc --noEmit` to confirm type changes compile without errors. Verify migration 19 is the last entry in the MIGRATIONS array.</verify>
  <done>Migration 19 exists with ALTER TABLE + index. ToolRegistryRow includes `status: string` field.</done>
</task>

<task type="auto">
  <name>Task 2: Staleness methods on ToolRegistryRepository</name>
  <files>src/storage/tool-registry.ts</files>
  <action>
    Add 5 new prepared statements and methods to `ToolRegistryRepository`:

    1. **stmtMarkStale** -- Updates status to 'stale' for a tool by name and project_hash. Uses `COALESCE(project_hash, '') = COALESCE(?, '')` for NULL-safe matching (existing pattern). Also sets `updated_at = datetime('now')`. Only updates if current status is not already 'stale' (idempotent).

    2. **stmtMarkDemoted** -- Updates status to 'demoted' for a tool by name and project_hash. Same NULL-safe COALESCE pattern. Sets `updated_at = datetime('now')`.

    3. **stmtMarkActive** -- Updates status to 'active' for a tool by name and project_hash. Same NULL-safe COALESCE pattern. Sets `updated_at = datetime('now')`. Only updates if current status is not already 'active' (idempotent).

    4. **stmtGetConfigSourced** -- Selects all tool_registry rows where `source LIKE 'config:%'` AND status = 'active' AND `(project_hash = ? OR project_hash IS NULL)`. This retrieves both project-level and global config-sourced tools for staleness comparison. Returns `ToolRegistryRow[]`.

    5. **stmtGetRecentEventsForTool** -- Selects the `success` column from `tool_usage_events` WHERE `tool_name = ? AND project_hash = ?` ORDER BY `created_at DESC` LIMIT `?`. Returns `Array<{ success: number }>`.

    Add these as class fields (private readonly) alongside existing prepared statements. Prepare them in the constructor inside the existing try block. Add corresponding public methods:

    ```typescript
    markStale(name: string, projectHash: string | null): void
    markDemoted(name: string, projectHash: string | null): void
    markActive(name: string, projectHash: string | null): void
    getConfigSourcedTools(projectHash: string): ToolRegistryRow[]
    getRecentEventsForTool(toolName: string, projectHash: string, limit?: number): Array<{ success: number }>
    ```

    For `getRecentEventsForTool`, default limit to 5.

    Each mark* method should be wrapped in try/catch with debug logging (matching existing patterns like recordUsage). The getConfigSourcedTools and getRecentEventsForTool methods should also have try/catch with debug logging.

    Also update `stmtGetAvailableForSession` to add status-aware ordering. Prepend to the existing ORDER BY:
    ```sql
    CASE status
      WHEN 'active' THEN 0
      WHEN 'stale' THEN 1
      WHEN 'demoted' THEN 2
      ELSE 3
    END,
    ```
    This sorts stale/demoted tools AFTER active tools, preserving the existing tool_type and usage_count ordering within each status group.

    Also update the `stmtUpsert` to include `status = 'active'` in the ON CONFLICT DO UPDATE SET clause, so that tools re-discovered via config scan are restored to active status automatically.
  </action>
  <verify>Run `npx tsc --noEmit` -- zero type errors. Run `npx vitest run` -- all existing tests pass. Verify the 5 new methods exist on the class by checking the file.</verify>
  <done>ToolRegistryRepository has markStale, markDemoted, markActive, getConfigSourcedTools, and getRecentEventsForTool methods. getAvailableForSession sorts by status. Upsert restores active status.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx vitest run` passes with zero regressions
3. Migration 19 is version 19 in the MIGRATIONS array
4. ToolRegistryRow.status field exists in tool-types.ts
5. All 5 new methods exist on ToolRegistryRepository
6. stmtGetAvailableForSession includes status-based ordering
</verification>

<success_criteria>
- Migration 19 adds `status TEXT NOT NULL DEFAULT 'active'` column and index to tool_registry
- ToolRegistryRow interface includes `status: string`
- ToolRegistryRepository has markStale, markDemoted, markActive, getConfigSourcedTools, getRecentEventsForTool
- getAvailableForSession sorts active before stale before demoted
- Upsert restores active status on re-discovery
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/16-staleness-management/16-01-SUMMARY.md`
</output>
