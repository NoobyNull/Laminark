---
phase: 13-context-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/context/injection.ts
  - src/context/injection.test.ts
autonomous: true

must_haves:
  truths:
    - "Session start injection includes a ranked 'Available Tools' section where the most recently and frequently used tools appear first"
    - "The tool section output never exceeds 500 characters regardless of how many tools are in the registry"
    - "The overall session context injection never exceeds 6000 characters"
    - "Tools with no recent usage (last 7 days) are sorted below recently-used tools"
    - "MCP server entries aggregate usage counts from their individual tool events for accurate scoring"
  artifacts:
    - path: "src/context/injection.ts"
      provides: "rankToolsByRelevance function, TOOL_SECTION_BUDGET constant, updated formatToolSection with sub-budget, updated assembleSessionContext with getUsageSince call"
      contains: "TOOL_SECTION_BUDGET"
    - path: "src/context/injection.test.ts"
      provides: "Tests for relevance ranking, sub-budget enforcement, and assembleSessionContext integration"
      contains: "rankToolsByRelevance"
  key_links:
    - from: "src/context/injection.ts"
      to: "src/storage/tool-registry.ts"
      via: "toolRegistry.getUsageSince(projectHash, '-7 days')"
      pattern: "getUsageSince"
    - from: "src/context/injection.ts (rankToolsByRelevance)"
      to: "src/shared/tool-types.ts (ToolUsageStats)"
      via: "import type"
      pattern: "ToolUsageStats"
---

<objective>
Add relevance-ranked tool suggestions with a 500-character sub-budget to session start context injection.

Purpose: Claude starts every session knowing not just what happened last time, but which tools are most relevant right now -- ranked by how often and how recently they were used in this project, within a compact budget that preserves room for memory observations.

Output: Modified `formatToolSection` with sub-budget enforcement, new `rankToolsByRelevance` scoring function, and `assembleSessionContext` wired to `getUsageSince` for temporal usage data. Implements CTXT-01, CTXT-02, CTXT-03.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-scope-resolution/11-01-SUMMARY.md
@.planning/phases/12-usage-tracking/12-01-SUMMARY.md
@.planning/phases/13-context-enhancement/13-RESEARCH.md
@src/context/injection.ts
@src/storage/tool-registry.ts
@src/shared/tool-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add relevance ranking and 500-char sub-budget to tool section</name>
  <files>src/context/injection.ts</files>
  <action>
Modify `src/context/injection.ts` to implement relevance-ranked tool suggestions with a 500-character sub-budget. All new functions are module-internal (not exported) per decision [11-01].

**Step 1 - Add import and constant:**
- Add `import type { ToolUsageStats } from '../shared/tool-types.js';` alongside the existing `ToolRegistryRow` import.
- Add constant `const TOOL_SECTION_BUDGET = 500;` after the existing `MAX_TOOLS_IN_CONTEXT` constant.

**Step 2 - Add `rankToolsByRelevance` function** (module-internal, not exported):
Place this function BEFORE `formatToolSection` in the file. It takes `tools: ToolRegistryRow[]` and `usageStats: ToolUsageStats[]`, returns `ToolRegistryRow[]` sorted by relevance score.

Implementation:
1. If `usageStats` is empty, return `tools` unchanged (no temporal data to rank by).
2. Build a `Map<string, ToolUsageStats>` lookup from `usageStats` keyed by `tool_name`.
3. Build a second `Map<string, { usage_count: number; last_used: string }>` aggregating stats by MCP server prefix. For each stat where `tool_name` matches `/^mcp__([^_]+(?:_[^_]+)*)__/`, extract the server name and aggregate: sum `usage_count`, keep the most recent `last_used`. This handles Pitfall 4 from research -- MCP server entries get usage credit from their individual tools.
4. Compute `maxUsage = Math.max(1, ...allCounts)` where `allCounts` includes both direct and server-aggregated counts. The `1` floor prevents division by zero (Pitfall 1).
5. For each tool, compute relevance score:
   - Look up stats directly by `tool.name` first.
   - If not found AND `tool.tool_type === 'mcp_server'` AND `tool.server_name` exists, use the server-aggregated stats.
   - If no stats found, score = 0.
   - Otherwise: `normalizedFrequency = stat.usage_count / maxUsage`, `ageDays = Math.max(0, (Date.now() - new Date(stat.last_used).getTime()) / (86400000))`, `recencyScore = Math.exp(-0.693 * ageDays / 7)`, `score = normalizedFrequency * 0.7 + recencyScore * 0.3`. The `Math.max(0, ageDays)` clamp handles Pitfall 2 (clock skew).
6. Sort by score descending. Ties broken by lifetime `usage_count` descending.
7. Return `scored.map(s => s.row)`.

**Step 3 - Modify `formatToolSection` to enforce 500-char sub-budget:**
The function signature stays the same: `function formatToolSection(tools: ToolRegistryRow[]): string`.

Changes:
1. Keep the existing dedup logic (seenServers, two-pass) and builtin filter unchanged.
2. Remove the `const limited = displayable.slice(0, MAX_TOOLS_IN_CONTEXT);` line -- the 500-char sub-budget is now the primary limiter. Keep `MAX_TOOLS_IN_CONTEXT` as a constant for safety but do not use it in the slice.
3. Initialize `const lines: string[] = ['## Available Tools'];`
4. Loop through `displayable` (all deduped non-builtin tools, not sliced). For each tool, format the line using the existing if/else chain (mcp_server, slash_command, skill, plugin, other).
5. After formatting each line, check: `if ([...lines, candidateLine].join('\n').length > TOOL_SECTION_BUDGET) break;` -- this incremental check prevents exceeding the budget (Pitfall 3: header is included in the count from the start).
6. Push the line to `lines` only if it fits.
7. After the loop, add an overflow indicator: if `displayable.length > (lines.length - 1)` and at least one tool was added, compute `const overflow = \`(\${displayable.length - (lines.length - 1)} more available)\`;` and add it only if the total with overflow still fits within `TOOL_SECTION_BUDGET`.
8. Return `lines.join('\n')`.

**Step 4 - Modify `assembleSessionContext` to wire in ranking:**
In the existing `if (toolRegistry)` block (around line 340), change:
```
const availableTools = toolRegistry.getAvailableForSession(projectHash);
toolSection = formatToolSection(availableTools);
```
to:
```
const availableTools = toolRegistry.getAvailableForSession(projectHash);
const usageStats = toolRegistry.getUsageSince(projectHash, '-7 days');
const ranked = rankToolsByRelevance(availableTools, usageStats);
toolSection = formatToolSection(ranked);
```

The rest of `assembleSessionContext` (budget trimming that drops toolSection first) stays unchanged per Pitfall 5 in research.

**What NOT to do:**
- Do NOT export `rankToolsByRelevance` or `formatToolSection` -- they are module-internal per [11-01].
- Do NOT modify the SQL in `getAvailableForSession` -- scoring is done in TypeScript.
- Do NOT use `estimateTokens()` from token-budget.ts -- the requirement specifies characters.
- Do NOT remove `MAX_TOOLS_IN_CONTEXT` constant (it may be used by future code).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify type checking passes. Manually inspect `src/context/injection.ts` to confirm:
1. `TOOL_SECTION_BUDGET = 500` constant exists
2. `rankToolsByRelevance` function exists and is NOT exported
3. `formatToolSection` uses incremental budget checking
4. `assembleSessionContext` calls `getUsageSince` and `rankToolsByRelevance`
  </verify>
  <done>
`injection.ts` contains a `rankToolsByRelevance` function that computes `score = normalizedFrequency * 0.7 + recencyScore * 0.3` with exponential decay recency and MCP server aggregation, a `formatToolSection` that enforces a 500-character sub-budget via incremental line checking, and `assembleSessionContext` that queries `getUsageSince(projectHash, '-7 days')` to feed temporal data into the ranking pipeline.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix pre-existing test failures and add Phase 13 test coverage</name>
  <files>src/context/injection.test.ts</files>
  <action>
Modify `src/context/injection.test.ts` to fix pre-existing broken tests and add coverage for the new relevance ranking and sub-budget features.

**Step 1 - Fix pre-existing `formatContextIndex` test failures:**
The tests at lines 110-189 call `formatContextIndex(session, observations)` with a flat `Observation[]` array as the second argument. The function signature was changed in Phase 11 to accept `{ changes, decisions, findings, references }` sections object. Fix these tests:

1. `'produces expected format with session and 3 observations'` (line 110): Change the second argument from `observations` array to `{ changes: observations, decisions: [], findings: [], references: [] }`. Update assertions to match the new format: replace `'[Laminark Context - Session Recovery]'` with `'[Laminark - Session Context]'`, replace `'## Last Session (2026-02-09T10:00:00Z to 2026-02-09T11:30:00Z)'` with `'## Previous Session'`, replace `'## Recent Memories (use search tool for full details)'` with `'## Recent Changes'`. Remove assertions about `source:` tags (the new format does not include source in each line). Update observation line assertions: lines now use `- CONTENT (RELATIVE_TIME)` format instead of `- [SHORT_ID] CONTENT (source: SOURCE)`.

2. `'shows only observations when session is null'` (line 131): Change second arg to `{ changes: observations, decisions: [], findings: [], references: [] }`. Update assertions to match new format (same replacements as above).

3. `'returns welcome message when session is null and observations are empty'` (line 144): Change second arg from `[]` to `{ changes: [], decisions: [], findings: [], references: [] }`. Assertions should still pass (welcome message logic unchanged).

4. `'returns welcome message when session has no summary and no observations'` (line 152): Change second arg from `[]` to `{ changes: [], decisions: [], findings: [], references: [] }`. Assertions should still pass.

5. `'truncates observation content at 120 characters'` (line 161): Change second arg from `observations` to `{ changes: observations, decisions: [], findings: [], references: [] }`. Assertions about `'A'.repeat(120) + '...'` should still pass (truncation logic unchanged).

6. `'each observation is a single line'` (line 174): Change second arg from `observations` to `{ changes: observations, decisions: [], findings: [], references: [] }`. Update the line detection: instead of `l.startsWith('- [')`, use `l.startsWith('- ')` since the new format does not prefix with `[SHORT_ID]`.

**Step 2 - Fix pre-existing `assembleSessionContext` test assertions:**
Two tests reference old format strings:
1. `'includes last session summary in output'` (line 219): Change `'[Laminark Context - Session Recovery]'` to `'[Laminark - Session Context]'`.
2. `'includes recent observations in output'` (line 230): Remove the assertion `expect(result).toContain('source: hook:Write')` since the new format does not include source tags in each line. The content assertion should still pass.

**Step 3 - Add new test describe block for ranking and sub-budget:**
Add a new `describe('tool ranking and sub-budget')` block. Since `rankToolsByRelevance` and `formatToolSection` are module-internal (not exported), test them indirectly through `assembleSessionContext` with a real database and `ToolRegistryRepository`.

Tests to add:

1. `'tool section fits within 500-character sub-budget'`: Create a `ToolRegistryRepository` from the test DB. Use `upsert()` to register 20+ tools with different names. Call `assembleSessionContext(db, projectHash, toolRegistry)`. Extract the tool section from the result (everything from `'## Available Tools'` to the end or next section). Assert `toolSection.length <= 500`.

2. `'recently-used tools appear before unused tools'`: Register 3 tools: tool-A (no usage), tool-B (5 usages in last 7 days), tool-C (2 usages in last 7 days). Use `recordOrCreate` with a session ID to create usage events for tool-B (call 5 times) and tool-C (call 2 times). Call `assembleSessionContext`. Extract the tool section. Assert that tool-B appears before tool-C, and tool-C appears before tool-A.

3. `'tool section is empty string when no non-builtin tools exist'`: Register only built-in tools. Call `assembleSessionContext`. Assert the result does NOT contain `'## Available Tools'`.

4. `'overall context stays under 6000 characters with tools'`: Register 20 tools, create usage events for all. Create a session with a large summary (~2000 chars). Create several observations. Call `assembleSessionContext`. Assert `result.length <= 6000`.

Import `ToolRegistryRepository` from `'../storage/tool-registry.js'` at the top of the test file.

**What NOT to do:**
- Do NOT try to export `rankToolsByRelevance` or `formatToolSection` just for testing. Test through the public `assembleSessionContext` API.
- Do NOT remove the existing passing tests -- only fix the broken ones.
  </action>
  <verify>
Run `npx vitest run src/context/injection.test.ts` and verify all tests pass (0 failures). The pre-existing 8 failures should be resolved and the new Phase 13 tests should pass.
  </verify>
  <done>
All `formatContextIndex` tests pass with the updated sections-object signature. All `assembleSessionContext` tests pass with updated format assertions. New tests verify: (1) tool section fits within 500 characters, (2) recently-used tools are ranked above unused tools, (3) empty tool section when only builtins exist, (4) overall context stays under 6000 chars with tools present. Zero test failures.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. `npx vitest run src/context/injection.test.ts` passes all tests (0 failures)
3. `TOOL_SECTION_BUDGET = 500` constant exists in injection.ts
4. `rankToolsByRelevance` is defined but NOT exported
5. `formatToolSection` enforces incremental 500-char budget checking
6. `assembleSessionContext` calls both `getAvailableForSession` and `getUsageSince`
7. Tool section budget trimming (dropped first on overall overflow) is preserved
</verification>

<success_criteria>
- Session start injection includes an "Available Tools" section listing the most relevant tools
- Tool suggestions section fits within a 500-character sub-budget
- Tools are ranked by relevance score = frequency * 0.7 + recency * 0.3
- MCP server entries aggregate usage from individual tool events
- Overall context injection does not exceed 6000 characters
- All injection.test.ts tests pass (pre-existing failures fixed + new Phase 13 tests added)
</success_criteria>

<output>
After completion, create `.planning/phases/13-context-enhancement/13-01-SUMMARY.md`
</output>
