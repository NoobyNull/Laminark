---
phase: 06-topic-detection-and-context-stashing
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - src/hooks/topic-shift-handler.ts
  - src/hooks/__tests__/topic-shift-handler.test.ts
  - src/commands/stash.ts
autonomous: true

must_haves:
  truths:
    - "When a new observation embedding has high cosine distance from previous, the current context thread is automatically stashed"
    - "User is notified that context was stashed with a message indicating /memorite:resume"
    - "User can manually stash current context via /memorite:stash slash command"
    - "Stash includes a summary of the topic and snapshot of relevant observations"
  artifacts:
    - path: "src/hooks/topic-shift-handler.ts"
      provides: "TopicShiftHandler that wires detector + stash manager into hook pipeline"
      exports: ["TopicShiftHandler"]
    - path: "src/commands/stash.ts"
      provides: "/memorite:stash slash command handler"
      exports: ["handleStashCommand"]
  key_links:
    - from: "src/hooks/topic-shift-handler.ts"
      to: "src/intelligence/topic-detector.ts"
      via: "TopicShiftDetector.detect() call"
      pattern: "detector\\.detect"
    - from: "src/hooks/topic-shift-handler.ts"
      to: "src/storage/stash-manager.ts"
      via: "StashManager.createStash() call"
      pattern: "stashManager\\.createStash"
    - from: "src/hooks/topic-shift-handler.ts"
      to: "notification mechanism"
      via: "returns notification message string"
      pattern: "notification|stashed.*resume"
---

<objective>
Wire the topic shift detector and stash manager into the hook pipeline so that automatic stashing occurs on detected topic shifts. Add user notification and the /memorite:stash manual stash command.

Purpose: This is the integration layer that makes topic detection active. Plan 01 built the detector, Plan 02 built storage -- this plan connects them into the live hook flow and adds user-facing notification per CTX-03, CTX-04, and UI-04.

Output: TopicShiftHandler that runs on each PostToolUse, /memorite:stash command handler, notification message format.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-topic-detection-and-context-stashing/06-01-SUMMARY.md
@.planning/phases/06-topic-detection-and-context-stashing/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: TopicShiftHandler integration class</name>
  <files>src/hooks/topic-shift-handler.ts, src/hooks/__tests__/topic-shift-handler.test.ts</files>
  <action>
    Create TopicShiftHandler class that orchestrates topic detection and stashing:

    Constructor accepts: { detector: TopicShiftDetector, stashManager: StashManager, embeddingEngine: EmbeddingEngine (from Phase 4), observationStore: ObservationStore (from Phase 1) }

    Method: async handleObservation(observation: Observation, sessionId: string, projectId: string): Promise of { stashed: boolean, notification: string | null }

    Logic:
    1. If observation has no embedding, skip detection (return { stashed: false, notification: null })
    2. Call detector.detect(observation.embedding)
    3. If shifted:
       a. Gather recent observations for the PREVIOUS topic (query observations from current session where timestamp < this observation, limit to last 20)
       b. Generate a topic label from the previous observations (use first observation's first 50 chars or a simple keyword extraction -- keep it simple, no LLM call)
       c. Generate a brief summary (concatenate first 3 observation contents, truncated to 200 chars total)
       d. Call stashManager.createStash({ projectId, sessionId, topicLabel, summary, observations: snapshotted })
       e. Return { stashed: true, notification: "Topic shift detected. Previous context stashed: \"{topicLabel}\". Use /memorite:resume to return." }
    4. If not shifted: return { stashed: false, notification: null }

    The notification string is what gets surfaced to the user (Plan 03 just returns it; the MCP response layer or hook response includes it).

    Write tests with mocked dependencies:
    - Observation with high-distance embedding triggers stash creation
    - Observation with low-distance embedding does not trigger stash
    - Observation without embedding is skipped
    - Notification message includes topic label and /memorite:resume hint
    - Previous observations are correctly gathered for stash snapshot
  </action>
  <verify>`npm test -- --testPathPattern=topic-shift-handler` passes. Handler correctly orchestrates detector + stash manager.</verify>
  <done>TopicShiftHandler detects shifts, creates stashes, and returns notification strings. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: /memorite:stash slash command</name>
  <files>src/commands/stash.ts</files>
  <action>
    Create the /memorite:stash slash command handler (follow the pattern established by /memorite:remember and /memorite:recall from Phase 5):

    Export async function handleStashCommand(args: { projectId: string, sessionId: string, label?: string }, deps: { stashManager: StashManager, observationStore: ObservationStore }): Promise of { success: boolean, message: string }

    Logic:
    1. Gather recent observations from current session (last 20 observations for current projectId + sessionId)
    2. If no observations found, return { success: false, message: "No observations in current session to stash." }
    3. Generate topicLabel from args.label if provided, otherwise extract from first observation content (first 50 chars)
    4. Generate summary (concatenate first 3 observation contents, truncated to 200 chars)
    5. Create snapshot of observations as StashObservation[] (map: id, content, type, timestamp, embedding)
    6. Call stashManager.createStash(...)
    7. Return { success: true, message: "Context stashed: \"{topicLabel}\". Use /memorite:resume to return to it." }

    Register in the slash command router (wherever Phase 5 established the pattern -- likely src/commands/index.ts or similar).
  </action>
  <verify>Manual test: calling handleStashCommand with mock dependencies returns correct message. Integration with slash command router confirmed.</verify>
  <done>/memorite:stash saves current session observations as a stash. Returns confirmation message. Registered in command router.</done>
</task>

</tasks>

<verification>
- TopicShiftHandler correctly wires detector.detect() -> stashManager.createStash() on shift
- Notification message format includes topic label and /memorite:resume instruction
- /memorite:stash command manually creates stash from current session
- No stash created when no topic shift detected
- No stash created when observation lacks embedding
</verification>

<success_criteria>
- Automatic stashing triggers on topic shift detection (INT-05, CTX-03)
- User notification returned on stash (CTX-04)
- /memorite:stash manual command works (UI-04)
- Integration tests pass with mocked dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/06-topic-detection-and-context-stashing/06-03-SUMMARY.md`
</output>
