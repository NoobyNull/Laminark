---
phase: 06-topic-detection-and-context-stashing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/migrations/006-context-stashes.sql
  - src/storage/stash-manager.ts
  - src/storage/__tests__/stash-manager.test.ts
  - src/types/stash.ts
autonomous: true

must_haves:
  truths:
    - "A context thread (observations + summary) can be saved as a stash record"
    - "Stashed threads can be listed ordered by recency"
    - "A specific stash can be retrieved by ID with its full observation snapshot"
    - "Stashes are scoped to project and session"
  artifacts:
    - path: "src/storage/migrations/006-context-stashes.sql"
      provides: "context_stashes table schema"
      contains: "CREATE TABLE context_stashes"
    - path: "src/storage/stash-manager.ts"
      provides: "StashManager class with CRUD operations"
      exports: ["StashManager"]
    - path: "src/types/stash.ts"
      provides: "Stash type definitions"
      exports: ["ContextStash", "StashObservation", "CreateStashInput"]
  key_links:
    - from: "src/storage/stash-manager.ts"
      to: "database"
      via: "SQLite prepared statements"
      pattern: "db\\.(prepare|run|all|get)"
    - from: "src/storage/stash-manager.ts"
      to: "src/types/stash.ts"
      via: "type imports"
      pattern: "import.*from.*stash"
---

<objective>
Create the context stashing storage layer: database schema for stash records and a StashManager class that creates, lists, retrieves, and deletes stashed context threads.

Purpose: Context stashing is the core persistence mechanism for Phase 6. When topic detection fires, the current thread's observations and summary must be snapshotted and stored so the user can resume later. This plan builds the storage foundation that Plans 03 and 04 consume.

Output: Migration SQL, StashManager class with full CRUD, type definitions, and tests.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stash types and database migration</name>
  <files>src/types/stash.ts, src/storage/migrations/006-context-stashes.sql</files>
  <action>
    Create src/types/stash.ts with:
    - ContextStash interface: { id: string, projectId: string, sessionId: string, topicLabel: string, summary: string, observationIds: string[], observationSnapshots: StashObservation[], createdAt: string, resumedAt: string | null, status: 'stashed' | 'resumed' | 'expired' }
    - StashObservation interface: { id: string, content: string, type: string, timestamp: string, embedding: number[] | null }
    - CreateStashInput interface: { projectId: string, sessionId: string, topicLabel: string, summary: string, observations: StashObservation[] }

    Create migration 006-context-stashes.sql:
    - context_stashes table with columns: id TEXT PRIMARY KEY, project_id TEXT NOT NULL, session_id TEXT NOT NULL, topic_label TEXT NOT NULL, summary TEXT NOT NULL, observation_snapshots TEXT NOT NULL (JSON blob of StashObservation[]), observation_ids TEXT NOT NULL (JSON array of original observation IDs), status TEXT NOT NULL DEFAULT 'stashed', created_at TEXT NOT NULL DEFAULT (datetime('now')), resumed_at TEXT
    - Index on (project_id, status, created_at DESC) for listing stashes
    - Index on (session_id) for session-scoped queries

    Use UUID v4 for stash IDs (import from crypto.randomUUID or uuid package -- follow whatever pattern Phase 1 established for ID generation).
  </action>
  <verify>Migration SQL is syntactically valid. Type file exports all interfaces. No import errors.</verify>
  <done>context_stashes table schema defined with proper indexes. Stash type definitions exported.</done>
</task>

<task type="auto">
  <name>Task 2: StashManager class with CRUD and tests</name>
  <files>src/storage/stash-manager.ts, src/storage/__tests__/stash-manager.test.ts</files>
  <action>
    Create StashManager class accepting a database connection (same pattern as other managers from Phase 1):

    Methods:
    - createStash(input: CreateStashInput): Promise of ContextStash -- inserts row, JSON-serializes observation snapshots and IDs, returns full record
    - listStashes(projectId: string, options?: { sessionId?: string, status?: string, limit?: number }): Promise of ContextStash[] -- returns stashes ordered by created_at DESC, default limit 10
    - getStash(id: string): Promise of ContextStash | null -- retrieves single stash by ID, JSON-parses observation_snapshots back to StashObservation[]
    - resumeStash(id: string): Promise of ContextStash -- sets status='resumed', sets resumed_at=now(), returns updated record
    - deleteStash(id: string): Promise of void -- hard delete
    - getRecentStashes(projectId: string, limit?: number): Promise of ContextStash[] -- returns stashed (not resumed) threads ordered by created_at DESC

    Write tests using in-memory SQLite (follow established test patterns from Phase 1):
    - Create a stash and verify all fields persisted including JSON round-trip of observations
    - List stashes returns correct order (most recent first)
    - Filter by session_id works
    - Resume stash updates status and resumed_at
    - getRecentStashes excludes resumed stashes
    - getStash returns null for nonexistent ID
  </action>
  <verify>`npm test -- --testPathPattern=stash-manager` passes all cases. StashManager exports correctly.</verify>
  <done>StashManager creates, lists, retrieves, resumes, and deletes stashes with full JSON round-trip. All tests pass.</done>
</task>

</tasks>

<verification>
- Migration SQL creates context_stashes table with all required columns
- StashManager CRUD operations work with JSON serialization/deserialization
- Tests verify round-trip persistence of observation snapshots
- Type definitions are consistent between storage layer and interface
</verification>

<success_criteria>
- context_stashes table schema defined with indexes
- StashManager class with 6 methods, all tested
- Observation snapshots survive JSON round-trip through SQLite
- At least 6 test cases passing
</success_criteria>

<output>
After completion, create `.planning/phases/06-topic-detection-and-context-stashing/06-02-SUMMARY.md`
</output>
