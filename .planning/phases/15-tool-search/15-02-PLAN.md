---
phase: 15-tool-search
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/mcp/tools/discover-tools.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Claude can call discover_tools MCP tool to search the registry by keyword"
    - "Scope filter narrows results to global, project, or plugin when specified"
    - "Omitting scope searches all scopes (cross-scope default)"
    - "Search results include scope, usage count, and last used timestamp for each tool"
    - "Semantic search works: 'file manipulation' finds tools described as 'read and write files'"
    - "Tool descriptions are embedded in the background for vector search"
    - "MCP server entries are deduplicated against individual tool entries in results"
  artifacts:
    - path: "src/mcp/tools/discover-tools.ts"
      provides: "registerDiscoverTools function for MCP tool registration"
      exports: ["registerDiscoverTools"]
    - path: "src/index.ts"
      provides: "discover_tools registration and background tool embedding loop"
      contains: "registerDiscoverTools"
  key_links:
    - from: "src/mcp/tools/discover-tools.ts"
      to: "src/storage/tool-registry.ts"
      via: "toolRegistry.searchTools() call"
      pattern: "searchTools"
    - from: "src/index.ts"
      to: "src/mcp/tools/discover-tools.ts"
      via: "registerDiscoverTools import and call"
      pattern: "registerDiscoverTools"
    - from: "src/index.ts"
      to: "src/storage/tool-registry.ts"
      via: "findUnembeddedTools + storeEmbedding in background loop"
      pattern: "findUnembeddedTools"
---

<objective>
Create the `discover_tools` MCP tool and wire it into the MCP server, plus add background embedding of tool descriptions to the existing 5-second interval loop.

Purpose: This is the user-facing feature -- Claude can explicitly search and explore the tool registry. Background embedding enables semantic search (SRCH-02) so "file manipulation" finds tools described as "read and write files."

Output: Working `discover_tools` MCP tool callable from Claude Code, background tool embedding producing vectors for semantic search.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-tool-search/15-RESEARCH.md
@.planning/phases/15-tool-search/15-01-SUMMARY.md
@src/index.ts
@src/mcp/tools/recall.ts
@src/mcp/tools/query-graph.ts
@src/storage/tool-registry.ts
@src/shared/tool-types.ts
@src/search/hybrid.ts
@src/mcp/token-budget.ts
@src/context/injection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: discover_tools MCP tool implementation</name>
  <files>src/mcp/tools/discover-tools.ts</files>
  <action>
Create `src/mcp/tools/discover-tools.ts` following the exact MCP tool registration pattern from `recall.ts` and `query-graph.ts`.

1. Export `registerDiscoverTools` function with this signature (matching existing tool patterns):
   ```typescript
   export function registerDiscoverTools(
     server: McpServer,
     toolRegistry: ToolRegistryRepository,
     worker: AnalysisWorker | null,
     hasVectorSupport: boolean,
     notificationStore: NotificationStore | null,
     projectHash: string,
   ): void
   ```

2. Register tool named `'discover_tools'` with:
   - title: `'Discover Tools'`
   - description: `'Search the tool registry to find available tools by keyword or description. Supports semantic search -- "file manipulation" finds tools described as "read and write files". Returns scope, usage count, and last used timestamp for each result.'`
   - inputSchema using Zod:
     - `query`: z.string().min(1).describe('Search query: keywords or natural language description')
     - `scope`: z.enum(['global', 'project', 'plugin']).optional().describe('Optional scope filter. Omit to search all scopes.')
     - `limit`: z.number().int().min(1).max(50).default(20).describe('Maximum results to return (default: 20)')

3. Handler implementation:
   a. Prepend pending notifications (same pattern as recall.ts -- use `prependNotifications` helper or inline the pattern).
   b. Call `toolRegistry.searchTools(args.query, { scope: args.scope, limit: args.limit, worker, hasVectorSupport })`.
   c. Deduplicate results: prefer `mcp_server` entries over individual `mcp_tool` entries from the same server. Use the same deduplication logic as `formatToolSection` in injection.ts:
      - First pass: collect server names from mcp_server results into a Set
      - Second pass: filter out mcp_tool entries whose server_name is in the Set
   d. Format each result using a `formatToolResult` helper function (defined in this file):
      ```
      {index}. {tool.name}{description}
         [{scope}] | {usageStr} | {lastUsedStr} | score: {score}
      ```
      Where:
      - description = tool.description ? ` -- ${tool.description}` : ''
      - usageStr = tool.usage_count > 0 ? `${tool.usage_count} uses` : 'never used'
      - lastUsedStr = tool.last_used_at ? `last: ${tool.last_used_at.slice(0, 10)}` : 'never'
      - score = result.score.toFixed(2)
   e. Apply token budget enforcement via `enforceTokenBudget` from `../token-budget.js` with TOKEN_BUDGET (2000).
   f. Add metadata footer: `---\n{count} result(s) | query: "{query}" | scope: {scope or "all"}`
   g. If truncated, append ` | truncated` to footer.
   h. If zero results: return `No tools found matching "{query}".` with scope context if provided.
   i. Wrap entire handler in try/catch, return error response on failure (pattern from recall.ts).

4. Helper functions needed (private to this file):
   - `formatToolResult(result: ToolSearchResult, index: number): string` -- formats one search result
   - `textResponse(text: string)` -- returns `{ content: [{ type: 'text', text }] }` (same pattern as recall.ts)
   - `errorResponse(text: string)` -- returns `{ content: [{ type: 'text', text }], isError: true }`
   - Notification prepending (inline or extract from recall.ts pattern)
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles. Verify the file exports `registerDiscoverTools`. Verify it imports from `../../storage/tool-registry.js`, `../../search/hybrid.js`, and `../token-budget.js`.
  </verify>
  <done>
`discover_tools` MCP tool is implemented with hybrid search (FTS5+vector), scope filtering, deduplication of MCP server vs individual tool entries, result formatting with scope/usage/last-used metadata, and token budget enforcement. Follows exact patterns from recall.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire discover_tools registration and background tool embedding</name>
  <files>src/index.ts</files>
  <action>
1. Add import for `registerDiscoverTools` at the top of index.ts alongside the other tool imports:
   ```typescript
   import { registerDiscoverTools } from './mcp/tools/discover-tools.js';
   ```

2. Add import for `ToolRegistryRepository` (if not already imported):
   ```typescript
   import { ToolRegistryRepository } from './storage/tool-registry.js';
   ```

3. Create a ToolRegistryRepository instance after the database is opened (near the `projectHash` line, after `initGraphSchema`). Wrap in try/catch since the tool_registry table may not exist on first run before migrations:
   ```typescript
   let toolRegistry: ToolRegistryRepository | null = null;
   try {
     toolRegistry = new ToolRegistryRepository(db.db);
   } catch {
     debug('mcp', 'Tool registry not available (pre-migration-16)');
   }
   ```

4. Register `discover_tools` in the MCP server setup section (after the existing `registerStatus` call):
   ```typescript
   if (toolRegistry) {
     registerDiscoverTools(server, toolRegistry, worker, db.hasVectorSupport, notificationStore, projectHash);
   }
   ```

5. Add `processUnembeddedTools` function BEFORE the existing `setInterval` block (near `processUnembedded`). This function:
   - Returns early if toolRegistry is null, or worker is not ready, or !db.hasVectorSupport
   - Calls `toolRegistry.findUnembeddedTools(5)` to get tools needing embeddings
   - For each tool, embeds `${tool.name} ${tool.description}` via `worker.embed(text)`
   - If embedding succeeds, calls `toolRegistry.storeEmbedding(tool.id, embedding)`
   - Wraps everything in try/catch (non-fatal, debug logging only)
   ```typescript
   async function processUnembeddedTools(): Promise<void> {
     if (!toolRegistry || !worker.isReady() || !db.hasVectorSupport) return;

     try {
       const unembedded = toolRegistry.findUnembeddedTools(5);
       for (const tool of unembedded) {
         const text = `${tool.name} ${tool.description}`;
         const embedding = await worker.embed(text);
         if (embedding) {
           toolRegistry.storeEmbedding(tool.id, embedding);
         }
       }
     } catch (err) {
       const msg = err instanceof Error ? err.message : String(err);
       debug('embed', 'Tool embedding error (non-fatal)', { error: msg });
     }
   }
   ```

6. Add `processUnembeddedTools()` call to the existing 5-second `setInterval` block. Add it after the `processUnembedded().catch(...)` call:
   ```typescript
   processUnembeddedTools().catch((err) => {
     const message = err instanceof Error ? err.message : String(err);
     debug('embed', 'Tool embedding background error', { error: message });
   });
   ```
   This runs alongside observation embedding in the same interval -- no new timer needed.

7. Verify: The `registerDiscoverTools` call should be placed in the same section as the other `register*` calls, maintaining the existing code organization pattern.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles with no errors. Run `npx tsdown` (or the project's build command) to verify the build succeeds. Verify that `registerDiscoverTools` appears in the MCP server setup section of index.ts. Verify that `processUnembeddedTools` is called in the setInterval block.
  </verify>
  <done>
discover_tools MCP tool is registered on the MCP server alongside the 6 existing tools. Background tool embedding runs in the existing 5-second interval, embedding tool name+description for semantic search. The full Phase 15 feature is complete: Claude can call discover_tools to search the tool registry by keyword/semantic meaning with scope filtering, and results include scope, usage count, and last used timestamp.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Build succeeds (`npx tsdown` or project build command)
3. `discover_tools` is registered as an MCP tool (visible in server tool list)
4. Search results include: tool name, description, scope, usage count, last used date, match score
5. Scope filter works: passing scope='project' only returns project-scoped tools
6. Omitting scope returns tools from all scopes
7. MCP server entries are deduplicated against individual tool entries
8. Token budget limits output to ~2000 tokens
9. Background tool embedding processes unembedded tool descriptions every 5 seconds
</verification>

<success_criteria>
- Claude can call `discover_tools` with a keyword query and receive ranked tool results
- Scope filtering narrows results when specified; omitting scope searches all scopes
- Results show scope, usage count, and last used timestamp (SRCH-03)
- Tool descriptions are embedded in background for semantic search (SRCH-02)
- MCP server entries preferred over individual tool entries in deduplication
- Token budget enforced at 2000 tokens
- All errors handled gracefully with debug logging (non-fatal)
</success_criteria>

<output>
After completion, create `.planning/phases/15-tool-search/15-02-SUMMARY.md`
</output>
