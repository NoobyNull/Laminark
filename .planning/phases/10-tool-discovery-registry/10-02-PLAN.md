---
phase: 10-tool-discovery-registry
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/hooks/config-scanner.ts
  - src/hooks/tool-name-parser.ts
  - src/hooks/handler.ts
  - src/hooks/session-lifecycle.ts
autonomous: true

must_haves:
  truths:
    - "On SessionStart, Laminark reads .mcp.json, ~/.claude.json, command directories, skill directories, and installed_plugins.json to discover tools"
    - "Every discovered tool from config scanning is stored in the tool_registry table with scope, source, and type metadata"
    - "When Claude invokes any tool during a session, Laminark records the tool name in the registry via PostToolUse organic discovery"
    - "Organic discovery increments usage_count for already-known tools and creates new entries for unknown tools"
    - "A malformed config file does not crash the hook handler -- errors are caught and scanning continues with partial results"
    - "Laminark's own tool calls are recorded in the registry (organic discovery runs BEFORE the self-referential filter)"
  artifacts:
    - path: "src/hooks/config-scanner.ts"
      provides: "scanConfigForTools() function reading all Claude Code config surfaces"
      contains: "scanConfigForTools"
    - path: "src/hooks/tool-name-parser.ts"
      provides: "inferToolType(), inferScope(), extractServerName() for organic discovery"
      contains: "inferToolType"
    - path: "src/hooks/handler.ts"
      provides: "ToolRegistryRepository instantiation and organic discovery call in processPostToolUseFiltered"
      contains: "toolRegistry"
    - path: "src/hooks/session-lifecycle.ts"
      provides: "Config scanning integration in handleSessionStart"
      contains: "scanConfigForTools"
  key_links:
    - from: "src/hooks/handler.ts"
      to: "src/storage/tool-registry.ts"
      via: "Instantiates ToolRegistryRepository and passes to processPostToolUseFiltered"
      pattern: "new ToolRegistryRepository"
    - from: "src/hooks/handler.ts"
      to: "src/hooks/tool-name-parser.ts"
      via: "Calls inferToolType/inferScope/extractServerName for organic discovery"
      pattern: "inferToolType"
    - from: "src/hooks/session-lifecycle.ts"
      to: "src/hooks/config-scanner.ts"
      via: "Calls scanConfigForTools during SessionStart"
      pattern: "scanConfigForTools"
    - from: "src/hooks/session-lifecycle.ts"
      to: "src/storage/tool-registry.ts"
      via: "Upserts config-scanned tools into registry"
      pattern: "toolRegistry\\.upsert"
---

<objective>
Wire tool discovery into Laminark's hook pipeline: config scanning at SessionStart (DISC-01 through DISC-04) and organic recording at PostToolUse (DISC-05). This completes all Phase 10 requirements by connecting the storage foundation from Plan 01 to the live hook events.

Purpose: The tool_registry table from Plan 01 is empty until discovery populates it. Config scanning fills it proactively on each session start; organic discovery catches tools that config scanning missed (MCP tool names are not in config files -- only server names are). Together they provide complete tool awareness.

Output: Two new files (config-scanner.ts, tool-name-parser.ts) and two modified files (handler.ts, session-lifecycle.ts).
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-tool-discovery-registry/10-RESEARCH.md
@.planning/phases/10-tool-discovery-registry/10-01-SUMMARY.md
@src/hooks/handler.ts
@src/hooks/session-lifecycle.ts
@src/hooks/self-referential.ts
@src/storage/tool-registry.ts
@src/shared/tool-types.ts
@src/shared/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config scanner and tool name parser</name>
  <files>src/hooks/config-scanner.ts, src/hooks/tool-name-parser.ts</files>
  <action>
    **Create `src/hooks/tool-name-parser.ts`:**

    Three pure functions for extracting metadata from tool names seen in PostToolUse:

    1. `inferToolType(toolName: string): ToolType` --
       - If `toolName.startsWith('mcp__')` -> return `'mcp_tool'`
       - If `/^[A-Z][a-zA-Z]+$/.test(toolName)` -> return `'builtin'` (PascalCase single words: Write, Edit, Bash, Read, Glob, Grep, WebFetch, WebSearch, NotebookEdit, Skill, TaskCreate, TaskUpdate, TaskList, TaskGet)
       - Otherwise -> return `'unknown'`

    2. `inferScope(toolName: string): ToolScope` --
       - If `toolName.startsWith('mcp__plugin_')` -> return `'plugin'`
       - If `toolName.startsWith('mcp__')` -> return `'project'` (conservative default; may be global but unknown from name alone)
       - Otherwise -> return `'global'` (built-in tools are always global)

    3. `extractServerName(toolName: string): string | null` --
       - Match against `/^mcp__plugin_([^_]+(?:_[^_]+)*)_([^_]+(?:_[^_]+)*)__/` for plugin MCP tools: extract the server name (second capture group). Example: `mcp__plugin_laminark_laminark__recall` -> server is `laminark` (the second `laminark` after the plugin name).
       - Match against `/^mcp__([^_]+(?:_[^_]+)*)__/` for project MCP tools: extract the server name. Example: `mcp__playwright__browser_screenshot` -> server is `playwright`.
       - Return null for non-MCP tools.

    Import ToolType and ToolScope from `'../shared/tool-types.js'`.

    **Create `src/hooks/config-scanner.ts`:**

    Main export: `scanConfigForTools(cwd: string, projectHash: string): DiscoveredTool[]`

    All filesystem operations MUST use synchronous versions (`readFileSync`, `readdirSync`, `existsSync`). The SessionStart hook is synchronous -- async operations are not supported.

    Internal helper functions (not exported):

    1. `scanMcpJson(filePath: string, scope: ToolScope, projectHash: string | null, tools: DiscoveredTool[]): void` --
       - Skip if file does not exist (`existsSync`).
       - Parse JSON. Extract `mcpServers` object (keys are server names).
       - For each server name, push a DiscoveredTool with: name = `mcp__${serverName}__*` (wildcard -- individual tool names not in config), toolType = `'mcp_server'`, scope, source = `config:${filePath}`, projectHash, description = null, serverName.
       - Wrap entire function body in try/catch. On error, call `debug('scanner', 'Failed to scan MCP config', { filePath })` and return without throwing.

    2. `scanClaudeJson(filePath: string, tools: DiscoveredTool[]): void` --
       - Skip if file does not exist.
       - Parse JSON. Check for top-level `mcpServers` (user-scope global servers). For each, push with scope='global', source='config:~/.claude.json', projectHash=null.
       - Check for `projects` object. For each project entry, check `mcpServers`. For each server found, push with scope='global', source='config:~/.claude.json', projectHash=null (user-configured servers via `claude mcp add` are treated as global).
       - Wrap in try/catch with debug logging.

    3. `scanCommands(dirPath: string, scope: ToolScope, projectHash: string | null, tools: DiscoveredTool[]): void` --
       - Skip if directory does not exist.
       - Read directory entries with `readdirSync(dirPath, { withFileTypes: true })`.
       - For each `.md` file: push with name = `/${basename(entry.name, '.md')}`, toolType = `'slash_command'`.
       - For each subdirectory (one level deep only): read its `.md` files. Push with name = `/${entry.name}:${basename(subEntry.name, '.md')}` (namespaced command format).
       - Extract description from YAML frontmatter of each .md file: read first 500 bytes, match `/^---\n([\s\S]*?)\n---/`, then `/description:\s*(.+)/`. Return null if no match.
       - Wrap in try/catch with debug logging.

    4. `scanSkills(dirPath: string, scope: ToolScope, projectHash: string | null, tools: DiscoveredTool[]): void` --
       - Skip if directory does not exist.
       - Read directory entries. For each subdirectory containing a `SKILL.md` file: push with name = entry.name (directory name is the skill name), toolType = `'skill'`.
       - Extract description from SKILL.md frontmatter.
       - Wrap in try/catch with debug logging.

    5. `scanInstalledPlugins(filePath: string, tools: DiscoveredTool[]): void` --
       - Skip if file does not exist.
       - Parse JSON. Look for `plugins` object (version 2 format: `{ version: 2, plugins: { "name@marketplace": [{ scope, installPath, version }] } }`).
       - For each plugin key, extract plugin name from `key.split('@')[0]`.
       - For each installation entry, push with toolType = `'plugin'`, scope = (install.scope === 'user' ? 'global' : 'project'), source = `'config:installed_plugins.json'`.
       - If the installation has an installPath, also call `scanMcpJson(join(installPath, '.mcp.json'), ...)` to discover the plugin's MCP servers.
       - Wrap in try/catch with debug logging.

    The main `scanConfigForTools` function calls all five scanners:
    ```
    scanMcpJson(join(cwd, '.mcp.json'), 'project', projectHash, tools);  // DISC-01
    scanClaudeJson(join(homedir(), '.claude.json'), tools);               // DISC-01
    scanCommands(join(cwd, '.claude', 'commands'), 'project', projectHash, tools);  // DISC-02
    scanCommands(join(homedir(), '.claude', 'commands'), 'global', null, tools);    // DISC-02
    scanSkills(join(cwd, '.claude', 'skills'), 'project', projectHash, tools);     // DISC-03
    scanSkills(join(homedir(), '.claude', 'skills'), 'global', null, tools);       // DISC-03
    scanInstalledPlugins(join(homedir(), '.claude', 'plugins', 'installed_plugins.json'), tools);  // DISC-04
    ```

    Imports needed: `readFileSync`, `readdirSync`, `existsSync` from `'node:fs'`; `join`, `basename` from `'node:path'`; `homedir` from `'node:os'`; `debug` from `'../shared/debug.js'`; `DiscoveredTool`, `ToolScope` from `'../shared/tool-types.js'`.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes (new files compile, imports resolve).
    2. `npm run build` succeeds.
    3. Read src/hooks/config-scanner.ts and confirm: scanConfigForTools is exported, calls all 5 scanners, all fs operations are synchronous (*Sync), every scanner is wrapped in try/catch.
    4. Read src/hooks/tool-name-parser.ts and confirm: three exported functions inferToolType, inferScope, extractServerName.
  </verify>
  <done>
    - src/hooks/config-scanner.ts exists with scanConfigForTools() calling 5 internal scanners for .mcp.json, ~/.claude.json, commands, skills, and installed_plugins.json.
    - src/hooks/tool-name-parser.ts exists with inferToolType(), inferScope(), extractServerName().
    - All filesystem operations are synchronous. All scanners wrapped in try/catch. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire discovery into handler.ts and session-lifecycle.ts</name>
  <files>src/hooks/handler.ts, src/hooks/session-lifecycle.ts</files>
  <action>
    **Modify `src/hooks/handler.ts`:**

    1. Add imports at the top:
       ```typescript
       import { ToolRegistryRepository } from '../storage/tool-registry.js';
       import { inferToolType, inferScope, extractServerName } from './tool-name-parser.js';
       ```

    2. Update `processPostToolUseFiltered` signature to accept an optional toolRegistry parameter:
       ```typescript
       export function processPostToolUseFiltered(
         input: Record<string, unknown>,
         obsRepo: ObservationRepository,
         researchBuffer?: ResearchBufferRepository,
         toolRegistry?: ToolRegistryRepository,
       ): void {
       ```

    3. Add organic discovery as the FIRST thing after the `if (!toolName)` early return, BEFORE the self-referential filter (line ~71). This is critical -- we want to record ALL tools including Laminark's own tools in the registry:
       ```typescript
       // DISC-05: Organic tool discovery -- record every tool we see
       if (toolRegistry) {
         try {
           toolRegistry.recordOrCreate(toolName, {
             toolType: inferToolType(toolName),
             scope: inferScope(toolName),
             source: 'hook:PostToolUse',
             projectHash: (input.cwd as string) ? getProjectHash(input.cwd as string) : null,
             description: null,
             serverName: extractServerName(toolName),
           });
         } catch {
           // Non-fatal: registry is supplementary to core memory function
         }
       }
       ```
       Wait -- handler.ts already computes projectHash in main() but does not pass it to processPostToolUseFiltered. Instead of calling getProjectHash again (expensive realpathSync), pass the projectHash from main() into processPostToolUseFiltered. So actually:

       Update the signature to also accept projectHash:
       ```typescript
       export function processPostToolUseFiltered(
         input: Record<string, unknown>,
         obsRepo: ObservationRepository,
         researchBuffer?: ResearchBufferRepository,
         toolRegistry?: ToolRegistryRepository,
         projectHash?: string,
       ): void {
       ```

       Then use that projectHash in the organic discovery block.

    4. In the `main()` function, after the existing `researchBuffer` initialization, add ToolRegistryRepository instantiation:
       ```typescript
       let toolRegistry: ToolRegistryRepository | undefined;
       try {
         toolRegistry = new ToolRegistryRepository(laminarkDb.db);
       } catch {
         // tool_registry table may not exist yet before migration 16
       }
       ```

    5. Update the PostToolUse/PostToolUseFailure case in the switch statement to pass toolRegistry and projectHash:
       ```typescript
       case 'PostToolUse':
       case 'PostToolUseFailure':
         processPostToolUseFiltered(input, obsRepo, researchBuffer, toolRegistry, projectHash);
         break;
       ```

    6. Update the SessionStart case to pass toolRegistry:
       ```typescript
       case 'SessionStart': {
         const context = handleSessionStart(input, sessionRepo, laminarkDb.db, projectHash, toolRegistry);
         if (context) {
           process.stdout.write(context);
         }
         break;
       }
       ```

    **Modify `src/hooks/session-lifecycle.ts`:**

    1. Add imports:
       ```typescript
       import { ToolRegistryRepository } from '../storage/tool-registry.js';
       import { scanConfigForTools } from './config-scanner.js';
       ```

    2. Update `handleSessionStart` signature to accept optional toolRegistry:
       ```typescript
       export function handleSessionStart(
         input: Record<string, unknown>,
         sessionRepo: SessionRepository,
         db: BetterSqlite3.Database,
         projectHash: string,
         toolRegistry?: ToolRegistryRepository,
       ): string | null {
       ```

    3. After `sessionRepo.create(sessionId)` and BEFORE the context assembly, add config scanning:
       ```typescript
       // DISC-01 through DISC-04: Scan config files for available tools
       if (toolRegistry) {
         const cwd = input.cwd as string;
         try {
           const scanStart = Date.now();
           const tools = scanConfigForTools(cwd, projectHash);
           for (const tool of tools) {
             toolRegistry.upsert(tool);
           }
           const scanElapsed = Date.now() - scanStart;
           debug('session', 'Config scan completed', { toolsFound: tools.length, elapsed: scanElapsed });
           if (scanElapsed > 200) {
             debug('session', 'Config scan slow (>200ms budget)', { elapsed: scanElapsed });
           }
         } catch {
           // Tool registry is supplementary -- never block session start
           debug('session', 'Config scan failed (non-fatal)');
         }
       }
       ```

    IMPORTANT CONSTRAINTS:
    - Do NOT change the return type of handleSessionStart (still returns `string | null`).
    - Do NOT add any stdout writes from config scanning (only SessionStart context assembly writes to stdout).
    - The toolRegistry parameter is optional -- if migration 16 hasn't run yet, it will be undefined and scanning is skipped gracefully.
    - Keep all existing behavior intact. This is purely additive.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes (all imports resolve, signatures match).
    2. `npm run build` succeeds.
    3. Read handler.ts and confirm: ToolRegistryRepository import present, processPostToolUseFiltered has toolRegistry and projectHash params, organic discovery block is BEFORE the self-referential filter, main() instantiates toolRegistry with try/catch, all switch cases pass toolRegistry.
    4. Read session-lifecycle.ts and confirm: scanConfigForTools import present, handleSessionStart has toolRegistry param, config scanning block runs after session create and before context assembly, wrapped in try/catch with timing.
    5. Verify no stdout writes in the config scanning path (only existing context assembly writes to stdout).
  </verify>
  <done>
    - handler.ts instantiates ToolRegistryRepository and passes it to processPostToolUseFiltered and handleSessionStart.
    - Organic discovery in processPostToolUseFiltered records every tool call BEFORE the self-referential filter.
    - Config scanning in handleSessionStart scans all config surfaces and upserts results into registry.
    - All discovery paths are wrapped in try/catch -- failures never block the hook pipeline.
    - Build passes. Existing behavior unchanged.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors.
2. `npm run build` succeeds.
3. handler.ts: organic discovery runs BEFORE self-referential filter -- Laminark's own tools are registered.
4. session-lifecycle.ts: config scanning runs after session create, before context assembly, within 200ms budget.
5. All 5 config surfaces scanned: .mcp.json, ~/.claude.json, commands dirs, skills dirs, installed_plugins.json.
6. Malformed config files do not crash the hook handler (try/catch everywhere).
7. Config scanning uses only synchronous fs operations (readFileSync, readdirSync, existsSync).
8. Tool name parser correctly handles: mcp__server__tool, mcp__plugin_name_server__tool, PascalCase builtins.
</verification>

<success_criteria>
- Config scanning discovers MCP servers, slash commands, skills, and plugins from all config surfaces (DISC-01 through DISC-04).
- Organic discovery records every tool invocation in the registry (DISC-05).
- All discovery writes to tool_registry table with correct scope, type, and source metadata (DISC-06).
- No regression in existing hook behavior -- observation capture, session lifecycle, research buffer all work unchanged.
- Build compiles without errors.
</success_criteria>

<output>
After completion, create `.planning/phases/10-tool-discovery-registry/10-02-SUMMARY.md`
</output>
