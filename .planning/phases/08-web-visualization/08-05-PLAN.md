---
phase: 08-web-visualization
plan: 05
type: execute
wave: 3
depends_on: ["08-02", "08-04"]
files_modified:
  - src/web/routes/sse.ts
  - src/web/server.ts
  - ui/graph.js
  - ui/app.js
autonomous: true

must_haves:
  truths:
    - "When a new observation is processed, the web UI updates automatically without manual refresh"
    - "Graph visualization performs smoothly with 500+ nodes using viewport culling"
    - "SSE reconnects automatically if the connection drops"
  artifacts:
    - path: "src/web/routes/sse.ts"
      provides: "SSE broadcast integration with analysis pipeline write events"
      contains: "broadcast"
    - path: "ui/graph.js"
      provides: "Viewport culling logic hiding off-screen nodes for performance"
      contains: "extent|viewport|hidden"
  key_links:
    - from: "src/web/server.ts"
      to: "src/web/routes/sse.ts"
      via: "broadcast called after database writes from analysis pipeline"
      pattern: "broadcast.*new_observation|broadcast.*entity_updated"
    - from: "ui/graph.js"
      to: "cytoscape"
      via: "viewport event listener for culling off-screen elements"
      pattern: "on.*viewport|on.*pan|on.*zoom"
    - from: "ui/app.js"
      to: "/api/sse"
      via: "EventSource with reconnect driving graph and timeline updates"
      pattern: "EventSource|addEventListener.*message"
---

<objective>
Wire SSE broadcasts from the server to drive live UI updates in both graph and timeline views, and implement viewport culling for the graph to handle 500+ nodes smoothly.

Purpose: VIS-05 (live updates) and VIS-06 (performance at scale). Without live SSE integration, users must manually refresh to see new data. Without viewport culling, the graph becomes sluggish with hundreds of nodes, defeating the purpose of visualization.
Output: Live-updating graph and timeline that automatically reflect new observations, plus viewport culling that keeps the graph responsive at 500+ nodes.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/STACK.md
@.planning/phases/08-web-visualization/08-01-SUMMARY.md
@.planning/phases/08-web-visualization/08-02-SUMMARY.md
@.planning/phases/08-web-visualization/08-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate SSE broadcasts with analysis pipeline and wire live updates end-to-end</name>
  <files>src/web/routes/sse.ts, src/web/server.ts, ui/app.js</files>
  <action>
**Server-side SSE integration (src/web/routes/sse.ts):**

The `broadcast` function was created in Plan 01. Now integrate it with the data pipeline:

In src/web/server.ts, after the main thread receives analysis results from the worker (the `analysisWorker.on('message', ...)` handler that writes to SQLite), call the SSE broadcast:
- After writing a new observation: `broadcast('new_observation', { id, text: truncated, sessionId, createdAt, entityIds })`
- After creating/updating an entity: `broadcast('entity_updated', { id, label, type, observationCount })`
- After detecting a topic shift: `broadcast('topic_shift', { id, fromTopic, toTopic, timestamp, confidence })`
- After session start: `broadcast('session_start', { id, startedAt })`
- After session end: `broadcast('session_end', { id, endedAt, duration, observationCount, summary })`

Ensure broadcast payloads are minimal -- send only what the client needs to update its view, not full observation text. The client will fetch full details from the REST API if needed (e.g., when user clicks a node).

Add a `lastEventId` counter to SSE messages for replay support:
- Each broadcast increments a counter and includes it as `id:` field in the SSE message
- If a client reconnects with `Last-Event-ID` header (automatic from EventSource), replay events since that ID from an in-memory ring buffer (last 100 events)
- This handles brief disconnections without data loss

**Client-side event handling (ui/app.js):**

Enhance the SSE event handling in app.js to dispatch granular custom DOM events:
- `new_observation` event: dispatch `laminark:new_observation` with the payload data. Both graph.js and timeline.js listen for this.
- `entity_updated` event: dispatch `laminark:entity_updated`. Graph.js updates/adds the node.
- `topic_shift` event: dispatch `laminark:topic_shift`. Timeline.js inserts a shift marker.
- `session_start` event: dispatch `laminark:session_start`. Timeline.js creates a new session card.
- `session_end` event: dispatch `laminark:session_end`. Timeline.js updates the session card.

Add a visual indicator for live update status:
- Small dot in the nav bar: green when SSE connected, red when disconnected, yellow when reconnecting
- Update this indicator based on EventSource.readyState (0=connecting/yellow, 1=open/green, 2=closed/red)
- Add tooltip showing time since last event received

**Reconnection robustness (ui/app.js):**
- EventSource auto-reconnects natively, but add a manual fallback:
- If no heartbeat received for 60 seconds, close and reopen the EventSource
- On reconnection, fetch fresh data from REST API to catch up on any missed events (belt and suspenders)
- Log reconnection events to console for debugging
  </action>
  <verify>
1. Open the web UI and verify the green SSE status dot appears in the nav bar
2. Trigger a new observation (via MCP tool or direct database write) -- verify the graph adds a node and timeline adds an entry without page refresh
3. Disconnect the server briefly and restart -- verify SSE reconnects (dot goes yellow then green) and UI catches up
4. Check browser console for SSE event logs
  </verify>
  <done>SSE broadcasts fire on every analysis pipeline write. Client receives events and updates both graph and timeline views live. Connection status indicator shows SSE health. Auto-reconnect with data catch-up handles interruptions.</done>
</task>

<task type="auto">
  <name>Task 2: Viewport culling and level-of-detail for 500+ node performance</name>
  <files>ui/graph.js, ui/app.js</files>
  <action>
**Viewport culling in ui/graph.js:**

The problem: Cytoscape renders ALL nodes even if they are off-screen. With 500+ nodes, this degrades canvas performance. The solution: hide elements that are outside the visible viewport and show them when they scroll into view.

Implementation:
- After initial graph render, listen for viewport change events: `cy.on('viewport', debounce(cullOffscreen, 100))`
- Also trigger on `pan` and `zoom` events (viewport may not fire for all interactions)
- `cullOffscreen()` function:
  1. Get the current viewport extent: `const ext = cy.extent()` (returns { x1, y1, x2, y2, w, h })
  2. Add a buffer zone (20% of viewport dimensions on each side) to avoid popping:
     ```javascript
     const buffer = { x: ext.w * 0.2, y: ext.h * 0.2 };
     const viewRect = { x1: ext.x1 - buffer.x, y1: ext.y1 - buffer.y, x2: ext.x2 + buffer.x, y2: ext.y2 + buffer.y };
     ```
  3. For each node, check if its position falls within viewRect. Use `node.position()` which returns {x, y}.
  4. Nodes outside viewRect: add CSS class `culled` (which sets `display: none` or `visibility: hidden` via Cytoscape style)
  5. Nodes inside viewRect: remove `culled` class
  6. For edges: cull if BOTH source and target are culled
- Use a Cytoscape style rule: `{ selector: '.culled', style: { 'display': 'none' } }` -- this is the fastest way to hide elements in Cytoscape without removing them from the graph

- Important: Do NOT cull during layout animation (disable culling while `cy.animated()` is true, re-enable after)
- Important: When entity type or time range filters are active, culled nodes must also respect those filters (a node hidden by filter should stay hidden regardless of viewport position)

**Level-of-detail (LOD):**
- When zoom level is below 0.5 (very zoomed out): hide edge labels and node labels to reduce rendering overhead. Apply via dynamic style: `cy.style().selector('edge').style('label', '').update()` when zoom < 0.5, restore labels when zoom >= 0.5.
- When zoom level is below 0.3: hide edges entirely, show only nodes as simple circles (remove shape differentiation). This lets users see the overall cluster structure without edge spaghetti.
- Listen to `zoom` event to toggle LOD levels with debouncing

**Performance stats:**
- Add a small performance overlay (toggleable) showing: visible nodes / total nodes, FPS estimate (using requestAnimationFrame timing), and culling status
- Toggle with keyboard shortcut `Ctrl+Shift+P` (P for performance)
- Display in top-right corner, small monospace text, semi-transparent background

**Batch update optimization:**
- When multiple SSE events arrive in quick succession (e.g., batch of observations being processed), batch the graph updates:
- Collect incoming events for 200ms, then apply all at once with a single layout run
- Use a simple debounced flush: queue events, flush after 200ms of no new events
- This prevents layout thrashing when 10+ observations arrive within seconds

**Debounce utility:**
- Add a simple `debounce(fn, ms)` utility function at the top of graph.js (3 lines, no library needed)
  </action>
  <verify>
1. Load a graph with 500+ nodes (may need to generate test data). Verify smooth panning and zooming.
2. Pan to edge of graph -- nodes that go off-screen should be culled (check with Ctrl+Shift+P performance overlay: visible nodes < total nodes)
3. Zoom out past 0.5 -- labels should disappear for cleaner view
4. Zoom out past 0.3 -- edges should hide, only node dots visible
5. Zoom back in -- labels and edges reappear
6. Performance overlay shows reasonable FPS (>30) with 500+ nodes
7. Rapidly add multiple observations via SSE -- graph batches updates without layout thrashing
  </verify>
  <done>Viewport culling hides off-screen nodes, keeping render set small regardless of total graph size. LOD reduces visual detail at low zoom levels. Batch updates prevent layout thrashing from rapid SSE events. Performance overlay provides diagnostic information. Graph handles 500+ nodes smoothly.</done>
</task>

</tasks>

<verification>
- New observations appear in both graph and timeline without page refresh (VIS-05)
- SSE connection status indicator shows green when connected
- SSE reconnects automatically and catches up on missed events
- With 500+ nodes, graph pans and zooms smoothly (>30 FPS)
- Viewport culling confirmed: off-screen nodes are not rendered (visible in perf overlay)
- LOD kicks in at low zoom levels: labels hide at 0.5x, edges hide at 0.3x
- Rapid SSE events are batched before graph layout runs
- All interactions from Plans 02 and 03 still work correctly with culling active
</verification>

<success_criteria>
VIS-05 and VIS-06 are delivered: the UI updates live as new observations are processed via SSE, and the graph handles 500+ nodes with viewport culling and level-of-detail for smooth performance. No manual refresh is needed.
</success_criteria>

<output>
After completion, create `.planning/phases/08-web-visualization/08-05-SUMMARY.md`
</output>
