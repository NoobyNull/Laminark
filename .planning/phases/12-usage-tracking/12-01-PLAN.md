---
phase: 12-usage-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/migrations.ts
  - src/shared/tool-types.ts
  - src/storage/tool-registry.ts
  - src/hooks/handler.ts
autonomous: true

must_haves:
  truths:
    - "Every PostToolUse hook event inserts a row in tool_usage_events with tool_name, session_id, project_hash, and timestamp"
    - "The existing usage_count/last_used_at aggregate on tool_registry continues to be updated (no regression)"
    - "Usage events from different sessions and projects are distinguishable via session_id and project_hash columns"
    - "Temporal queries can answer 'how many times was tool X used in the last 7 days' using the events table"
    - "PostToolUseFailure events are recorded with success=0 to enable future Phase 16 failure-driven demotion"
  artifacts:
    - path: "src/storage/migrations.ts"
      provides: "Migration 17 creating tool_usage_events table"
      contains: "tool_usage_events"
    - path: "src/shared/tool-types.ts"
      provides: "ToolUsageEvent interface"
      contains: "ToolUsageEvent"
    - path: "src/storage/tool-registry.ts"
      provides: "Event recording in recordOrCreate + temporal query methods"
      exports: ["ToolRegistryRepository"]
    - path: "src/hooks/handler.ts"
      provides: "session_id threaded from input to recordOrCreate"
      contains: "session_id"
  key_links:
    - from: "src/hooks/handler.ts"
      to: "src/storage/tool-registry.ts"
      via: "recordOrCreate call with sessionId parameter"
      pattern: "recordOrCreate\\(toolName.*session"
    - from: "src/storage/tool-registry.ts"
      to: "tool_usage_events table"
      via: "stmtInsertEvent prepared statement"
      pattern: "stmtInsertEvent"
    - from: "src/hooks/handler.ts"
      to: "src/storage/tool-registry.ts"
      via: "hook_event_name threaded for success/failure distinction"
      pattern: "hookEventName|hook_event_name"
---

<objective>
Add per-event usage tracking to the tool registry so every PostToolUse hook event is recorded with session and project context, enabling temporal usage analysis for downstream routing intelligence.

Purpose: Phase 10 built aggregate usage counters (usage_count, last_used_at) on tool_registry rows. Phase 12 adds the granular event layer that answers "when", "how often in what period", and "in which session" -- the data foundation that Phase 13 (context enhancement) and Phase 14 (conversation routing) need for relevance ranking.

Output: Migration 17 (tool_usage_events table), ToolUsageEvent type, extended recordOrCreate with event recording, handler wiring with session_id, and temporal query methods.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-usage-tracking/12-RESEARCH.md

@src/storage/migrations.ts
@src/storage/tool-registry.ts
@src/shared/tool-types.ts
@src/hooks/handler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tool_usage_events schema and event recording</name>
  <files>
    src/storage/migrations.ts
    src/shared/tool-types.ts
    src/storage/tool-registry.ts
  </files>
  <action>
**Migration 17** in `src/storage/migrations.ts`:

Add a new migration entry after migration 16 in the MIGRATIONS array:

```typescript
{
  version: 17,
  name: 'create_tool_usage_events',
  up: `
    CREATE TABLE tool_usage_events (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      tool_name TEXT NOT NULL,
      session_id TEXT,
      project_hash TEXT,
      success INTEGER NOT NULL DEFAULT 1,
      created_at TEXT NOT NULL DEFAULT (datetime('now'))
    );

    CREATE INDEX idx_tool_usage_events_tool
      ON tool_usage_events(tool_name, created_at DESC);
    CREATE INDEX idx_tool_usage_events_session
      ON tool_usage_events(session_id) WHERE session_id IS NOT NULL;
    CREATE INDEX idx_tool_usage_events_project_time
      ON tool_usage_events(project_hash, created_at DESC);
  `,
},
```

Update the file's top comment to include migration 17 in the list.

The `success` column (INTEGER 0/1) defaults to 1 (TRUE). PostToolUseFailure events will set it to 0. This enables Phase 16's failure-driven demotion without requiring another migration later.

**ToolUsageEvent type** in `src/shared/tool-types.ts`:

Add the following interface after `ToolRegistryRow`:

```typescript
/**
 * Raw database row from the tool_usage_events table.
 */
export interface ToolUsageEvent {
  id: number;
  tool_name: string;
  session_id: string | null;
  project_hash: string | null;
  success: number;  // 0 = failure, 1 = success
  created_at: string;
}

/**
 * Aggregated usage stats for temporal queries.
 */
export interface ToolUsageStats {
  tool_name: string;
  usage_count: number;
  last_used: string;
}
```

**Event recording in ToolRegistryRepository** (`src/storage/tool-registry.ts`):

1. Add import for the new types: `import type { DiscoveredTool, ToolRegistryRow, ToolUsageEvent, ToolUsageStats } from '../shared/tool-types.js';`

2. Add a new prepared statement field: `private readonly stmtInsertEvent: BetterSqlite3.Statement;`

3. In the constructor, after `stmtGetAvailableForSession` is prepared, add:
```typescript
this.stmtInsertEvent = db.prepare(`
  INSERT INTO tool_usage_events (tool_name, session_id, project_hash, success)
  VALUES (?, ?, ?, ?)
`);
```

4. Modify the `recordOrCreate` method signature to accept `sessionId` and `success`:
```typescript
recordOrCreate(
  name: string,
  defaults: Omit<DiscoveredTool, 'name'>,
  sessionId?: string | null,
  success?: boolean,
): void
```

5. Inside the `recordOrCreate` try block, AFTER the existing `stmtRecordUsage.run()` / upsert logic, add:
```typescript
// Insert usage event with session context (UTRK-02)
if (sessionId !== undefined) {
  this.stmtInsertEvent.run(name, sessionId, defaults.projectHash, success === false ? 0 : 1);
}
```

CRITICAL: The event insert goes INSIDE the existing try/catch. Do NOT add a separate recordUsage call -- that would double-count usage_count. The event insert supplements the existing aggregate update, it does not replace it. Per research pitfall 2: "Do NOT add a separate call path."

CRITICAL: The stmtInsertEvent.run must NOT throw and crash the handler. It is inside the existing try/catch in recordOrCreate, which already logs and swallows errors. This is the correct pattern.

Note: Do NOT wrap in a transaction. The aggregate update + event insert are independent rows in different tables. If the event insert fails but the aggregate succeeds, that is acceptable (events are supplementary analytics data). Avoiding the transaction keeps the code simpler and is consistent with the existing non-transactional pattern in recordOrCreate.
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- must compile with zero errors
2. Run `npx tsdown` -- must build successfully
3. Verify migration 17 is the last entry in the MIGRATIONS array
4. Verify `stmtInsertEvent` is prepared in the constructor
5. Verify `recordOrCreate` signature includes optional `sessionId` and `success` parameters
6. Verify the ToolUsageEvent and ToolUsageStats interfaces exist in tool-types.ts
  </verify>
  <done>
- Migration 17 creates tool_usage_events with tool_name, session_id, project_hash, success, created_at columns and three indexes
- ToolUsageEvent and ToolUsageStats interfaces are exported from tool-types.ts
- recordOrCreate accepts optional sessionId and success parameters and inserts an event row when sessionId is provided
- The existing usage_count/last_used_at aggregate update is unchanged (no regression)
- All new code is inside existing try/catch (non-fatal error handling preserved)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire handler session_id threading and add temporal query methods</name>
  <files>
    src/hooks/handler.ts
    src/storage/tool-registry.ts
  </files>
  <action>
**Handler wiring** in `src/hooks/handler.ts`:

Modify the `processPostToolUseFiltered` function to pass `session_id` and success/failure status through to `recordOrCreate`.

In the organic discovery block (around line 77-89), change from:

```typescript
toolRegistry.recordOrCreate(toolName, {
  toolType: inferToolType(toolName),
  scope: inferScope(toolName),
  source: 'hook:PostToolUse',
  projectHash: projectHash ?? null,
  description: null,
  serverName: extractServerName(toolName),
});
```

To:

```typescript
const sessionId = input.session_id as string | undefined;
const isFailure = hookEventName === 'PostToolUseFailure';
toolRegistry.recordOrCreate(toolName, {
  toolType: inferToolType(toolName),
  scope: 'hook:PostToolUse',
  projectHash: projectHash ?? null,
  description: null,
  serverName: extractServerName(toolName),
}, sessionId ?? null, !isFailure);
```

Wait -- `scope` must remain `inferScope(toolName)`, not `'hook:PostToolUse'`. The `source` field is `'hook:PostToolUse'`. The original code sets these correctly, so keep `scope: inferScope(toolName)` and `source: 'hook:PostToolUse'` as they are. Only ADD the two new parameters (`sessionId ?? null` and `!isFailure`).

So the corrected change is to add two arguments to the existing recordOrCreate call:

```typescript
const sessionId = input.session_id as string | undefined;
const isFailure = hookEventName === 'PostToolUseFailure';
toolRegistry.recordOrCreate(toolName, {
  toolType: inferToolType(toolName),
  scope: inferScope(toolName),
  source: 'hook:PostToolUse',
  projectHash: projectHash ?? null,
  description: null,
  serverName: extractServerName(toolName),
}, sessionId ?? null, !isFailure);
```

Note: `hookEventName` is already defined at the top of `processPostToolUseFiltered` (line 68). Use it directly.

**Temporal query methods** in `src/storage/tool-registry.ts`:

Add three new prepared statements in the constructor:

```typescript
this.stmtGetUsageForTool = db.prepare(`
  SELECT tool_name, COUNT(*) as usage_count, MAX(created_at) as last_used
  FROM tool_usage_events
  WHERE tool_name = ? AND project_hash = ?
    AND created_at >= datetime('now', ?)
  GROUP BY tool_name
`);

this.stmtGetUsageForSession = db.prepare(`
  SELECT tool_name, COUNT(*) as usage_count, MAX(created_at) as last_used
  FROM tool_usage_events
  WHERE session_id = ?
  GROUP BY tool_name
  ORDER BY usage_count DESC
`);

this.stmtGetUsageSince = db.prepare(`
  SELECT tool_name, COUNT(*) as usage_count, MAX(created_at) as last_used
  FROM tool_usage_events
  WHERE project_hash = ?
    AND created_at >= datetime('now', ?)
  GROUP BY tool_name
  ORDER BY usage_count DESC
`);
```

Add corresponding class fields:
```typescript
private readonly stmtGetUsageForTool: BetterSqlite3.Statement;
private readonly stmtGetUsageForSession: BetterSqlite3.Statement;
private readonly stmtGetUsageSince: BetterSqlite3.Statement;
```

Add three public methods:

```typescript
/**
 * Returns usage stats for a specific tool within a time window.
 * @param timeModifier - SQLite datetime modifier, e.g., '-7 days', '-30 days'
 */
getUsageForTool(toolName: string, projectHash: string, timeModifier: string = '-7 days'): ToolUsageStats | null {
  const row = this.stmtGetUsageForTool.get(toolName, projectHash, timeModifier) as ToolUsageStats | undefined;
  return row ?? null;
}

/**
 * Returns per-tool usage stats for a specific session.
 */
getUsageForSession(sessionId: string): ToolUsageStats[] {
  return this.stmtGetUsageForSession.all(sessionId) as ToolUsageStats[];
}

/**
 * Returns per-tool usage stats since a time offset for a project.
 * @param timeModifier - SQLite datetime modifier, e.g., '-7 days', '-30 days'
 */
getUsageSince(projectHash: string, timeModifier: string = '-7 days'): ToolUsageStats[] {
  return this.stmtGetUsageSince.all(projectHash, timeModifier) as ToolUsageStats[];
}
```

These three methods provide the temporal query capabilities required by UTRK-03:
- `getUsageForTool`: "Was Read used 50 times this week?" (per-tool temporal query)
- `getUsageForSession`: "What tools were used in session X?" (per-session analysis)
- `getUsageSince`: "What are the most-used tools in the last 7 days?" (project-wide temporal ranking)
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- must compile with zero errors
2. Run `npx tsdown` -- must build successfully
3. Verify `processPostToolUseFiltered` passes `sessionId` and success boolean to `recordOrCreate`
4. Verify the three query methods exist on ToolRegistryRepository: `getUsageForTool`, `getUsageForSession`, `getUsageSince`
5. Verify no double-counting: only ONE call to `recordOrCreate` per PostToolUse event, which handles both aggregate and event recording internally
6. Grep for `recordOrCreate` in handler.ts to confirm only one call site exists with all 4 parameters
  </verify>
  <done>
- handler.ts threads session_id and success/failure status to recordOrCreate for every PostToolUse and PostToolUseFailure event
- Three temporal query methods are available: getUsageForTool (per-tool windowed), getUsageForSession (per-session), getUsageSince (project-wide windowed)
- No double-counting: the single recordOrCreate call handles both aggregate update and event insertion
- PostToolUseFailure events are recorded with success=0 (enables Phase 16 failure-driven demotion)
  </done>
</task>

</tasks>

<verification>
After both tasks are complete, verify the full data flow end-to-end:

1. **Build check**: `npx tsc --noEmit && npx tsdown` -- zero errors
2. **Migration existence**: Grep `tool_usage_events` in migrations.ts -- migration 17 creates the table
3. **Type existence**: Grep `ToolUsageEvent` in tool-types.ts -- interface exported
4. **Recording path**: Grep `stmtInsertEvent` in tool-registry.ts -- prepared in constructor, used in recordOrCreate
5. **Handler threading**: Grep `session_id` usage near `recordOrCreate` in handler.ts -- session_id extracted from input and passed through
6. **Query methods**: Grep `getUsageForTool|getUsageForSession|getUsageSince` in tool-registry.ts -- all three methods exist
7. **No regression**: Grep `stmtRecordUsage` in tool-registry.ts -- still called (aggregate update preserved)
8. **Success/failure**: Grep `success` in tool-registry.ts -- inserted in stmtInsertEvent with 0/1 value
9. **Non-fatal**: Verify all new code is inside try/catch blocks -- no unhandled throws
</verification>

<success_criteria>
1. Every PostToolUse/PostToolUseFailure hook event inserts a row in tool_usage_events with tool_name, session_id, project_hash, success flag, and created_at timestamp
2. The existing usage_count and last_used_at aggregate columns on tool_registry continue to be updated (backward compatibility with Phase 11 scope resolution sorting)
3. Three temporal query methods are available for downstream phases: per-tool windowed stats, per-session stats, and project-wide windowed ranking
4. PostToolUseFailure events are distinguishable from successful uses via the success column (enables Phase 16)
5. TypeScript compilation and build both pass with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-usage-tracking/12-01-SUMMARY.md`
</output>
