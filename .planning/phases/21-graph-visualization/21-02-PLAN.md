---
phase: 21-graph-visualization
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - ui/graph.js
  - ui/styles.css
  - ui/index.html
autonomous: true

must_haves:
  truths:
    - "Debug paths render as animated dashed lines connecting waypoint nodes on the D3 graph"
    - "Waypoints are color-coded by type (error: red, attempt: yellow, resolution: green)"
    - "A toggle button in the toolbar shows/hides the path overlay without affecting the knowledge graph"
    - "Path overlay loads on graph init and updates via SSE events"
  artifacts:
    - path: "ui/graph.js"
      provides: "Path overlay SVG layer, animated lines, waypoint markers, toggle"
      contains: "pathOverlayGroup"
    - path: "ui/styles.css"
      provides: "Path overlay styles with animated dashed lines"
      contains: "path-overlay"
    - path: "ui/index.html"
      provides: "Path overlay toggle button in toolbar"
      contains: "paths-toggle-btn"
  key_links:
    - from: "ui/graph.js"
      to: "/api/paths"
      via: "fetch in loadPathOverlay"
      pattern: "fetch.*api/paths"
    - from: "ui/graph.js"
      to: "ui/styles.css"
      via: "CSS classes for animation"
      pattern: "path-line|waypoint-marker"
---

<objective>
Render debug paths as animated breadcrumb trails overlaid on the D3 knowledge graph, with a toolbar toggle to show/hide them.

Purpose: This is the core visualization requirement (UI-05 + UI-07). Users see debug paths as colored, animated dashed lines connecting waypoint nodes on the existing graph, with a simple toggle to control visibility.

Output: Path overlay layer in graph.js, animated CSS styles, toggle button in toolbar.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-graph-visualization/21-01-SUMMARY.md
@ui/graph.js
@ui/styles.css
@ui/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add path overlay SVG layer and rendering logic to graph.js</name>
  <files>ui/graph.js</files>
  <action>
Add a path overlay system to graph.js. This is a new SVG layer inserted between the edges group and nodes group in the layer paint order.

**Module state additions** (add near the top with other module state variables around line 130):
```
// Path overlay state
var pathOverlayGroup = null;
var pathOverlayVisible = localStorage.getItem('laminark-path-overlay') !== 'false';
var pathData = []; // Array of { id, status, triggerSummary, waypoints: [{id, type, summary, nodeId?}] }
```

**Waypoint type color map** (add near ENTITY_STYLES):
```
var WAYPOINT_TYPE_COLORS = {
  error: '#f85149',
  attempt: '#d29922',
  failure: '#f0883e',
  success: '#3fb950',
  pivot: '#a371f7',
  revert: '#79c0ff',
  discovery: '#58a6ff',
  resolution: '#3fb950',
};
```

**In initGraph()**, after creating edgeLabelsGroup (line 237) and BEFORE creating nodesGroup (line 238), insert:
```
pathOverlayGroup = svgG.append('g').attr('class', 'path-overlay-group');
```
This ensures paths render above edges but below nodes.

Also in initGraph(), call `initPathOverlayToggle();` after `initEdgeLabelToggle();`.

**Add loadPathOverlay() function:**
```
async function loadPathOverlay() {
  if (!svg || !pathOverlayVisible) return;

  try {
    var params = new URLSearchParams();
    if (window.laminarkState && window.laminarkState.currentProject) {
      params.set('project', window.laminarkState.currentProject);
    }
    params.set('limit', '10');
    var url = '/api/paths' + (params.toString() ? '?' + params.toString() : '');
    var res = await fetch(url);
    if (!res.ok) throw new Error('HTTP ' + res.status);
    var data = await res.json();
    pathData = (data.paths || []).filter(function(p) { return p.status === 'active' || p.status === 'resolved'; });

    // For each path, fetch waypoints
    for (var i = 0; i < pathData.length; i++) {
      try {
        var detailRes = await fetch('/api/paths/' + encodeURIComponent(pathData[i].id));
        if (detailRes.ok) {
          var detail = await detailRes.json();
          pathData[i].waypoints = detail.waypoints || [];
        }
      } catch (e) { pathData[i].waypoints = []; }
    }

    renderPathOverlay();
  } catch (err) {
    console.error('[laminark:graph] Failed to load path overlay:', err);
  }
}
```

**Add renderPathOverlay() function:**
This renders path lines and waypoint markers. For each path:
1. Draw a curved path line using d3.line with curveCatmullRom through the waypoint positions
2. Draw waypoint circle markers at each position, colored by waypoint type

The waypoints don't have their own graph coordinates, so position them along a horizontal timeline bar at the bottom of the viewport, OR map them to graph nodes if observation_id matches. For simplicity, render paths as a horizontal timeline strip at the bottom of the graph area:

```
function renderPathOverlay() {
  if (!pathOverlayGroup || !pathOverlayVisible) {
    if (pathOverlayGroup) pathOverlayGroup.style('display', 'none');
    return;
  }
  pathOverlayGroup.style('display', null);
  pathOverlayGroup.selectAll('*').remove();

  if (pathData.length === 0) return;

  var width = containerEl ? containerEl.clientWidth : 800;
  var height = containerEl ? containerEl.clientHeight : 600;

  // Get current transform to position in screen space
  var transform = d3.zoomTransform(svg.node());

  pathData.forEach(function(path, pathIndex) {
    if (!path.waypoints || path.waypoints.length === 0) return;

    var pathGroup = pathOverlayGroup.append('g')
      .attr('class', 'path-trail')
      .attr('data-path-id', path.id);

    // Position waypoints evenly spaced along a line
    var waypoints = path.waypoints;
    var margin = 80;
    var yBase = (height - 60) / transform.k - transform.y / transform.k;
    var xStart = (-transform.x / transform.k) + margin / transform.k;
    var xEnd = (-transform.x / transform.k) + (width - margin) / transform.k;
    var spacing = waypoints.length > 1 ? (xEnd - xStart) / (waypoints.length - 1) : 0;

    var points = waypoints.map(function(wp, i) {
      return { x: xStart + i * spacing, y: yBase + pathIndex * 40 / transform.k };
    });

    // Draw connecting line (animated dashed)
    if (points.length > 1) {
      var lineGen = d3.line()
        .x(function(d) { return d.x; })
        .y(function(d) { return d.y; })
        .curve(d3.curveCatmullRom.alpha(0.5));

      pathGroup.append('path')
        .attr('class', 'path-line' + (path.status === 'active' ? ' path-line-active' : ''))
        .attr('d', lineGen(points))
        .attr('fill', 'none')
        .attr('stroke', path.status === 'resolved' ? '#3fb950' : '#d29922')
        .attr('stroke-width', 2.5 / transform.k)
        .attr('stroke-dasharray', (6 / transform.k) + ' ' + (4 / transform.k))
        .attr('opacity', 0.8);
    }

    // Draw waypoint markers
    points.forEach(function(pt, i) {
      var wp = waypoints[i];
      var color = WAYPOINT_TYPE_COLORS[wp.waypoint_type] || '#8b949e';
      var radius = 6 / transform.k;

      var marker = pathGroup.append('g')
        .attr('class', 'waypoint-marker')
        .attr('transform', 'translate(' + pt.x + ',' + pt.y + ')')
        .style('cursor', 'pointer');

      marker.append('circle')
        .attr('r', radius)
        .attr('fill', color)
        .attr('stroke', '#0d1117')
        .attr('stroke-width', 1.5 / transform.k);

      // Sequence number
      marker.append('text')
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'central')
        .attr('font-size', (8 / transform.k) + 'px')
        .attr('fill', '#fff')
        .attr('font-weight', '700')
        .attr('pointer-events', 'none')
        .text(wp.sequence_order);

      // Tooltip on hover
      marker.append('title')
        .text(wp.waypoint_type + ': ' + (wp.summary || '').substring(0, 80));

      // Click to show path detail
      marker.on('click', function(event) {
        event.stopPropagation();
        if (window.laminarkApp && window.laminarkApp.fetchPathDetail) {
          window.laminarkApp.fetchPathDetail(path.id).then(function(detail) {
            if (detail) {
              document.dispatchEvent(new CustomEvent('laminark:show_path_detail', { detail: detail }));
            }
          });
        }
      });
    });

    // Path label
    if (points.length > 0) {
      var labelX = points[0].x;
      var labelY = points[0].y - 12 / transform.k;
      pathGroup.append('text')
        .attr('class', 'path-label')
        .attr('x', labelX)
        .attr('y', labelY)
        .attr('font-size', (10 / transform.k) + 'px')
        .attr('fill', path.status === 'resolved' ? '#3fb950' : '#d29922')
        .attr('opacity', 0.9)
        .text((path.trigger_summary || 'Debug Path').substring(0, 40));
    }
  });
}
```

**Add SSE handler functions** (called from app.js via window.laminarkGraph):
```
function addPathOverlay(pathEvent) {
  // A new path started — reload overlay
  loadPathOverlay();
}

function updatePathOverlay(waypointEvent) {
  // New waypoint added — reload overlay
  loadPathOverlay();
}

function resolvePathOverlay(resolveEvent) {
  // Path resolved — reload overlay
  loadPathOverlay();
}
```

**Add initPathOverlayToggle() function:**
```
function initPathOverlayToggle() {
  var btn = document.getElementById('paths-toggle-btn');
  if (!btn) return;

  btn.classList.toggle('active', pathOverlayVisible);

  btn.addEventListener('click', function() {
    pathOverlayVisible = !pathOverlayVisible;
    localStorage.setItem('laminark-path-overlay', pathOverlayVisible ? 'true' : 'false');
    btn.classList.toggle('active', pathOverlayVisible);

    if (pathOverlayVisible) {
      loadPathOverlay();
    } else {
      if (pathOverlayGroup) pathOverlayGroup.style('display', 'none');
    }
  });
}
```

**Trigger path overlay load** in loadGraphData(), after the graph renders successfully (around line 708, after the setTimeout for fitToView):
```
// Load path overlay after graph data
if (pathOverlayVisible) {
  setTimeout(function() { loadPathOverlay(); }, 1000);
}
```

**Update the ticked() function** to re-render the path overlay on simulation ticks (since the viewport transform changes). Add at the end of ticked():
```
// Path overlay repositioning is handled via zoom transform, not per-tick
```
Actually, the path overlay uses absolute screen coordinates converted via transform, so it needs re-rendering on zoom. Add to the zoom handler in initGraph() (inside the 'zoom' event, after `updateLevelOfDetail()`):
```
renderPathOverlay();
```

**Update window.laminarkGraph exports** (at the bottom) to include:
```
addPathOverlay: addPathOverlay,
updatePathOverlay: updatePathOverlay,
resolvePathOverlay: resolvePathOverlay,
loadPathOverlay: loadPathOverlay,
isPathOverlayVisible: function() { return pathOverlayVisible; },
```
  </action>
  <verify>Grep for 'pathOverlayGroup' in ui/graph.js to confirm the overlay layer exists. Grep for 'WAYPOINT_TYPE_COLORS' to confirm color map. Grep for 'paths-toggle-btn' to confirm toggle init. Grep for 'loadPathOverlay' in exports to confirm it's exposed.</verify>
  <done>Path overlay renders as animated dashed lines with colored waypoint markers on the D3 graph, positioned as a timeline strip. Toggle, SSE handlers, and exports all wired.</done>
</task>

<task type="auto">
  <name>Task 2: Add toggle button to HTML and animated path styles to CSS</name>
  <files>ui/index.html, ui/styles.css</files>
  <action>
**In ui/index.html**, add a toggle button in the graph toolbar (inside `.graph-toolbar`, after the edge-labels-btn and before analysis-btn, around line 76):
```html
<button id="paths-toggle-btn" class="paths-toggle-btn active" title="Toggle debug path overlay">
  <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
    <path d="M2 8c0-.4.3-.7.7-.7h1.6c.4 0 .7.3.7.7s-.3.7-.7.7H2.7C2.3 8.7 2 8.4 2 8zm4.3 0c0-.4.3-.7.7-.7h1.6c.4 0 .7.3.7.7s-.3.7-.7.7H7C6.6 8.7 6.3 8.4 6.3 8zm4.4 0c0-.4.3-.7.7-.7h1.6c.4 0 .7.3.7.7s-.3.7-.7.7h-1.6c-.4 0-.7-.3-.7-.7z"/>
    <circle cx="2" cy="8" r="1.5"/>
    <circle cx="8" cy="8" r="1.5"/>
    <circle cx="14" cy="8" r="1.5"/>
  </svg>
</button>
```

**In ui/styles.css**, add path overlay styles at the end of the file:

```css
/* ====================================================================
   Path Overlay Styles
   ==================================================================== */

.paths-toggle-btn {
  background: transparent;
  border: 1px solid var(--border);
  color: var(--text-muted);
  padding: 4px 6px;
  border-radius: var(--radius);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all var(--transition);
}

.paths-toggle-btn:hover {
  color: var(--text);
  border-color: var(--text-muted);
}

.paths-toggle-btn.active {
  color: var(--accent);
  border-color: var(--accent);
  background: rgba(88, 166, 255, 0.1);
}

/* Animated dashed line for active paths */
.path-line-active {
  animation: path-dash-flow 1.5s linear infinite;
}

@keyframes path-dash-flow {
  to {
    stroke-dashoffset: -20;
  }
}

/* Waypoint markers */
.waypoint-marker circle {
  transition: r 0.15s ease;
}

.waypoint-marker:hover circle {
  filter: brightness(1.3);
}

/* Path label */
.path-label {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  pointer-events: none;
}

/* Path trail group */
.path-trail {
  pointer-events: all;
}
```
  </action>
  <verify>Grep for 'paths-toggle-btn' in ui/index.html. Grep for 'path-dash-flow' in ui/styles.css. Verify the button appears in the toolbar section of the HTML.</verify>
  <done>Toggle button in toolbar with SVG icon, CSS animation for active path dashed lines, hover effects on waypoint markers.</done>
</task>

</tasks>

<verification>
1. Open the web UI and navigate to the Knowledge Graph view
2. Verify the path toggle button appears in the toolbar (dotted line icon)
3. If debug paths exist in the database, verify they render as animated dashed lines at the bottom of the graph
4. Toggle the button off/on and verify the overlay hides/shows
5. Zoom in/out and verify the overlay repositions correctly
6. Waypoint markers show color coding (red for error, yellow for attempt, green for resolution)
</verification>

<success_criteria>
- pathOverlayGroup SVG layer exists between edges and nodes in paint order
- Waypoint markers colored by type per WAYPOINT_TYPE_COLORS map
- CSS animation creates flowing dashed line effect on active paths
- Toggle button persists state in localStorage
- Path overlay loads data from /api/paths endpoint
- SSE events trigger overlay refresh
- Clicking waypoint markers dispatches laminark:show_path_detail event
</success_criteria>

<output>
After completion, create `.planning/phases/21-graph-visualization/21-02-SUMMARY.md`
</output>
