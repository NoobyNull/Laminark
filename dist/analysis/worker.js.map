{"version":3,"file":"worker.js","names":[],"sources":["../../src/analysis/engines/local-onnx.ts","../../src/analysis/engines/keyword-only.ts","../../src/analysis/embedder.ts","../../src/analysis/worker.ts"],"sourcesContent":["/**\n * Local ONNX embedding engine using @huggingface/transformers.\n *\n * Loads BGE Small EN v1.5 (quantized q8) via dynamic import() for\n * zero startup cost (DQ-04). Model files are cached in ~/.laminark/models/.\n */\n\nimport { join } from 'node:path';\n\nimport { getConfigDir } from '../../shared/config.js';\nimport type { EmbeddingEngine } from '../embedder.js';\n\n// Pipeline type from @huggingface/transformers -- kept as `unknown` to avoid\n// hard dependency on the library's type definitions at import time.\ntype Pipeline = (\n  text: string,\n  options?: { pooling?: string; normalize?: boolean },\n) => Promise<{ data: ArrayLike<number> }>;\n\n/**\n * Embedding engine backed by BGE Small EN v1.5 running locally via ONNX Runtime.\n *\n * All public methods catch errors internally and return null/false.\n */\nexport class LocalOnnxEngine implements EmbeddingEngine {\n  private pipe: Pipeline | null = null;\n  private ready = false;\n\n  /**\n   * Lazily loads the model via dynamic import().\n   *\n   * - Uses `@huggingface/transformers` loaded at runtime (not bundled)\n   * - Caches model files in ~/.laminark/models/\n   * - Returns false on any error (missing runtime, download failure, etc.)\n   */\n  async initialize(): Promise<boolean> {\n    try {\n      const { pipeline, env } = await import('@huggingface/transformers');\n\n      // Cache models in user config directory\n      env.cacheDir = join(getConfigDir(), 'models');\n\n      this.pipe = (await pipeline('feature-extraction', 'Xenova/bge-small-en-v1.5', {\n        dtype: 'q8',\n      })) as unknown as Pipeline;\n\n      this.ready = true;\n      return true;\n    } catch {\n      this.ready = false;\n      return false;\n    }\n  }\n\n  /**\n   * Embeds a single text string into a 384-dimensional vector.\n   *\n   * Returns null if:\n   * - Engine not initialized\n   * - Input is empty/whitespace\n   * - Pipeline throws\n   */\n  async embed(text: string): Promise<Float32Array | null> {\n    if (!this.ready || !this.pipe) {\n      return null;\n    }\n\n    if (!text || text.trim().length === 0) {\n      return null;\n    }\n\n    try {\n      const output = await this.pipe(text, { pooling: 'cls', normalize: true });\n      return Float32Array.from(output.data);\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Embeds multiple texts, preserving order.\n   *\n   * Returns null for any text that was empty or failed.\n   */\n  async embedBatch(texts: string[]): Promise<(Float32Array | null)[]> {\n    const results: (Float32Array | null)[] = [];\n\n    for (const text of texts) {\n      if (!text || text.trim().length === 0) {\n        results.push(null);\n      } else {\n        results.push(await this.embed(text));\n      }\n    }\n\n    return results;\n  }\n\n  /** BGE Small EN v1.5 produces 384-dimensional embeddings. */\n  dimensions(): number {\n    return 384;\n  }\n\n  /** Engine identifier. */\n  name(): string {\n    return 'bge-small-en-v1.5-q8';\n  }\n\n  /** Whether the model loaded successfully. */\n  isReady(): boolean {\n    return this.ready;\n  }\n}\n","/**\n * Null fallback embedding engine for graceful degradation (DQ-03).\n *\n * Used when the ONNX runtime or model is unavailable.\n * All embedding methods return null -- search falls back to keyword-only (FTS5).\n */\n\nimport type { EmbeddingEngine } from '../embedder.js';\n\n/**\n * Embedding engine that produces no embeddings.\n *\n * Acts as a silent fallback so that the rest of the system can\n * operate in keyword-only mode without special-casing missing engines.\n */\nexport class KeywordOnlyEngine implements EmbeddingEngine {\n  /** Always returns null -- no model available. */\n  async embed(): Promise<Float32Array | null> {\n    return null;\n  }\n\n  /** Returns array of nulls matching input length. */\n  async embedBatch(texts: string[]): Promise<(Float32Array | null)[]> {\n    return texts.map(() => null);\n  }\n\n  /** No dimensions -- no model. */\n  dimensions(): number {\n    return 0;\n  }\n\n  /** Engine identifier. */\n  name(): string {\n    return 'keyword-only';\n  }\n\n  /** Intentionally returns false -- this engine has no model. */\n  async initialize(): Promise<boolean> {\n    return false;\n  }\n\n  /** Always false -- no model loaded. */\n  isReady(): boolean {\n    return false;\n  }\n}\n","/**\n * EmbeddingEngine interface and factory.\n *\n * Defines the pluggable abstraction for text embedding.\n * All consumers depend on this interface -- never on concrete engines.\n */\n\nimport { LocalOnnxEngine } from './engines/local-onnx.js';\nimport { KeywordOnlyEngine } from './engines/keyword-only.js';\n\n/**\n * Pluggable embedding engine abstraction.\n *\n * All methods that can fail return null/false -- engines NEVER throw.\n * This is critical for graceful degradation (DQ-03).\n */\nexport interface EmbeddingEngine {\n  /** Embed a single text string. Returns null on failure or empty input. */\n  embed(text: string): Promise<Float32Array | null>;\n\n  /** Embed multiple texts. Returns null for any that failed or were empty. */\n  embedBatch(texts: string[]): Promise<(Float32Array | null)[]>;\n\n  /** Embedding dimensions (384 for BGE Small, 0 for keyword-only). */\n  dimensions(): number;\n\n  /** Engine identifier string. */\n  name(): string;\n\n  /** Lazy initialization. Returns true on success, false on failure. */\n  initialize(): Promise<boolean>;\n\n  /** Whether initialize() has been called and succeeded. */\n  isReady(): boolean;\n}\n\n/**\n * Creates and initializes an embedding engine.\n *\n * Attempts LocalOnnxEngine first. If initialization fails (missing model,\n * ONNX runtime unavailable, etc.), falls back to KeywordOnlyEngine.\n *\n * Never throws -- always returns a valid engine.\n */\nexport async function createEmbeddingEngine(): Promise<EmbeddingEngine> {\n  const onnxEngine = new LocalOnnxEngine();\n  const success = await onnxEngine.initialize();\n\n  if (success) {\n    return onnxEngine;\n  }\n\n  return new KeywordOnlyEngine();\n}\n","/**\n * Worker thread entry point for off-main-thread embedding.\n *\n * Receives embed/embed_batch/shutdown messages from the main thread via\n * parentPort, runs the embedding engine, and responds with Float32Array\n * results using zero-copy transfer.\n *\n * Compiled as a separate tsdown entry point to dist/analysis/worker.js.\n */\n\nimport { parentPort } from 'node:worker_threads';\nimport { createEmbeddingEngine } from './embedder.js';\n\nif (!parentPort) {\n  throw new Error('worker.ts must be run as a Worker thread');\n}\n\nconst port = parentPort;\n\ninterface EmbedMessage {\n  type: 'embed';\n  id: string;\n  text: string;\n}\n\ninterface EmbedBatchMessage {\n  type: 'embed_batch';\n  id: string;\n  texts: string[];\n}\n\ninterface ShutdownMessage {\n  type: 'shutdown';\n}\n\ntype WorkerMessage = EmbedMessage | EmbedBatchMessage | ShutdownMessage;\n\nasync function init(): Promise<void> {\n  let engineName = 'keyword-only';\n  let dimensions = 0;\n\n  try {\n    const engine = await createEmbeddingEngine();\n    engineName = engine.name();\n    dimensions = engine.dimensions();\n\n    port.postMessage({ type: 'ready', engineName, dimensions });\n\n    port.on('message', async (msg: WorkerMessage) => {\n      if (msg.type === 'embed') {\n        try {\n          const embedding = await engine.embed(msg.text);\n\n          if (embedding === null) {\n            port.postMessage({ type: 'embed_result', id: msg.id, embedding: null });\n          } else {\n            // Zero-copy transfer of the underlying ArrayBuffer\n            const buf = embedding.buffer as ArrayBuffer;\n            port.postMessage(\n              { type: 'embed_result', id: msg.id, embedding },\n              [buf],\n            );\n          }\n        } catch {\n          port.postMessage({ type: 'embed_result', id: msg.id, embedding: null });\n        }\n      } else if (msg.type === 'embed_batch') {\n        try {\n          const embeddings = await engine.embedBatch(msg.texts);\n\n          // Collect non-null buffers for zero-copy transfer\n          const transferList: ArrayBuffer[] = [];\n          for (const emb of embeddings) {\n            if (emb !== null) {\n              transferList.push(emb.buffer as ArrayBuffer);\n            }\n          }\n\n          port.postMessage(\n            { type: 'embed_batch_result', id: msg.id, embeddings },\n            transferList,\n          );\n        } catch {\n          port.postMessage({\n            type: 'embed_batch_result',\n            id: msg.id,\n            embeddings: msg.texts.map(() => null),\n          });\n        }\n      } else if (msg.type === 'shutdown') {\n        process.exit(0);\n      }\n    });\n  } catch {\n    // Engine creation failed -- still report ready with keyword-only fallback\n    port.postMessage({ type: 'ready', engineName, dimensions });\n\n    port.on('message', (msg: WorkerMessage) => {\n      if (msg.type === 'embed') {\n        port.postMessage({ type: 'embed_result', id: msg.id, embedding: null });\n      } else if (msg.type === 'embed_batch') {\n        port.postMessage({\n          type: 'embed_batch_result',\n          id: msg.id,\n          embeddings: msg.texts.map(() => null),\n        });\n      } else if (msg.type === 'shutdown') {\n        process.exit(0);\n      }\n    });\n  }\n}\n\ninit();\n"],"mappings":"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"}